

# JAVA学习笔记

##   java介绍

1990年 sun公司启动绿色计划

1992年 创建oak（橡树）语言-->java

1994 gosling 参加硅谷大会演示java功能，震惊世界

1995 sun正式发布java第一个版本。

2009年，甲骨文公司宣布收购sun，2011，发布java7

java其他版本：https://www.oracle.com/cn/java/technologies/downloads/

java技术体系平台

**java SE（java Standard Edition）标准版**

支持面向桌面级应用，提供完整的java核心api，此版本之前称为J2SE

**Java EE(java Enterprise Edition)企业版**

是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如：servlet，jsp等，主要针对web应用程序开发，版本以前称为J2EE

**java ME（java Micro Edition）小型版**

支持java程序运行在移动终端（手机，pad）上的平台，对java api有所精简，并加入针对移动终端的支持，此版本以前称为J2ME

java 重要特点

1. java语言是面向对象的（oop）
2. java语言是健壮的，java的强类型机制，异常处理，垃圾的自动收集等是java程序健壮性的重要保证
3. java语言是跨平台型的
4. java语言是解释型的
   解释型语言：JavaScript，PHP，java 编译型语言：c /c++
   区别是：解释型语言，编译后的代码，不能直接被机器执行，需要解释器来执行，编译型语言，编译后的代码，可以直接被机器执行。

JVM java虚拟机是java跨平台的关键。

`javac`命令编译java文件为class文件   `java`命令运行编译后的class文件

JDK java开发工具包 JDK = JRE+java开发工具

JRE java运行环境  JRE = JVM + java的核心类库

java11 中午api文档：https://www.apiref.com/java11-zh/index.html

## java快速入门

`public static void main(String[] args)`表示一个主方法，即程序的入口。

`;`表示一段语句的结束

`javac Hello.java`文件名和类名一致，类名首字母应该大写

`java Hello` 运行java文件实际是运行hello这个类，所以不能写`java Hello.class`这样写系统会去找Hello.class这个类，肯定是找不到的，所以会报错。

一个文件中只能有一个public 类，其他类的个数不限。每一个类编译后都对应生成一个class文件

## 转义字符

`\t`一个制表位，实现对齐的功能

`\n` 换行符

`\\` 一个\

`\"`一个"

`\'`一个‘

`\r` 一个回车，回车和换行的区别：回车后光标移到第一的位置并不换行，如果有输出则会覆盖原来的内容，换行则在下一行输出。回车+换行 的效果 = 换行

## 注释

单行注释  //注释文字

多行注释  /*  注释文字  */

文档注释 /**  

  		*/

文档注释可以生成一套文档网页文件，

生成命令：`javadoc -d 文件夹名 -author -version Demo.java`

-author -version 为注释的作者，版本或参数等注释信息

## 变量

变量的使用步骤：

1. 声明变量 int a
2. 赋值变量 a = 60
3. 使用变量  System.out.println(a)

也可以简化直接一步到位：int a = 60

## +号的使用

程序中+号的使用

1. 当左右两边都是数值型时，则做加法运算
2. 当左右两侧有一方为字符串，则做拼接运算

## 数据类型

### 基本数据类型

数值型

| 整数类型 | 数据空间（字节） | 数据范围                                                     |
| -------- | ---------------- | ------------------------------------------------------------ |
| byte     | 1                | -128 到 127                                                  |
| short    | 2                | -2¹⁵ 到 (2¹⁵ - 1)<br />-32,768 到 32,767                     |
| int      | 4                | -2³¹ 到 (2³¹ - 1)<br />-2,147,483,648 到 2,147,483,647大约 ±21亿 |
| long     | 8                | -2⁶³ 到 (2⁶³ - 1)<br />long bigNumber = 9223372036854775807L; // 必须加L |

| 浮点类型 | 数据空间（字节） | 数据范围                                                     |
| -------- | ---------------- | ------------------------------------------------------------ |
| float    | 4                | ±3.40282347E+38F (6-7 位有效小数位)<br/>小数默认是双精度如果声明单精数，具体值结尾必须带f（float a = 1.2f） |
| double   | 8                | ±1.79769313486231570E+308 (15 位有效小数位)                  |

浮点数 = 符号位+指数位+尾数位（尾数部分可能丢失，造成精度损失，小数都是近似值）

**浮点数使用陷阱：8.1/3 = 2.69999997 当我们对运算结果是小数的结果进行相等判断时，要小心。**通常用两个数的差值小于某个精度就认为相等，如果两个数是没有结果计算的小数是可以直接判断是否相等的。

| 字符型 | 数据空间（字节） | 数据范围        |
| ------ | ---------------- | --------------- |
| char   | 2                | 单个字符例：'a' |

'a'是char类型，"a"则是String类型

字符型 + 数字 = 字符对应的unicode码 + 数字

ascII是0--127 共128个字符

| 布尔型  | 数据空间（字节） | 数据范围   |
| ------- | ---------------- | ---------- |
| boolean | 1                | true/false |

不可以用0或非0的整数替代false和true。

### 基本数据类型的转换

#### 自动类型转换

当java程序在进行赋值或运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换。

数据类型按精度大小（容量）排序如下：

char--》int---》long--》float---》double

byte--》short---》int---》long---》float---》double

```java
int a = 'a'; // 字符赋值给int是可以的
double b = 80; // 整型赋值给双精度也是可以的
```

自动类型转换的细节：

1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。
2. 当我们把精度大的数据类型赋值给精度小的数据类型时，就会报错，反之就会自动类型转换。
3. byte，short 和char之间不会相互自动转换，三者可以混合计算，在计算时首先转换成int类型。
4. boolean不参与自动类型转换
5. 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型

#### 强制类型转换

自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型，使用时要加上强制转换符`()`，但可能造成精度降低或者溢出，格外要注意。

注意细节：

强转符号只对最近的操作数有效，往往会使用小括号提升优先级

```java
int x = (int)10*3.5+6*1.5 // 错误，只转换了10，并不是转换整个结果
int x = (int)(10*3.5+6*1.5) //正确，这样才转换整个的结果
```

char类型可以保存int的常量值，但不能保存int的变量值，需要强转

```java
char c1 = 100; // ok,保存100对应的unicode码
int m = 100;
char c2 = m;  // 不行，会报类型不一致的错误
char c3 = (char)m; //ok
```

byte，short和char类型在进行运算时，当做int类型处理。

- 基本数据类型转string类型，`+ ""`即可。
- string类型转基本数据类型，通过基本类型的包装类调用`parseXX`方法记录。`Interger.parseInt("123")`
- 把字符串转成字符char：`a = "123"; b = a.charAt(0)`，只能取字符串中的某一个字符。

string类型转基本数据类型的注意事项：

1. 将string转基本数据类型时，要确保string类型能够转成有效的数据，比如我们可以把“123”，转成一个整数，但是不能把“hello”转成整数。
2. 如果格式不正确，就会抛出异常，程序就会终止，这个问题在异常处理章节中，会处理

### 引用数据类型

类 class

接口 interface

数组 [ ]

## 运算符

### 算术运算符

| 运算符 | 运算                                             | 范例                      | 结果                |
| ------ | ------------------------------------------------ | ------------------------- | ------------------- |
| +      | 正号                                             | +7                        | 7                   |
| -      | 负号                                             | b=11;-b                   | -11                 |
| +      | 加                                               | 9+9                       | 18                  |
| -      | 减                                               | 10-8                      | 2                   |
| *      | 乘                                               | 7*8                       | 56                  |
| /      | 除                                               | 9/3                       | 3                   |
| %      | 取模（取余）                                     | 11%9                      | 2                   |
| ++     | 自增(前):先运算后取值<br />自增(后):先取值后运算 | a=2;b=++a;<br/>a=2;c=a++; | a=3;b=3<br/>a=3;c=2 |
| --     | 自减(前):先运算后取值<br />自减(后):先取值后运算 | a=2;b=--a;<br/>a=2;c=a--; | a=1;b=1<br/>a=1;c=2 |
| +      | 字符串相加                                       | "java"+"kc"               | "javakc"            |

```java
-10.5%3 = -1.5
// float 求余的公式：a%b = a - (int)a/b*b
//-10.5 -(-10)/3*3 =》-10.5-（-3*3）=》-10.5+9=》-1.5

System.out.println(10/4); //从数学来看是2.5 java结果为2 因为两个int运算结果为int
System.out.println(10.0/4) //结果为2.5 double除int结果为double
```

取模的公式：`a % b = a-(int)a/b*b`

自增自减如果独立使用，i++ 和 ++i是一样的，如果作为表达式使用则不同。

```java
int i =1;
i=i++;
System.out.println(i);
//结果是多少? i = i++赋值时会使用临时变量
//使用临时变量规则1.temp = i 2.i++ 3.i=temp
// 所以应该输出 1

int i =1;
i=++i;  //先计算再赋值，1.i=i+1 2.temp=i 3.i= temp
System.out.println(i); //结果就是2
```

print()和println()的区别，带ln的会自动换行

### 关系运算符

关系运算符的结果都是boolen型，关系表达式经常用在if结构的条件中或循环结构的条件中。

| 运算符     | 运算               | 范例                    | 结果  |
| ---------- | ------------------ | ----------------------- | ----- |
| ==         | 相等于             | 8==7                    | false |
| !=         | 不等于             | 8!=7                    | true  |
| <          | 小于               | 8<7                     | false |
| >          | 大于               | 8>7                     | true  |
| <=         | 小于等于           | 8<=7                    | false |
| >=         | 大于等于           | 8>=7                    | true  |
| instanceof | 检查是否是类的对象 | "abc" instanceof String | true  |

### 逻辑运算符

用于连接多个条件（多个关系表达式），最终的结果也是一个boolen值。

1. 短路与 ：&&(当a和b同时为true，则为true，否则为false)
   短路或：||(当a和b有一个为true，则为true，否则为false)
   取反：!
2. 逻辑与：&(当a和b同时为true，则为true，否则为false)
   逻辑或：|(当a和b有一个为true，则为true，否则为false)
   逻辑异或：^（当a和b不同时，为true，否则为false）

| a     | b     | a&b   | a&&b  | a\|b  | a\|\|b | !a    | a^b   |
| ----- | ----- | ----- | ----- | ----- | ------ | ----- | ----- |
| true  | true  | true  | true  | true  | true   | false | false |
| true  | false | false | false | true  | true   | false | true  |
| false | true  | false | false | true  | true   | true  | true  |
| false | false | false | false | false | false  | true  | false |

&& 和&使用区别

1. &&短路与：如果第一个条件为false，则第二个条件不会判断，最终结果为false，效率高
2. &逻辑与：不管第一个条件是否为false，第二个条件都要判断，效率低
3. 开发中，我们使用的基本都是短路与&&，效率高

||和|使用区别

1. ||短路或：如果第一个条件为ture，则第二个添加不会判断，最终结果为true，效率高
2. 逻辑或：不管第一个条件是否为true，第二个条件都要判断，效率低
3. 开发中，我们基本使用||

### 赋值运算符

赋值运算符就是将某个运算后的值，赋给指定的变量。

复合赋值运算符：+= 、-+、*=、 /= 、%=

a += b  ==> a = a + b

赋值运算符特点

1. 运算顺序从右往左 `int num = a+b+c;`先计算a+b+c再赋值。
2. 赋值运算符的左边只能是变量，右边可以是变量，表达式，常量
3. 复合赋值运算符等价于下面的效果
   比如：a -= 3; 等价于 a = a -3;
4. 复合赋值预算法会进行类型转换
   byte b = 2; b +=3; b++;  此时b += 3 ==》b = (byte)(b+3)会进行类型转换把b+3的结果转换成byte。
   byte b = 2; b = b + 3; 则会直接报错，因为b的类型为byte,b+3的结果是int，会报类型不兼容类型的错误。

### 三元运算符

条件表达式 ？表达式1 ：表达式2;

如果条件表达式为true，运算后的结果是表达式1；

如果条件表达式为false，运算后的结果是表达式2；

注意细节：

表达式1和表达式2要为可以赋给接收变量的类型（或可以自动转换或者强制转换）

### 运算符的优先级

|         | .  ()  {}  ;  ,                        |
| ------- | -------------------------------------- |
| R --> L | ++  --  ~   !(data type)               |
| L-->R   | *  /  %                                |
| L-->R   | + -                                    |
| L-->R   | <<(左位移)   >>(右位移)  >>>(逻辑右移) |
| L-->R   | <  >  <=  >=  instanceof               |
| L-->R   | ==  !=                                 |
| L-->R   | &                                      |
| L-->R   | ^                                      |
| L-->R   | \|                                     |
| L-->R   | &&                                     |
| L-->R   | \|\|                                   |
| L-->R   | ?   :                                  |
| R-->L   | = *=  /=  %=                           |
| R-->L   | +=   -=   <<=   >>=                    |
| R-->L   | >>>=  &=   ^=  \|=                     |

运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如上表，上一行运算符总优先于下一行。

只有单目运算符，赋值运算符是从右向左运算的。
运算符优先级顺序分类：

1. （）{} ，等
2. 单目运算 ++   --
3. 算术运算符
4. 位移运算符
5. 比较运算符
6. 逻辑运算符
7. 三元运算符
8. 赋值运算符

### 标识符规则

java对各种变量，方法和类等命名时使用的字符序列称为标识符

凡是自己可以起名字的地方都叫标识符

标识符的命名规则（必须遵守）

1. 由26个英文字母大小写，0-9，_或$组成
2. 数字不可以开头
3. 不可以使用关键字和保留字，但能包含关键字和保留字
4. java中严格区分大小写，长度无限制
5. 标识符不能包含空格

标识符命名规范【更加专业】

1. 包名：多单词组成时所有字母都小写
2. 类名\接口名：多单词组成时，所有单词的首字母大写【大驼峰】
3. 变量名\方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写【小驼峰，简称驼峰法】
4. 常量名：所有字母都大写。多单词时每个单词用下划线连接
5. 后面我们学习到类，包，接口等时，我们的命名规范要这样遵守，更加详细的看文档。

### 键盘输入

接收用户输入的数据，就可以使用键盘输入语句获取，键盘输入需要一个扫描器（对象），就是Scanner。

步骤：
1.导入该类的所在包，java.util.*

2.创建该类的对象

3.调用里面的功能

```java
import java.until.Scanner;//Scanner类 表示简单文本扫描器
public class Input{
    public staic void main(String[] args){
        //创建一个Scanner对象
        Scanner myScanner = new Scanner(System.in);
        System.out.println("请输入名字");
        String name = mySacnner.next(); //接收用户输入字符串
        System.out.println("请输入年龄");
        int name = mySacnner.nextInt(); //接收用户输入int
        System.out.println("请输入薪水");
        double salary = mySacnner.nextDouble(); //接收用户输入double
    }
}

```

### 进制

对于整数，有四种表示方式：

1.二进制：0,1 满2进1，以0b或0B开头。

2.十进制：0-9，满10进1.

3.八进制：0-7，满8进1，以数字0开头表示。

4.十六进制：0-9及A(10)-F(15)，满16进1.以0x或0X开头表示。此处的A-F不区分大小写。

二、八、十六进制转十进制：位数上的值X进制的(位数-1)次方然后相加的和

十进制转二、八、十六进制：十进制数不断除以要转的进制，得到每次的余数，直到商为0为止，然后将每步的余数倒过来就是对应的进制数。

二进制转八进制：从低位开始，将二进制数每三位一组，转成对应的八进制即可。

二进制转十六进制：从低位开始，将二进制数每四位一组，转成对应的十六进制即可。

八进制转二进制：将八进制数每1位转成对应的一个3位的二进制数即可。

十六进制转二进制：将十六进制数每1位转成对应的一个4位的二进制数即可。

### 原码、反码、补码

1. 二进制的最高位是符号位：0表示正数，1表示负数
2. 正数的原码，反码、补码都一样(三码合一)
3. 负数的反码 = 它的原码符号位不变，其他位取反
4. 负数的补码 = 它的反码+1，负数的反码 = 负数的补码 -1
5. 0的反码，补码都是0
6. java没有无符号数，换言之，java中的数都是有符号的
7. 在计算机运算的时候，都是以**补码的方式来运算**的
8. 当我们看运算结果的时候，要看他的原码

### 位运算符

java中有7个位运算（&、|、^、~、>>、<<、>>>）

&按位与运算规则：两位全为1，结果为1，否则为0

|按位或运算规则：两位有一个为1，结果为1，否则为0

^按位异或运算规则：两位一个为0一个为1，结果为1，否则为0

~按位取反运算规则：0变1，1变0

\>>算术右移：低位溢出，符号位不变，并用符号位补溢出的高位（本质就是>>1就是除以2只取整数部分）

<<算术左移：符号位不变，低位补0（本质就是<<1就是乘以2）

\>\>>逻辑右移也叫无符号右移，运算规则是：低位溢出，高位补0

特别说明：没有<<<符号

## 控制结构

### 分支控制

#### 单分支

if(条件表达式){

​	执行代码块

}

#### 双分支

if(条件表达式){

​	执行代码块1

}else{

​	执行代码块2

}

#### 多分支

if(条件表达式1){

​	执行代码块1

}else if(条件表达式2){

​	执行代码块2

}...

else{

​	执行代码块n

}

多分支可以没有else

#### 嵌套分支

一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支结构称为内层分支，外面的分支结构称为外层分支。规范：不要超过3层

if(){

​	if(){

​	}else{

​	}

}

#### switch分支结构

switch(表达式){

​	case 常量1：

​		语句块1;

​		break;

​	case 常量2：

​		语句块2;

​		break;

​	....

​	case 常量n：

​		语句块n;

​		break;

​	default:
​		default语句块;

​		break;

}

switch注意事项：

1. 表达式数据类型应和case后的常量**类型一致**，或者是可以自动转成可以相互比较的类型
2. swtich(表达式)中表达式的返回值必须是：byte，short，int，char，enum(枚举)，String中的一种
3. case子句中的值必须是常量或者常量表达式，不能是变量
4. default子句是可选的，当没有匹配的case时，执行default
5. break语句用来在执行完一个case分支后使程序跳出switch语句块，如果没有写break，程序会顺序执行到switch结尾，除非遇到break。

### 循环控制

#### for循环

for(循环变量初始化;循环条件;循环变量迭代){

​	循环操作（语句）;

}

注意事项：

1. 循环添加是返回一个布尔值的表达式

2. for(;循环判断条件;)中的初始化和变量迭代可以写到其他地方，但是两边的分号不能省略。
   ```java
   for(;;){
       //表示一个死循环，可以配合break;完成特殊功能
   }
   ```

   

3. 循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开

   

#### while循环

循环变量初始化;

while(循环条件){

​	循环体（语句）;

​	循环变量迭代;

}

while循环是先判断再执行

#### do..while循环

循环变量初始化;

do{

​	循环体（语句）;

​	循环变量迭代;

}while(循环条件);

说明：do while是关键字

也有循环四要素，只是位置不一样

先执行，后判断，也就是说，一定会执行一次

最后又一个分号;

#### 多重循环控制

将一个循环放在另一个循环体内就形成了嵌套循环。其中for，while，do..while均可作为外层循环和内层循环。

实质上嵌套循环就是把内层循环当成外层循环的循环体，当只有内层循环的循环添加为false时，才会跳出内层循环，才可结束外层的当次循环，开始下一次的循环

当外层循环次数为m次，内层为n次，则内层循环实际上需要执行m*n次。

#### 跳转控制语句break

循环，但是循环的次数不知道，当某个条件满足时，可以通过break终止循环。

注意事项：

break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是那一层语句块。

```java
lable1:
for(int j=0;j<4;j++){
    lable2:
    for(int i=0;i<10;i++){
        if(i==2){
            // 通过lable指定退出哪层循环
            break lable1;
        }
        System.out.println("i="+i);
    }
}
```

没有指定标签，break默认退出最近的循环体。

#### 跳转控制语句continue

continue语句用于结束本次循环，继续执行下一次循环。

continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是那一层循环，和break的标签使用规则一样。

#### 跳转控制语句return

return使用在方法中，表示跳出所在的方法。如果return写在main方法，会退出程序。

## 数组、排序、查找

#### 数组

数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。即：数组就是一组数据

```java
// 1.静态初始化
double[] array = {3,5,1,3.4,2,50} //double 类型的数组
//2.动态初始化
int a[] = new int[3] //表示定义一个int数组a，存放3个int类型是数
int = {1,2,3};
//3.动态初始化2
int a[] //先声明数组
a = new int[]{2,3,4}; //再创建数组 new 就是分配空间
//或者只创建数据空间不赋值
a = new int[2];

```

数组注意事项：

1. 数组元素是相同数据类型或可以自动数据转换
2. 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。
3. 数组创建后，如果没有赋值，会默认值int 0，short 0，byte 0，long 0，float 0.0，double 0.0，char \u0000，boolean false，String null
4. 使用数组的步骤：声明数组并开辟空间》给数组各个元素赋值》使用数组
5. 数组的下标是从0开始的
6. 数组下标必须在指定范围内使用，否则报：下标越界异常，比如int[] arr=new int[5];有效下标为0-4
7. 数组属引用类型，数字型数据是对象（object）



#### 数组赋值机制 

基本数据类型赋值，赋值方式为值拷贝，相互不影响。

数组在默认情况下是引用传递，赋的值是内存地址。

```java
int[] arr1 = {10,20,30};
int[] arr2 = arr1;
arr2[0] = 40;
System.out.println(arr1[0]);
//因为arr2是引用的arr1的地址，改变arr2后arr1[0]会变成40
```

数组的拷贝

```java
int[] arr1 = {10,20,30};
int[] arr2 = new int[arr1.length];
for(i=0;i<arr1.length;i++){
    arr2[i] = arr1[i];
}
arr2[0] = 40;
//此时为数组拷贝，改变arr2[0]的值，不影响arr1
```

数组添加

```java
int[] arr = {1,2,3};
//给数字添加元素使用其他语言的arr[3]=4这种方法是不行的
//应该使用下面的方法
int[] arrNew = new int[arr.length+1];
//遍历arr数组，依次将元素拷贝得arrNew数组
for(int i=0;i<arr.length;i++){
    arrNew[i] = arr[i];
}
//把4赋给arrNew最后一个元素 
arrNew[arrNew.length-1] = 4;
//让arr指向arrNew
arr = arrNew;
```

#### 排序

排序是将多个数据，依指定的顺序进行排列的过程。

1.内部排序
将需要处理的所有数据都加载到内存中进行排序。包括（交换式排序法、旋转式排序法和插入式排序法）

2.外部排序

数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）

冒泡排序实例

```java
int[] arr ={24,69,80,57,13};
//外层循环控制循环轮数
for(int i=arr.length-1;i>0;i--){
    //内层循环每轮的次数
    for(int j=0; j<i; j++){
        if(arr[j]>arr[j+1]){
            temp=arr[j];
            arr[j]=arr[j+1];
            arr[j+1]=temp;
        }
    }
}

```

字符串的比较使用`equals()`函数

```java
String a = "金毛狮王";
if(a.equals("白眉鹰王")){
    System.out.print('字符串一样');
}else{
    System.out.print('字符串不一样');
}
```

#### 二维数组

int\[][] 来标识二维数组

```java
int[][] arr = {{0,0,0,0,0},{0,1,0,0,0},{2,0,3,0,0}};
//遍历二维数组
for(int i=0;i<arr.length;i++){
    for(int j=0;j<arr[i].length;j++){
        System.out.print(arr[i][j]+" ");
    }
    System.out.println();
}
```

二维数组动态初始化

```java
int arr[][] = new int[2][3];
arr[1][1] = 8;
int arr[][] = new int[3][];//定义一个二维数组，一维数组的元素数不一样多，这种二维数组称为列数不等的二维数组。
```

打印杨辉三角

```java
int[][] yang = new int[10][];
//生成杨辉三角
for(int i=0;i<yang.length;i++){
    yang[i] = new int[i+1];给每个一维数组开空间
    for(int j=0;j<yang[i].length;j++){
        if(j==0 || j ==yang[i].length -1){
            //每一行的第一个元素和最后一个元素都是1
            yang[i][j] = 1;
        }else{
            //中间元素是上一行同列和上一行同列的前一位的和
            yang[i][j] = yang[i-1][j]+yang[i-1][j-1];
        }
    }
}
//输出杨辉三角
for(int i=0;i<yang.length;i++){
    for(int j=0;j<yang[i].length;j++){
        System.out.print(yang[i][j]+"\t");
    }
    System.out.println();
}
```

二维数组的三种声明方式：

```java
int[][] arr;
int[] arr[];
int arr[][];
```

## 类与对象

对象在内存中的存在形式如下图：（类是引用数据类型）

![2025-09-18_222833](.\img\2025-09-18_222833.png)

类的属性也叫成员变量。属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型（对象，数组）。

注意事项：

1.属性的定义语法同变量，示例：访问修饰符 属性类型 属性名;

2.属性的定义类型可以为任意类型，包含基本类型或引用类型
默认值int 0，short 0，byte 0，long 0，float 0.0，double 0.0，char \u0000，boolean false，String null

3.属性如果不赋值，有默认值，规则和数组一致。

### 创建对象

1.先声明再创建

```java
Cat cat; //声明对象
cat = new Cat();   //创建 
```

2.直接创建

```java
Cat cat = new Cat();
```

访问属性：对象名.属性名

### 类和对象的内存分配机制

```java
Person p = new Person();
p.age = 10;
Person p1 = p;
// p1指向 p对象对应的内存地址
```

java内存的结构分析：
1.栈：一般存放基本数据类型（局部变量）

2.堆：存放对象（Cat cat，数组等）

3.方法区：常量池（常量，比如字符串），类加载信息

创建对象的流程：

1.先加载Person类信息（属性，方法，只会加载一次）

2.在堆中分配空间，进行默认初始化，吧堆的内存地址赋给p

3.进行指定初始化，如 p.age = 10 

### 成员方法

```java
class Person{
    String name;
    int age;
    //public 表示方法是公开的
    //void 表示方法没有返回值（如果有返回值就写返回值的类型）
    //speak 方法名
    //() 形参列表  括号空，表示没有传入参数
    //{ } 方法体，写要执行的代码
    // 方法写好后，不调用（使用），不会执行（输出 ）
    public void speak(){
        System.out.println("我是一个好人");
    }
}
```

![2025-09-19_215307](.\img\2025-09-19_215307.png)

方法调用小结：

1.当程序执行到方法时，就会开辟一个独立的空间（栈空间）

2.当方法执行完毕，或者执行到return语句时，就会返回

3.放回到调用方法的地方，返回后继续执行方法后面的代码

成员方法的优势：

1.提高代码的复用性

2.可以将实现的细节封装起来，然后供其他用户来调用即可。

**方法的注意事项：**

- 访问修饰符：（作用是控制方法使用的范围）可选，有四种public，protected，default(默认的，可以不写)，private。

- 返回数据类型

1.一个方法最多有一个返回值。

2.返回类型可以为任意类型，包含基本类型或引用类型

3.如果方法要求有返回数据类型，则方法体中最后的执行语句必须有return值，而且要求返回值类型和return的值类型一致或兼容

4.如果方法是void，则方法体中可以没有return语句，或者只写return

- 方法名：遵循驼峰命名法，最好见名知意。
- 形参列表

1.一个方法可以有0个参数，也可以有多个参数，中间用逗号分隔

2.参数类型可以是任意类型，包含基本类型或引用类型

3.调用到参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数

4.方法定义是的参数称为形式参数，简称形参，方法调用时的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容，个数，顺序必须一致

- 方法体

里面写完成功能的具体语句，可以为输入，输出，变量，运算，分支，循环，方法调用，但是不能再定义方法，即方法不能嵌套定义。

- 方法调用

1.同一个类中的方法调用，直接调用即可

2.跨类中的方法A类调用B类方法：需要通过对象名调用

3.特别说明一下：跨类的方法调用和方法的访问修饰符相关。

### 成员方法传参机制

基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参

引用类型传递的是内存地址，可以通过形参影响实参。

如果引用类型传递给方法，方法内的变量改变(新的引用不是改变引用类型的值)则不会改变引用类型的数据（即方法内变量指向的引用类型的内存地址改变了，指向了新的地址，所以原来的引用数据不受影响）。

### 递归调用

递归规则：

1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
2. 方法的局部变量（基础数据类型）是独立的，不会相互影响
3. 如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据
4. 递归必须向退出递归的添加逼近，否则就是无限递归，出现StackOverflowError，死归了
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

### 方法重载OverLoad

java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致！

重载的好处：

1.减轻起名的麻烦

2.减轻记名的麻烦

重载的注意事项：

1.方法名：必须相同

2.形参列表：必须不同（形参类型或个数或顺序，至少一个不同，实参名无要求）

3.返回类型：无要求

### 可变参数

java运行将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。就可以通过可变参数实现

基本语法：访问修饰符 返回类型 方法名(数据类型**...** 形参名){ }

```java
class HspMethod{
    //需求可以计算2个数，3个数，4,5个数的和
    //可以通过方法重载实现
    public int sum(int n1,int n2){
        return n1+n2;
    }
    
    public int sum(int n1,int n2,int n3){
        return n1+n2+n3;
    }

    public int sum(int n1,int n2,int n3,int n4){
        return n1+n2+n3+n4;
    }
    //方法重载还是不方便，对于上面三个方法，方法名相同，功能相同，参数个数不同可以使用可变参数优化
    public int sum(int... nums){
        //int... 表示接受的是可变参数，类型是int，即可以接受多个int（0或多），使用可变参数是，可以当做数组来使用，即nums可以当做数组
        int res = 0;
        for(int i=0;i<nums.length;i++){
            res += nums[i];
        }
        return res;
    }
}
```

可变参数的注意事项：

1. 可变参数的实参可以为0个或多个。
2. 可变参数的实参可以是数组。
3. 可变参数的本质就是数组。
4. 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
5. 一个形参列表中只能出现一个可变参数

### 变量作用域

在java编程中，主要的变量就是属性（成员变量）和局部变量。

我们说的局部变量一般是指在成员方法中定义的变量

java中作用域的分类：

- 全局变量：也就是属性，作用域是整个类
- 局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中

全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值。

作用域注意事项：

1. 属性和局部变量可以重名，访问时遵循就近原则
2. 同一个作用域中，比如在同一个成员方法中，两个局部变量不能重名
3. 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中。
4. 作用域范围不同
   全局变量：可以被本类使用，或其他类使用（通过对象调用）
   局部变量：只能在本类的方法中使用
5. 修饰符不同
   全局变量/属性可以加修饰符
   局部变量不可以加修饰符 

### 构造方法/构造器

构造方法又叫构造器（constructor），是类的一种特殊的方法，它的主要作用是完成对新对象的属性初始化。

基本语法

修饰符 方法名(形参列表){	方法体;  }

说明：

1. 构造器的修饰符可以默认，也可以是public protected private
2. 构造器没有返回值，也不能写void
3. 方法名和类名必须一样
4. 参数列表和成员方法一样的规则
5. 构造器的调用，由系统来完成

构造器的注意事项：

1. 一个类可以定义多个不同的构造器，即构造器重载
2. 构造器名和类名要相同
3. 构造器没有返回值
4. 构造器是完成对象的初始化，并不是创建对象
5. 在创建对象时，系统自动的调用该类的构造方法
6. 如果没有定义构造器，系统会自动给类生成一个默认无参构造方法（也叫默认构造器 ）
7. 一旦定义了直接的构造器，默认的构造器就覆盖了，就不嗯给你再使用默认的无参构造器，除非显示的定义一下。

完成对象初始化的步骤：

1.默认初始化2.属性的显式初始化3.构造器的初始化4.把对象在堆中的地址返回给对象的引用

### this关键字

java虚拟机会给每个对象分配this，代表当前对象。

```java
class Dog{
    String name;
    int age;
    //构造方法
    public Dog(String name,int age){
        //this 就是当前对象，this.name就是当前对象的name
        this.name = name;
        this.age = age;
    }
}
```

简单的说那个对象调用，this就代表那个对象。

this的注意事项：

1. this关键字可以用来访问本类的属性，方法，构造器
2. this用于区分当前类的属性和局部变量
3. 访问成员方法的语法：this.方法名(参数列表);
4. 访问构造器的语法：this(参数列表); 注意只能在构造器中使用（即只能在构造器中访问另外一个构造器，并且this构造器必须放在构造器的第一条语句）
5. this不能再类定义的外部使用，只能在类定义的方法中使用。

## 面向对象编程

### 包

包有三大作用：

1.区分相同名字的类

2.当类很多时，可以很好的管理类

3.控制访问范围

包基本语法： package 包名;   package 关键字，表示打包

包的本质：实际上就是创建不同的文件夹/目录来保存类文件。

包的命名规则：

只能包含数字，字母，下划线，小圆点，但不能用数字开头，不能是关键字或保留字

命名规范：一般是小写字母+小圆点。一般是com.公司名.项目名.业务模块名

java中常用的包：

java.lang.*   //lang包是基本包，默认引入，不需要再引入

java.util.* 	//util包，系统提供的工具包，工具类

java.net.*	//网络包，网络开发

java.awt.*	//是做java的界面开发，GUI

**引入包**

语法： import 包;

我们引入一个包的主要目的是要使用该包下的类

比如 import java.util.Scanner; 就只是引入一个类Scanner

import java.util.*;  表示将java.util包下所有的类都引入（推荐使用单独引入）

包的注意事项：

1.package 的作用是声明当前类所在的包，需要放在类的class的最上面，一个类中最多只有一句package

2.import指令 位置放在package的下面，在类定义前面，可以有多句且没有顺序要求。

```java
package com.dpwl.web.model;
// package 声明当前类的位置
import java.util.Arrays;
// 引用其他包下的类
public class Model {
    static void main() {
        int[] ints = new int[4];
        ints = new int[]{1, 5, 8, -1};
        Arrays.sort(ints);
    }
}
```

### 访问修饰符

java提供四种访问控制修饰符号，用于控制方法和属性的访问权限。

1.公开级别：用public修饰，对外公开

2.受保护级别：用protected修饰，对子类和同一个包中的类公开

3.默认级别：没有修饰符号，向同一个包的类公开。

4.私有级别：用private修饰，只有类本身可以访问，不对外公开。

4中访问修饰符的访问范围

| 访问级别 | 修饰符    | 本类 | 同包 | 子类 | 不同包 |
| -------- | --------- | ---- | ---- | ---- | ------ |
| 公开     | public    | √    | √    | √    | √      |
| 受保护   | protected | √    | √    | √    | ×      |
| 默认     | 无        | √    | √    | ×    | ×      |
| 私有     | private   | √    | ×    | ×    | ×      |

修饰符注意事项

1. 修饰符可以用来修饰类中的属性,成员方法以及类
2. 只有默认的和public才能修饰类,并且遵循上述范围权限的特点
3. 关于在子类中的访问权限,学习继承再讲
4. 成员方法的访问规则和属性完全一样

面向对象编程的三大特点:

封装,继承和多态

### 封装

封装(ensapsulation)就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起,数据被保护在内部,程序的其他部分只有通过被授权的操作[方法],才能对数据进行操作.

封装的好处:1.隐藏实现细节 2.可以对数据进行验证,保证安全合理.

封装的实现步骤

1. 将属性进行私有化private [不能直接修改属性]
2. 提供一个公共的set方法,用于对属性判断并赋值
3. 提供一个公共的get方法,用于获取属性的值.

### 继承

继承可以解决代码服用,让我妈的边陲更加靠近人类思维,当多个类存在相同的属性和方法是,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法,所有的子类不需要重新定义这些属性和方法,只需要通过extends来声明继承父类即可.

继承的基本语法:

class 子类 extends 父类{}

1. 子类就会自动拥有父类定义的属性和方法
2. 父类又叫超类,基类
3. 子类又叫派生类

继承的好处:1.代码复用性提高了 2.代码的扩展性和维护性提高了

继承的注意事项:

1. 子类继承了所有的属性和方法,非私有的属性和方法可以在子类直接访问,但是私有属性和方法不能在子类直接访问,要通过父类提供公共的方法去访问
2. 子类必须调用父类的构造器,完成父类的初始化
3. 当创建子类对象时,不管使用子类的那个构造器,默认情况下总会去调用父类的无参构造器,如果父类没有提供无参构造器,则必须在子类的构造器中用super去指定使用父类的那个构造器完成对分类的初始化工作,否则,编译不会通过.

4. 如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表);
5. super在使用时，需要放在构造器第一行(super只能在构造器中使用)
6. super()和this()`this()用于指定本类的构造方法`都只能放在构造器第一行，隐藏这两个方法不能共存在一个构造器
7. java所有类都是Object类的子类，Object是所有类的子类
8. 父类构造器的调用不限于直接父类！将一直往上追溯直到Object类。
9. 子类最多只能继承一个父类（指直接继承），即java中是单继承机制，如何让A类继承B类和C类？（A继承B，B继承C）
10. 不能滥用继承，子类和父类直接必须满足is-a（是个XX的）的逻辑关系

继承在内存中的布局：

![2025-09-25_223238](.\img\2025-09-25_223238.png)

继承关系中如何访问属性？

要按照查找关系：1.首先看子类是否有该属性2.如果子类有这个属性，并且可以访问，则返回信息3.如果子类没有这个属性，就看父类有每一这个属性（如果父类有该属性并且可以访问，就返回信息，没有继续往上找直到Object）

#### super关键字

super代表父类的引用，用于访问父类的属性，方法，构造器。

基本语法：

1.访问父类的属性，但不能访问父类的private属性：`super.属性名`;

2.访问父类的方法，但不能访问父类的private方法：`super.方法名(参数列表)`;

3.访问父类的构造器：`super(参数列表);`只能放在构造器的第一句，只能出现一次。

super的细节：

1.调用父类的构造器的好处（分工明确，父类属性由父类初始化，子类的属性由子类初始化）

2.当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果。

3.super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类中都有同名的成员，使用super访问遵循**就近原则**。A->B->C(当然也要遵循权限的相关规则，如果访问的直接父类有对应的属性或方法，但是权限是私有的，那么程序会直接报错，不会再往上级去找。)

super和this的比较

| 区别点     | this                                                   | super                                    |
| ---------- | ------------------------------------------------------ | ---------------------------------------- |
| 访问属性   | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 | 从父类开始查找属性                       |
| 调用方法   | 访问本类中的方法，如果本类没有此方法则从父类继续查找   | 从父类开始查找方法                       |
| 调用构造器 | 调用本类构造器，必须放在构造器的首行                   | 调用父类构造器，不行放在子类构造器的首行 |
| 特殊       | 表示当前对象                                           | 子类中访问父类对象                       |

#### 方法重写/覆盖（override）

方法覆盖（重写）就是子类有一个方法，和父类的某个方法的**名称，返回类型，参数**一样，那么我们就说子类的这个方法覆盖了父类的方法。（不一定是直接父类的方法） 

注意事项：

方法重写，需要满足一下的条件

1. 子类的方法的参数，方法名称要和父类方法的参数，名称完全一样。
2. 字符方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类，比如父类返回类型是Object，子类方法返回类型是String
3. 自乐方法不能缩小父类方法的访问权限

重写和重载的比较

| 名称     | 重载（overload）             | 重写（override）                                     |
| -------- | ---------------------------- | ---------------------------------------------------- |
| 发生范围 | 本类                         | 父子类                                               |
| 方法名   | 必须一样                     | 必须一样                                             |
| 参数列表 | 类型，个数或顺序至少一个不同 | 必须一样                                             |
| 返回类型 | 无要求                       | 子类重写的方法返回类型和父类返回的类型一致或是其子类 |
| 修饰符   | 无要求                       | 不能缩小父类的权限范围                               |

### 多态

方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承继承之上的。

1.方法的多态。重写和重载就体现多态

2.对象的多态

- 一个对象的编译类型和运行类型可以不一致
- 编译类型在定义对象时，就确定了，不能改变
- 运行类型的可以变化的
- 编译类型看定义时=号的左边，运行类型看=号的右边

```java
Animal animal = new Dog();
//Dog()是Animal()的子类（animal可以接受子类的对象），此时变量的编译类型是Animal运行类型是Dog，体现了一个对象的编译类型和运行类型可以不一致。
animal = new Cat();
//animal从Dog类通过重新赋值变成Cat类，体现了运行类型是可以变化的。
```

多态的注意事项：

多态的前提是：两个对象(类)存在继承关系

多态的向上转型

1. 向上转型本质：父类的引用指向了子类的对象（子类向上转型成父类）

2. 语法： 父类类型   引用名 = new 子类类型();

3. 向上转型特点：编译类型看左边（声明），运行类型看右边（创建的具体对象）。可以调用父类中的所有成员（需遵守访问权限），不能调用子类中特有成员（因为声明是父类类型，父类中没有子类特有的成员，所以编译通不过）；最终运行效果看子类的具体事项（运行时看实际的创建类型，找创建类型的方法，找不到就往父类上找）。

多态的向下转型

1. 语法：子类类型 引用名 = （子类类型）父类引用;
2. 只能强转父类的引用，不能强转父类的对象
3. 要求父类的引用必须指向的是当前目标类型的对象
4. 当向下转型后可以调用子类类型中所有的成员。

```java
Animal animal = new Cat();
// Cat类中有个独特的方法catchMouse()；因为向上转型了所有此时直接使用animal.catchMouse()；方法编译通不过
//可以先使用向下转型，就可以使用独特方法了，向下转型的前提条件是这个创建的对象和向下转型的声明是同一个类。
Cat cat = （Cat）animal; //上面animal实际创建的就是Cat类，所以可以向下转型成Cat。
cat.catchMouse();
```

属性没有重写之说，属性的值看编译类型。

```java
class Base{ int count = 10;}
class Sub extends Base{ int count = 20；}
Base base = new Sub(); //此时Sub()向上转型
System.out.print(base.count); //输出10，因为属性只看声明类型，直接去声明的类中找。base声明是Base类，Base类的count属性是10
```

instanceOf 比较操作符，用于判断**对象的运行类型**是否为XX类型或XX类型的子类型。

#### 动态绑定机制

当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定

当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

```java
//案例分析
class A{
    public int i = 10;
    public int sum(){
        return getI()+10;
    }
    public int sum1(){
        return i+10;
    }
    public int getI(){
        return i;
    }
}
class B extends A{
    public int i = 20;
    public int sum(){
        return i+20;
    }    
    public int getI(){
        return i;
    }
    public int sum1(){
        return i+10;
    }
}
A a = new B(); //向上转型
System.out.println(a.sum()); //运行B类中的方法40
//如果注释掉B类中的sum()方法此时该输出什么？
//分析：B类中没有sum()方法，此时会向父类查找，找到sum()方法运行
//A类的sum()方法中又调用getI()方法，那此时是调用A类的getI()还是B类的getI()呢?
//根据动态绑定原则，该对象的方法会和运行类型绑定，所以应该调用的是B类的getI()方法，所以结果是30，如果B类中没有getI(),则又遵循继承机制找父类中的getI();
System.out.println(a.sum1()); //30
//如果注释掉B类中的sum1(),同理找到父类A的sum1(), sum1(){i+10;} i是属性不动态绑定，所以此时的i就是A类的属性i = 10;结果就是20
```

#### 多态的应用

1.多态数组

数组的定义类型为父类类型，里面保存的实际元素类型为子类类型

```java
//父类class Person
//两个子类class Student和class Teacher,创建一个父类数组，元素包含1个父类，各两个子类
Person[] person = new Person[5];
person[0] = new Person("jack",20);
person[1] = new Studnet("marry",20,90);
person[2] = new Student("smith",18,30.1);
person[3] = new Teacher("scott",30,18000);
person[4] = new Teacher("kong",50,25000);
//调用各自独特的方法
for(i=0;i<person.length;i++){
    if(person[i] instanceof Studnet){ //判断运行类型是否是Studnet
        ((Student)person[i]).study(); //向下转型并执行study()方法
    }else if(person[i] instanceof Teacher){
        ((Teacher)person[i]).teach();
    }
}
```

2.多态参数

方法定义的形参类型为父类类型，实参类型运行为子类类型

```java
//主人类
class Master{
    public void feed(Animal animal,Food food){
        System.out.println("主人正在喂"+animal.getName()+food.getName());
    }
}
//Cat继承Animal，bone继承Food
feed(Cat cat, Bone bone);
```

### Object类详解

#### equals()方法

判断两个对象是否相等，equals 和 ==（比较运算符）的区别

1. ==：既可以判断基本类型，又可以判断引用类型
2. ==：如果判断基本类型，判断的是值是否相等。
3. ==：如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象。
4. equals：是Object类中的方法，只能判断引用类型。
5. 默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。

```java
integer a = new integer(100);
integer b = new integer(100);
System.out.println(a == b);  // false a和b不是同一个对象
System.out.println(a.equals(b)); //True a和b两个对象的值相等
```

#### hashCode()方法

返回对象的哈希码值，支持此方法是为了提高哈希表的性能。

1. 提供具有哈希结构的容器的效率
2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的。
3. 两个引用，如果指向的是不同的对象，则哈希值是不一样的
4. 哈希值主要根据地址号来的！，不能完全将哈希值等价于地址。
5. 后面在集合中，hashCode如果需要的话，也会重写

#### toString()方法

默认返回：类的  全类名（包名+类名）+@+哈希值的十六进制

子类往往重写toString方法，用于返回对象的属性信息

重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式

```java
@Override //重写toString方法，idea 快捷键ctrl+insert， 选toString
public String toString() {
    return "Monster{" +
        "name='" + name + '\'' +
        ", job='" + job + '\'' +
        ", salary=" + salary +
        '}';
}
```

当直接输出一个对象时，toString方法会被默认的调用

#### finalize()方法

当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。

1. 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作
2. 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法。
3. 垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制

### 断点调试（debug）

断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个bug

断点调试的快捷键

F7(跳入)：跳入方法内

F8(跳过)：逐行执行代码

shift+F8(跳出)：跳出方法

F9(resume)：执行到下一个断点



### 类变量/静态变量

类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，统一任何一个该类的对象去修改它时，修改的也是同一个变量。

定义语法

访问修饰符 static 数据类型 变量名; [推荐]

static 访问修饰符 数据类型 变量名;

访问类变量

类名.类变量名  或者  对象名.类变量名;

注意事项：

1. 什么时候需要用类变量

   当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）

2. 类变量与实例变量（普通属性）区别
   类变量是该类的所有对象共享的，而实例变量是每个对象独享的。

3. 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量

4. 类变量可以通过类名.l类变量名  或者对象名.类变量名来访问，java设计者推荐我们使用 类名.类变量名方式访问。【前提是满足修饰符的访问权限】

5. 实例变量不能通过 类名.类变量名 方式访问

6. 类变量是在类加载是就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了

7. 类变量的生命周期是随类的加载开始，随着类消亡而消毁。

### 类方法/静态方法

访问修饰符 static 数据返回类型 方法名(){ }   [推荐]

static 访问修饰符 数据返回类型 方法名(){ } 

类方法的调用：类名.类方法名  或者  对象名.类方法名

类方法的使用场景：

当方法中不设计到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。（如果我们希望不创建实例，也可以使用某个方法，即当做工具来使用，这时，把方法做成静态方法非常合适）

类方法注意事项：

1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无this的参数，普通方法中隐含着this的参数
2. 类方法可以通过类名调用，也可以通过对象名调用
3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用。
4. 类方法中不允许使用和对象有关的关键字，比如this和super，普通方法（成员方法）可以
5. 类方法（静态方法）中只能访问静态变量或静态方法
6. 普通成员方法，既可以访问普通变量(方法)，也可以访问静态变量（方法）。

小结：静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员，但必须遵守修饰符访问权限范围。

### 理解main方法

```java
//语法
public static void main(String[] args){}
```

1.main方法是java虚拟机调用的。

2.java虚拟机需要调用类的main()方法，所以改方法的访问权限必须是public

3.java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static

4.该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所允许的类的参数

5.当java虚拟机执行程序时，用户可以在命令行传入(参数1 参数2 参数3) 参数。

注意细节：

1.再main()方法中，我们可以直接调用main方法所在类的静态方法或静态属性。

2.但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。

### 代码块

代码化块又称为初始化块，属于类中的成员（即 是类的一部分，），类似于方法，将逻辑语句封装在方法体中，通过{ }包围起来。

但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用。

基本语法：

`[修饰符]{ 代码 };`

注意：

1. 修饰符可选，要写的话，也只能写static
2. 代码块分为两种，使用static修饰的叫静态代码块，没有修饰符的，叫普通代码块
3. 逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）
4. 最后的`;`可以写上，也可以省略

代码块的好处：

1. 相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作
2. 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性

```java
//代码块案例
class Movie{
    private String name;
    private double price;
    private String director;
    //下面的2个构造器都有相同的语句
    //这样代码看起来比较冗余，可以放入到一个代码块中
    //这样当我们不管调用哪个构造函数，都会调用代码块的内容
    //代码块的执行顺序优先于构造器
    {
        System.out.println("荧幕打开...");
        System.out.println("广告开始...");
        System.out.println("电影准备播放...");
    };
    public Movie(String name){
        this.name = name;
        //System.out.println("荧幕打开...");
        //System.out.println("广告开始...");
        //System.out.println("电影准备播放...");
    }
    public Movie(String name,double price){
        this.name = name;
        this.price = price;
        //System.out.println("荧幕打开...");
        //System.out.println("广告开始...");
        //System.out.println("电影准备播放...");
    }
}
```

代码块注意事项：

1. static代码块也叫静态代码块，作用就是对类进行初始化，而且它**随着类的加载而执行**，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行一次。
2. static代码块（类）什么时候会被加载
   - 创建对象实例时（new）
   - 创建子类对象实例，父类也会被加载（父类先被加载，子类后被加载）
   - 使用类的静态成员时（静态属性，静态方法）
3. 普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次（和类加载没有关系，可以理解成普通代码块是构造器的补充，构造器被调用，代码块就被调用）。如果只是使用类的静态成员，普通代码块并不会执行。
4. 创建一个对象时，在一个类调用顺序是：
   - 调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定向的顺序调用）
   - 调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）
   - 调用构造方法
5. 构造器的最前面其实隐含了super()和调用普通代码块，静态相关的代码块，属性初始化，在类加载时就执行完毕了，因此是优先于构造器和普通代码块执行的。
6. 我们看一下创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：
   - 父类的静态代码块和静态属性（优先级一样，按定义顺序执行）
   - 子类的静态代码块和静态属性（优先级一样，按定义顺序执行）
   - 父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
   - 父类的构造方法
   - 子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
   - 子类的构造方法
7. 静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员。

### 单例设计模式

所谓类的单例(单个实例)设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。

单例模式有两种方式：1.饿汉式 2.懒汉式

饿汉式步骤如下

1. 构造器私有化  ==》防止直接new
2. 累牍内部创建对象
3. 向外暴露一个静态的公共方法

```java
//有一个类，目标需求是GirlFriend类 只能创建一个女朋友
class SingleTon{
    pulic static void main(String[] args){
        //通过方法获取对象,即可完成目标
        GirlFriend instance = GirlFriend.getInstance();
    }
}
//饿汉式单例案例（类的实例还没有确定要使用就已经创建好了，饿汉式可能造成实例创建了没有使用，造成资源的浪费）
class GirlFriend{
    private String name;
    //如果保证我们只能创建一个GirlFriend对象？
    //1.将构造器私有化,外部别人就不能实例化类
    private GirlFriend(String name){
        this.name = name;
    }
    //2.在类的内部直接创建一个静态对象，实现唯一性
    private static GirlFriend gf = new GirlFriend("小红");
    //3.提供一个公共的static方法，返回内部创建的对象
    public static GirlFriend getInstance(){
        return gf;
    }
} 
//懒汉式单例模式（只有当用户使用时，才返回对象，后面再次调用时，返回的还是上次创建的对象）
class GirlFriend{
    private String name;
    
    //步骤：
    //1.将构造器私有化,外部别人就不能实例化类
    private GirlFriend(String name){
        this.name = name;
    }
    //2.定义一个空的静态变量
    private static GirlFriend gf = null;
    //3.定义一个static静态方法，判断对象是否创建，并返回对象
    public static GirlFriend getInstance(String name){
        if(gf == null){
            gf = new GirlFriend(name);
        }
        return gf;
    }
}
```

饿汉式 Vs 懒汉式

1. 二者最主要的区别在于创建对象的时机不同：饿汉式实在类加载就创建了对象实例，而懒汉式是在使用时才创建。
2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题。（后面学习线程后，会完善）
3. 饿汉式存在浪费资源的可能，因为如果程序运行时一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。

### final关键字

final 最后的，最终的

final 可以修饰类、属性、方法和局部变量。

在某些情况下， 程序员可能有以下需求，就会使用到final：

1. 当不希望类被继承时，可以用final修饰
2. 当不希望父类的某个方法被子类覆盖/重写（override）时，可以用final关键字修饰。
3. 当不希望类的某个属性的值被修改，可以用final修饰。
4. 当不希望某个局部变量被修改，可以使用final修饰。

final注意事项：

1. final修饰的属性又叫常量，一般用xx_xx_xx来命名
2. final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一：
   - 定义时：如 public final double TAX_RATE = 0.08;
   - 在构造器中
   - 在代码块中
3. 如果final修饰的属性是静态的，则初始化的位置只能是1.定义时，2.在静态代码块 不能再构造器中赋值。
4. final类不能继承，但是可以实例化对象
5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以继承。一般来说，如果一个类以及是final类了，就没有必要再将方法修饰成final方法。
6. final不能修饰构造方法（构造器）
7. final和static往往搭配使用，效率更高，底层编译器做了优化处理
8. 包装类（Integer，Double，Float,Boolean等都final），String也是final类。

### 抽象类

抽象方法就是没有实现的方法（也就是没有方法体的方法），当一个类中存在抽象方法时，需要将该类用abstract来修饰，这个类就是抽象类。

一般来说抽象类会被继承，抽象方法会被子类实现。

```java
//抽象类语法
abstract class AAA{ //抽象类
    public abstract void hi(); //抽象方法
}
```



抽象类常被框架和设计使用到

抽象类的注意事项：

1. 抽象类不能被实例化
2. 抽象类不一定要包含abstract方法，也就是说抽象类可以没有abstract方法，也可以包含已经实现的方法。
3. 一旦类包含了abstract方法，则这个类必须声明为abstract
4. abstract只能修饰类和方法，不能修饰属性和其他
5. 抽象类可以有任意成员【抽象类本质还是类】，比如：非抽象方法、构造器、静态属性等等
6. 抽象方法不能有主体，即不能实现
7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。
8. 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的。、

### 模板设计模式

```java
//创建模板类
abstract class Template{
    public abstract void job(); //抽象方法
    public void caleTimes(){
        //统计耗时
        long start = System.currentTimeMillis();//获取当前毫秒
        job();
        long end = System.currentTimeMillis();
        System.out.println("耗时："+(end - start));
    }
}
class A extends Template{ //继承模板类
    public void job(){ //具体方法实现
        int num - 0;
        for(i=1;i<=100000;i++){
            num += i;
        }
    }
}

class B extends Template{ //继承模板类
    public void job(){ //具体方法实现
        int num - 0;
        for(i=1;i<=100000;i++){
            num *= i;
        }
    } 
}
//使用模板设计可以抽象出具体的业务逻辑，吧大部分工具的代码写到模板类，增加代码的复用性
```

### 接口

接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。

语法：

interface 接口名{

​	//属性

​	//方法

}

class 类名 implements 接口{

​	自己属性；

​	自己方法；

​	必须实现接口的所有抽象方法

}

在jdk7前，接口里的所有方法都每一方法体

jdk8后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现

接口注意事项：

1.接口不能被实例化

2.接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰。

3.一个普通类实现接口，就必须将该接口的所有方法都实现（idea内alt+enter可以快速实现接口方法实现）

4.抽象类实现接口，可以不用实现接口的方法。

5.一个类可以同时实现多个接口

6.接口中的属性，只能是finmal的，而且是public static final修饰符。

7.接口中属性的访问形式：接口名.属性名

8.接口不能继承其他的类，但是可以继承多个别的接口

9.就看的修饰符只能是public和默认，这点和类的修饰符是一样的。

#### **实现接口 VS 继承类**

可以理解为实现是对单继承机制的补充。

当子类继承了父类，就自动的拥有了父类的功能，如果子类需要扩展功能，可以通过实现接口的方式扩展。

1. 接口和继承解决的问题不同
   检测的价值主要在于：解决代码的复用性和可维护性
   接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法。
2. 接口比继承更加灵活
   接口比继承更加灵活，继承是满足 is - a的关系，而接口只需要满足 like - a的关系。
3. 接口在一定程度上实现代码解耦【接口规范性+动态绑定】 

#### 接口的多态特性

1. 多态参数
   在前面的usb接口案例，UsbInterface usb，既可以接收手机对象，又可以接收相机对象，就体现了接口多态（接口引用可以指向实现了接口的类的对象，即接口变量可以指向不同的接口实现类实例）

2. 多态数组
   给usb数组中，存放phone和相机对象，phone类还有一个特有的方法call()，请遍历usb数组，如果是phone对象，除了调用usb接口定义的方法外，还需要调用phone特有方法call。

3. 接口存在多态传递现象。

   ```java
   public class InterfacePolyPass{
       public static void main(String[] args){
           //接口类型的变量可以指向，实现了该接口的类的对象实例
           IG ig = new teacher();
           //如果IG继承了IH接口，而Teacher类实现了IG接口，那么实际上就相当于Teacher类也实现了IH接口，这就是接口多态传递现象。
           IH ih = new teacher();
       }
   }
   
   interface IH{}
   interface IG extends IH{}
   class Teacher implements Ig{
       
   }
   ```

### 内部类

一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员。内部类最大的特点就是可以直接访问私有属性，并且可以提现类与类之间的包含关系。

基本语法：

class Outer{ //外部类

​	class Inner{ // 内部类

​	}

}

class Other{ //外部其他类

}

类的小结：

类的五大成员：1.属性 2.方法 3.构造器 4.代码块 5.内部类

#### 内部类的分类

定义在外部类局部位置上（比如方法内）：

1. 局部内部类（有类名）

   - 局部内部类是定义在外部类的局部位置，通常在方法内，
   - 局部内部类（本质仍然是一个类）可以直接访问外部类的所有成员，包括私有的。
   - 不能添加访问修饰符，但是可以使用final修饰（不能再被其他类继承）
   - 作用域：仅仅在定义它的方法或代码块中。
   - 局部内部类可以直接访问外部类的成员。
   - 外部类不能访问局部内部类，那如何使用局部内部类：在方法中，可以创建包含内部类的方法对象，然后用对象调用该方法即可。
   - 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问

2. 匿名内部类（没有类名，**重点！！！**）
   匿名内部类的特点：1.本质是类 2.是内部类 3.该类没有定义名字（系统分配）4. 同时还是一个对象

   ```java
   //基本语法
   new 类或接口(参数列表){
       类体
   }
   ```

   匿名内部类的语法比较奇特，请注意，因为匿名内部类即是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，因此可以调用匿名内部类的方法如下。

   ```java
   new A(){
       @Override
       public void cry(){
           System.out.println("Hello");
       }
   }.cry(); //定义类，并直接调用方法
   
   A a = new A(){
       @Override
       public void cry(){
           System.out.println("Hello");
       }
   } //定义类，并创建对象赋值
   a.cry(); //使用对象调用方法
   ```

   匿名内部类的最佳实践

   ```java
   //当做实参时间传递，简介高效
   interface AA{
       public void cry();
   }
   //main 方法中：
   public static void show(AA a){
       a.cry();
   }
   show(new AA{
       @Override
       public void cry(){
           System.out.print('这是一个匿名内部类');
       }
   });
   ```

   

定义在外部类的成员位置上：

1. 成员内部类（没用static修饰）

   ```java
   class Outer{
       //外部类
       private int n1 = 10;
       public String name = "张三";
       class Inner{
           //成员内部类
           public void say(){
               //可以直接访问外部类的所有成员，包含私有的
               System.out.println("n1="+n1+"name="+name);
           }
       }
       //方法可以直接使用成员内部类
       public void t1(){
           Inner inner = new Inner();
           inner.say();          
       }
   }
   ```

   - 成员内部类定义在外部类的成员位置上（即不在方法或代码块内），可以直接访问外部类的所有成员，包含私有的

   - 可以添加任意访问修饰符（public，protected，默认，private），因为它的地位就是一个成员。

   - 作用域和外部类的其他成员一样，为整个类体。在外部类的成员方法中创建成员内部类对象，再调用方法。

   - 成员内部类访问外部类成员：直接访问

   - 外部类访问成员内部类：创建对象，再访问

   - 外部其他类访问成员内部类三种方法：

     ```java
     //方法一 外部类.new 内部类
     Outer.Inner inner = Outer.new Inner();
     //方法二 在外部类中写一个方法，返回实例化成员内部类
     public void getInner(){
         return new Inner();     
     }
     Outer.Inner inner = Outer.getInner();
     //方法三 和方法一类似
     Outer.Inner inner = new Outer.new Inner();
     ```

   - 如果成员内部类的成员和外部类的成员重名，会遵守就近原则，如果要访问外部类的成员，使用 外部类.this.成员

2. 静态内部类（使用static修饰）
   静态内部类是定义在外部类的成员位置，并且有static修饰。

   - 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员。

   - 可以添加任意访问修饰符（public，protected，默认，private），因为它的地位就是一个成员。

   - 作用域：同其他成员，整个类体。

   - 静态内部类访问外部类：直接访问所有静态成员

   - 外部类访问静态内部类：创建对象，再访问

   - 外部其他类访问静态内部类

     ```java
     //方式一
     Outer.Inner inner = new Outer.Inner();
     //方式二， 写一个方法，返回内部类的实例
     public void getInner(){
         return new Inner();      
     }
     Outer.Inner inner = Outer.getInner();
     ```

   - 如果成员内部类的成员和外部类的成员重名，会遵守就近原则，如果要访问外部类的成员，使用 外部类.this.成员

## 枚举和注解

枚举英文enumeration，简写enum

枚举是一组常量的集合

可以这样理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。

### 自定义枚举

自定义枚举的步骤：

1. 将构造器私有化，目的是防止直接new
2. 去掉setXXX方法
3. 在类的内部创建固定的对象。对枚举对象/属性使用 final +static 共同修饰，实现底层优化。枚举对象名通常使用全部大写，常量的命名规范。
4. 枚举对象根据需要，也可以有多个属性。

```java
//自定义枚举类
class Season{
    private String name;
    private String desc;
    Season(String name,String desc) {
        this.name = name;
        this.desc = desc;
    }
    
    public final static Season SPRING = new Season("春天","春暖花开");
    public final static Season SUMMER = new Season("夏天","夏日炎炎");
    public final static Season AUTUMN = new Season("秋天","秋高气爽");
    public final static Season WINTER = new Season("冬天","冬雪皑皑");
    

    public String getName() {
        return name;
    }

    public String getDesc() {
        return desc;
    }

    @Override
    public String toString() {
        return "Season{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                '}';
    }
}
```



### enum关键字实现枚举

1. 使用enum关键字替代class
2. 常量名(实参列表);
3. 如果有多个常量（对象），使用`,`间隔即可
4. 使用enum关键字定义枚举，要求将常量对象，写在最前面。

```java
//enum关键字枚举
enum Season{
    SPRING("春天","春暖花开"),
    SUMMER("夏天","夏日炎炎"),
    AUTUMN("秋天","秋高气爽"),
    WINTER("冬天","冬雪皑皑");
    private String name;
    private String desc;
    Season(String name,String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    public String getDesc() {
        return desc;
    }

    @Override
    public String toString() {
        return "Season{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                '}';
    }
}
```

注意事项：

1. 当我们使用enum关键字开发一个枚举类时，默认会继承Enum类，而且是一个final类。
2. 传统的`public static final Season SPRING = new Season("春天","春暖花开");`简化成`SPRING("春天","春暖花开");`这里必须知道，它调用的是那个构造器。
3. 如果使用无参构造器，创建枚举对象，则实参列表和小括号都可以省略
4. 当有多个枚举对象时，使用`,`间隔，最后一个用分号结尾。
5. 枚举对象必须放在枚举类的行首。

### Enum类各种方法的使用

1.  toString() 返回的是当前对象名，子类可以重写该方法，用于返回对象的属性信息
2. name() 输出枚举对象的名称
3. ordinal() 输出的是该枚举对象的次序/编号，从0开始。
4. values() 返回含有定义的所有枚举对象的数组
5. valueOf() 将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常
6. compareTo() 比较两个枚举常量，比较的就是位置号（枚举对象.compareTo(枚举对象2);结果就是枚举对象编号减枚举对象2的编号）

### enum实现接口

1.使用enum关键字后，就不能再继承其他类了，因为enum会隐式继承Enum，而java是单继承机制。

2.枚举类和普通类一样，可以实现接口，如下形式。

`enum 类名 implements 接口1,接口2{ }`

## 注解

1.注解（Annotation）也被称为元数据（Metadata）,用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。

2.和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。

3.在javaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在javaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替java EE旧版中所遗留的繁冗代码和XML配置等。

使用Annotation时要在其前面增加@符号，并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素

三个基本的Annotation：

1. @Override：限定某个方法，是重写父类方法，该注解只能用于方法

   - @Override表示指定重写父类的方法（从编译层面验证），如果父类没有fly方法，则会报错
   - 如果不写@Override注解，而父类仍有public void fly(){}，仍然构成重写
   - @Override 只能修饰方法，不能修饰其他类，包，属性等
   - 查看@Override注解源码为@Target(ElementType.METHOD),说明只能修饰方法
   - @Target是修饰注解的注解，成为元注解。

2. @Deprecated：用于表示某个程序元素（类，方法等）已过时

   - 修饰某个元素，表示该元素已经过时
   - 即不在推荐使用，但是仍然可以使用
   - 可以修饰方法，类，字段，包，参数等
   - 可以做版本升级过渡使用

3. @SuppressWarnings：抑制编译器警告

   - 当我们不希望看到这些警告的时候可以使用@SupperWarnings({"All"}):忽略所有警告。

   - all:   抑制所有的警告

     boxing:        抑制与装箱/拆箱操作相关的警告

     cast:         抑制与强制转换操作相关的警告

     dep-ann:       抑制与已弃用注释相关的警告

     deprecation:     抑制与弃用相关的警告

     fallthrough:     在开关语句中抑制与丢失中断相关的警告

     finally:        抑制与最终块相关的不返回的警告

     hiding:        为了抑制相对于本地隐藏变量的警告。

     incomplete-switch:  在switch语句(enum案例)中，为了抑制相对于丢失条目的警告

     nls:          抑制相对于非nls字符串常量的警告

     null:         抑制与空分析相关的警告

     rawtypes:       在类params上使用泛型时，要抑制相对于非特定类型的警告。

     restriction:      抑制与使用不鼓励或禁止引用有关的警告

     serial:         禁止对可序列化类缺少serialVersionUID字段的警告

     static-access:     抑制与不正确的静态访问相关的警告

     synthetic-access:   抑制与内部类的未优化访问相关的警告

     unchecked:      抑制与未检查操作相关的警告

     unqualified-field-access: 抑制与字段访问不限定相关的警告

     unused:        抑制与未使用代码相关的警告

   - @SuppressWarnings作用范围是和放置的位置相关。通常可以放到属性，方法，或者类的前面。

**元注解（了解）**

元注解的种类：

1. Retention  指定注解的作用范围，三种，RetentionPolicy.SOURCE(作用于源码，编译器使用后，直接丢弃这种策略的注解)
   RetentionPolicy.CLASS(编译器把注解记录在class文件中，当运行java程序时，jvm不会保留注解，默认值)，RetentionPolicy.RUNTIME(编辑器将把注解记录在class文件中，当运行java程序时，jvm会保留注解，程序可以通过反射获取该注解)
2. Target 指定注解可以再那些地方使用
3. Documented 指定该注销是否会再javadoc体现
4. Inherited 子类会继承父类注解

## 异常处理

异常介绍：

java语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）

执行过程中所发生的异常事件可分为两类

1. Error（错误），java虚拟机无法解决的严重问题
2. Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。Exception分为两大类：运行时异常和编译时异常（是必须要处理的异常）。

异常体系图

![QQ20251010-163307](.\img\QQ20251010-163307.png)

### 常见的运行时异常

1. NullPointerException 空指针异常
2. ArithmeticException 数学运算异常
3. ArrayIndexOutOfBoundsException 数组下标越界异常
4. ClassCastException 类型转换异常
5. NumberFormatException 数字格式不正确异常

### 编译异常

编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译。

常见的编译异常

- SQLException 操作数据库时，查询表可能发生异常
- IOException 操作文件时，发生的异常
- FileNotFoundException 当操作一个不存在的文件时，发生异常
- ClassNotFoundException 加载类，而该类不存在时，异常
- EOFException 操作文件，到文件末尾，发生异常
- IIIegalArguementException 参数异常

### 异常处理

异常处理就是当异常发生时，对异常处理的方法。

异常处理的方式：

1. try - catch - finally
   程序猿在代码中捕获发生的异常，自行处理

   ```java
   try{
       有可能发生异常的代码
   }catch(Exception e){
      // 捕获到异常
      // 1. 当异常发生时
      // 2. 系统将异常封装成Exception 对象 e,传递给catch
      // 3. 得到异常对象后，程序员自己处理
      // 4. 如果没有发生异常，catch代码块不执行
      // 5. 可以使用多个catch捕获不同的异常，子类异常写在前面，父类异常写在后台
   }finally{
       // 不管try代码块是否有异常发生，始终要执行finally，所以通常将释放资源的代码，放在finally
   }
   ```
   
2. throws

   将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是jvm，系统默认就是使用throws处理异常。
   

try - catch - finally 执行顺序小结：

1. 如果没有出现异常，则执行try块中所有的语句，不执行catch块中语句，如果有finally，最后还需要执行finally里面的语句
2. 如果出现异常，则try快中异常发生后，剩下的语句不再执行。将执行catch块中的语句，如果有finally，最后还需要执行finally里面的语句。

异常处理注意事项：

1. 对于编译异常，程序中必须处理，比如try-catch或者throws
2. 对于运行时异常，程序中如果没有处理，默认就是throws的方式处理
3. 子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类
4. 在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws
5. 当一个方法抛出编译异常时，调用此方法的方法也要处理这个编译异常，不然编译通不过，如果抛出的是运行时异常，则不用处理，编译也可以通过

### 自定义异常

当程序中出现了某些“错误”,但该错误信息并没有在throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。

```java
//自定义年龄异常类，我们把自定义异常继承RuntimeException，做成运行时异常，好处是可以使用默认的处理机制，更加方便。
class AgeException extends RuntimeException{
    public AgeException(String message){
        super(message);
    }
}

int age =180;
if(!(age>=18 && age<=120)){
    throw new AgeException("年龄需要在18-120之间");
    System.out.println("你的年龄范围正确");
}
```

|        | 意义                     | 位置       | 后面的东西 |
| ------ | ------------------------ | ---------- | ---------- |
| throws | 异常处理的一种方式       | 方法声明处 | 异常类型   |
| throw  | 手动生成异常对象的关键字 | 方法体中   | 异常对象   |

## 常用类

### 包装类

针对八种基本数据类型相应的引用类型--包装类

有了类的特点，就可以调用类中的方法。

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| boolean      | Boolean   |
| char         | Character |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |

### 包装类和基本数据类型的转换

jdk5 前的手动装箱和拆箱方式，装箱：基本类型--》包装类型，反之，拆箱

jdk5 后（含jdk5）的自动装箱和拆箱方式

自动装箱底层调用的是valueOf方法，比如Integer.valueOf()

```java
//手动装箱 int ---》Integer
int n1 = 100;
Integer i = new Integer(n1);
//或者
Integer i = Integer.valueOf(n1);
//手动拆箱 Integer-----》int
int i1 = i.intValue();

//jdk5级之后自动装箱和拆箱
int n2 = 200;
Integer i2 = n2; //int 自动装箱到Integer
int n3 = i2; //Integer 自动拆箱到int
```

其他包装类类似，就不一一举例。

```java
Object obj1= true? new Integer(1) : new Double(2.0);
System.out.print(obj1);
//输出结果是1.0
//解析：三元运算符看做一个整体，冒号前是Ineteger，冒号后是Double，类型不一致，则要依范围更大的类型为主，所以结果升级为Double类型，并不是Integer。
```

### 包装类型和String类型的相互转换

**包装类型转String：**

- 方式一：
  Integer i = 100; // int 自动装箱
  String str = i + ""; // Integer i 赋值给是tr 转 String
- 方式二：
  String str2 = i.toString();
- 方式三:
  str3 = String.valueOf(i);

**String 转包装类：**

​	String str = "234";

方式一：
	//String -->int --->Integer
	Integer j = Integer.parseInt(str);

方式二：
	Integer j = new Integer(str);

方式三：
	Integer j = Integer.valueOf(str);

​	

### **Integer创建机制**

Integer包装的int数如果在-128到127之间则直接从cache中读取，如果不在这个范围内，则创建新的对象。

new 出来的两个对象一定是不同的对象。

```java
Integer i1 = new Integer(127);
Integer i2 = new Integer(127);
System.out.println(i1==i2);  // False，new出来的肯定是不同的对象

Integer i11 = 127;
int i12 = 127;
System.out.println(i11==i12); //True 只要有基本数据类型就是比较值是否相等
```

### String类

String对象用于保存字符串，也就是一组字符串序列。
![QQ20251013-100511](.\img\QQ20251013-100511.png)

字符串常量对象是用双引号括起来的字符序列，如："你好"，“12.97”，"boy"等。

字符串的字符使用unicode字符编码，一个字符（不区分字母还是汉字）占两个字节

String类较常用的构造方法：

- String s1 = new String();
- String s2 = new String(String original);
- String s3 = new String(char[] a);
- String s4 = new String(char[] a,int startIndex,int count);

String 类实现了接口Serializable【String可以串行化：可以再网络传输】

String类实现了接口Comparable【String对象可以比较大小】

String是final类，不能被其他的类继承

String 有属性 private final char value[]；用于存储字符串内容，一定注意：value是一个final类型，不可以修改（此处的不可修改不是指字符串内容不可修改，而是指value的**内存地址不可修改**，value存放的常量池地址是可以修改的。）
栈：String --》堆：value --》常量池：具体字符

**创建String对象的两种方式：**

方式一：直接赋值 String s = “dpwl”;

方式二：调用构造器 String s2 = new String("dpwl");

两种方式的区别：

1. 方式一：先从常量池查看是否有"dpwl"数据空间，如果有，直接指向；如果灭有则重新创建，然后指向。s最终指向的是常量池的空间地址
2. 方式二：现在堆中创建空间，里面维护了value属性，指向常量池的“dpwl”空间，如果常量池没有“dpwl”,重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址。

小结：String c ="a" + "b"；常量相加，看的是常量池，String c1 = a + b;变量想加，是在堆中。

**String类的常见方法**

String类是保存字符串常量的，每次更新都需要新开辟空间，效率较低，因此java设计者还提供了`StringBuilder`和`StringBuffer`来增强String的功能，并提高效率。

String类的常见方法：

- equals  区分大小写，判断内容是否相等
- equalslgnoreCase 忽略大小写判断内容是否相等
- length 获取字符的个数，字符串的长度
- indexOf 获取字符在字符串中第1次出现的索引，索引从0开始，如果找不到 -1
- lastIndexOf 获取字符在字符串中最后1次出现的索引，从0开始，找不到-1
- substring 截取指定范围的子串`substring(6)从索引6后截取全部，substring(2,5)从索引2到索引4，不含5的3个字符`
- trim 去掉前后空格
- charAt 获取某索引处的字符，**注意不能使用Str[index]这种方式**
- toUpperCase 字符串转大写
- toLowerCase 字符串转小写
- concat  拼接字符串
- compateTo 比较字符串大小，如前者大返回正数，后者大返回负数
- toCharArray 转换成字符串数组
- format 格式字符串，%s 字符串 %c 字符 %d 整型 %.2f 保留2位(四舍五入)的浮点型
- replace 替换字符串中的字符`s2 = s1.replace("a","b")；执行后s1不变，把返回的新字符串赋值给s2`
- split 分割字符串返回一个数组，需要转义字符串中的| \\等

**StringBuffer类**

代表可变的字符序列，可以对字符串内容进行增删。很多方法与String相同，但StringBuffer是可变长度的。（StringBuffer存放的不是字符常量，所以可知，它是存放在堆中的）

StringBuffer是一个容器。

StringBuffer是一个final类，不能被继承。

因为StringBuffer字符内容是存在char[] value,所以在变化（增加/删除）不用每次都更换地址（只有增加到空间不够时，才使用更大的空间，此时才更换地址）

**String Vs StringBuffer**

1. String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低。// private final char value[]；
2. StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高。

```java
// StringBuffer构造器的使用
//创建一个大小为16的char[]，用于存放字符内容。
StringBuffer str = new StringBuffer(); 
//通过构造器指定char[] 大小
StringBuffer str = new StringBuffer(100);
// 通过给一个String，创建StringBuffer，char[]大小就是str.length()+16
StringBuffer str = new StringBuffer("hello"); 
```

**string 和StringBuffer的转换**

1. String转StringBuffer

   ```java
   String str = "hello tom";
   StringBuffer string = new StringBuffer(str);
   //注意：返回的才是StringBuffer对象，原来的str不变。
   //方式二 使用append方法
   StringBuffer string2 = new StringBuffer();
   string2 = string2.append(str);
   ```

2. StringBuffer 转String

   ```java
   StringBuffer string = new StringBuffer("hello tom");
   //方式一，toString方法
   String s = string.toString();
   //方式二 使用构造器
   String string2 = new String(string);
   ```

**StringBuffer的常见方法**

- append  在后面追加
- delete(start,end) 删除>=start&&<end 处的字符
- replace(start,end,str)  把>=start&&<end 处的字符替换成str
- indexOf  查找字符在字符串中的位置索引，找不到返回-1
- insert(n,str)  在索引n处插入str，n处原来的字符后移
- length  返回字符串的长度

**StringBuilder类**

一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步（StringBuilder不是线程安全）。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议有限采用该类，因为在大多数实现中，它比StringBuffer要快。

在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。 

**String 、StringBuffer和StringBuilder的比较**

1. StringBuffer和StringBuilder非常类似，均代表可变的字符序列，而且方法也一样

2. String：不可变字符序列，效率低，但是复用率高。

3. StringBuffer：可变字符序列，效率较高（增删），线程安全

4. StringBuilder：可变字符序列，效率最高，线程不安全

5. String使用注意说明

   ```java
   String s = "a"; //创建了一个字符串
   s+="b"; //实际上原来的“a”字符串对象已经丢弃了，现在又产生了一个字符串s+“b”（也就是“ab”）。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率，如果这样的操作放到循环中，会极大影响程序的性能==》结论：如果我们对String做大量修改，不要使用String
   ```

使用的原则，结论：

如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder

如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder

如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer

如果字符串很少修改，被多个对象引用，使用String，比如配置信息等

### Math类

Math类包含用于执行基本数学运算的方法，如初等指数，对数，平方根和三角函数

常用方法（都是静态方法）：

1. abs 求绝对值

2. pow 求幂 `Math.pow(2,4) //2的4次方`

3. ceil 向上取整，返回>=该参数的最小整数（转成double）

4. floor 向下取整，返回<=该参数的最大整数（转成double）

5. round 四舍五入

6. sqrt 求开方

7. random 返回[0,1)之间的随机小数

   ```java
   //如果随机生成一个大于等于a，小于等于b的数
   // 因为0<=Math.random()<1，设x = Match.random();
   // 所以 x*a + a >=a, b.x+1-a+a<=b 把前面的a带入=》 b.x-x.a+1+a<=b 可以推导出这个随机数就是 (int)x*(b-a+1)+a<=b
   ```

### Arrays类

Arrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）。

1. toString返回数组的字符串形式  Arrays.toString(arr)

2. sort 排序 （自然排序和定制排序）

   ```java
   //sort 自定义排序
   Arrays.sort(arr,new Comparator(){
       //实现了Comparetor接口的匿名内部类，要求实现compare方法
       @Override
       public int compare(Object o1,Object o2){        
           Integer i1 = (Integer) o1;
           Integer i2 = (Integer) o2;
   		return i2-i1; //从大到小， i1-i2 从小到大
       }
   });
   ```

   

3. binarySearch 通过二分搜索法进行查找，要求必须排好序，找不到返-(low+1)
   
4. copyOf 数组元素的复制，`Arrays.copyOf(arr,len)`如果拷贝的len比arr.length()小，则新数组从后面删除，如果比它大，则新数组后面加null，len小于0则报异常。

5. fill 数组元素的填充`Arrays.fill(arr,9)`使用9替换掉arr数组内所有的元素

6. equals 比较两个数组元素内容是否完全一致

7. asList 将一组值，转换成list

### System类

系统类

1. exit 退出当前程序`System.exit(0)`0表示退出的状态是正常退出
2. arraycopy 复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组。`System.arraycopy(arr,0,newarr,0,3)`arr是要复制的源数组，0复制的起始位置索引，newarr 复制到的目标数组，0,3复制到数组的开始索引和元素个数
3. currentTimeMillens 返回当前时间距离1970-1-1的毫秒数
4. gc 运行垃圾回收机制 System.gc();

### BigInteger和BigDecimal 类

BigInteger 保存数据比较大的整数

BigDecimal 保存数据比较大的浮点数

常见方法：

1. add 加

2. subtract 减

3. multiply 乘

4. divide 除 可能会抛出异常，如果除不尽无限循环就异常，可以控制精度来处理

   `num1.divide(num2,BigDecimal.ROUND_CEILING)`ROUND_CEILING保留和分子一样的精度

### 日期类

日期类分为：Date，Calendar，LocalDate 三类

**Date类**在java.util包

获取的是系统当前时间，输出的格式是国外的方式通常需要格式转换

`SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 hh:mm:ss E");` E=星期

`Date(long date)`传入long类型的毫秒返回日期

String转Date：`sdf.parse(str) `注意，字符串的格式必须和上面定义的格式保持一致，否则就报异常。

**Calendar类**：第二代日期类日历

calendar类是一个抽象类，它为特定瞬间与一组诸如YEAR，MONTH，DAY_OF_MONTH，HOUR等日历字段之间的转换提供了一些方法，并为操作日历自段（例如获得下星期的日期）提供了一些方法。
calendar是抽象类，并且构造器是private，可以通过getInstance实例化

`Calendar c = Calendar.getInstance();`

获取年：`c.get(Calendar.YEAR);`

获取月：`c.get(Calendar.MONTH)+1;`月份从0开始的，所以要加1

获取日：`c.get(Calendar.DAY_OF_MONTH);`

获取时：`c.get(Calendar.HOUR);`12小时制`c.get(Calendar.HOUR_OF_DAY);`24小时制

Calendar没有提供格式化的方法，所以日期格式需要自己拼接

**第三代日期类**

前面两代日期类的不足：
JDK1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入Calendar类之后被弃用了，而Calendar也存在问题

1. 可变性：像日期和时间这样的类应该是不可变的
2. 偏移性：Date中的年份是从1900开始的，而月份都从0开始
3. 格式化：格式化只对Date有用，Calendar则不行
4. 此外，它们也不是线程安全的，不能处理润秒等（每隔2天，多出1s）。

Jdk8加入第三代日期类，常见方法LocalDate(日期，年月日)、LocalTime（时间，时分秒），LocalDateTime（日期时间）

```java
LocalDateTime ldt = LocalDateTime.now();
//DateTimeFormatter 格式日期类
DateTimeFormatter dtf = DateTimeFormatter.ofpattern("yyyy-MM-dd HH:mm:ss");
```

**Instant 时间戳**类似于Date提供了一系列和Date类转换的方式

Instant --》Date：Date date = Date.from(instant);

Date ---> Instant: Instant instant = date.toInstant();

第三代日期类更多方法

- LocalDateTime类
- MonthDay类：检查重复事件
- 是否有闰年
- 增加日期的某个部分
- 使用plus方法测试增加时间的某个部分
- 使用minus方法测试查看一年前和一年后的日期

## 集合

前面我们保存多个数据使用的是数组，那么数组有那些不足的地方：

1. 长度开始时必须指定，而且一旦指定，不能更改
2. 保存的必须是同一类型的元素
3. 使用数组进行增加/删除元素比较麻烦

集合的好处：

- 可以动态保存任意多个对象，使用比较方便
- 提供了一系列方便的操作对象的方法：add，remove，set，get等
- 使用集合，添加，删除新元素比较简洁

### 集合的框架体系

单列集合：存放的都是单个的对象

![QQ20251014-165627](.\img\QQ20251014-165627.png)

双列集合：存放的都是键值对

![QQ20251014-165905](.\img\QQ20251014-165905.png)

### Collection接口和常用方法

Collection接口实现类的特点：

1. collection实现子类可以存放多个元素，每个元素可以是object
2. 有些Collection的实现类，可以存放重复的元素，有些不可以
3. 有些Collection的实现类，有些是有序的（List），有些不是有序（Set）
4. Collection接口没有直接的实现子类，是通过它的子接口Set和List类实现的

Collection接口常用方法，以实现子类ArrayList来演示：

1. add ：添加单个元素
2. remove：删除指定元素
3. contains：查找元素是否存在
4. size：获取元素个数
5. isEmpty：判断是否为空
6. clear：清空
7. addAll：添加多个元素
8. containsAll：查找多个元素是否都存在
9. removeAll ：删除多个元素
10. 说明：以ArrayList实现类来演示

Collection接口遍历元素方式

1. 使用Iterator（迭代器）
   - Iterator对象称为迭代器，主要用于遍历Collection集合中的元素。
   - 所有实现了Collection接口的集合类都有一个iterator()方法，用于返回一个实现了Iterator接口的对象，即可以返回一个迭代器。
   - Iterator的结构图：通过while循环Iterator.hasNext()判断是否还有更多元素，有就可以使用iterator.next()下移一位并返回元素，直到没有元素。重新定义一下Iterator就可以重置指针位置位第一个。也可以使用增强for来遍历`for(Object o:iterator){}`
   - Iterator仅用于遍历集合，Iterator本身并不存放对象。

### List接口和常用方法

基本介绍：List接口是Collection接口的字接口

1. List集合类中元素有序（即添加顺序和取出顺序一致），且可重复
2. List集合中的每个元素都有其对应的顺序索引，即支持索引。
3. List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。
4. JDK api中List接口的实现类常用的有：ArrayList，LinkedList和Vector

List接口的常用方法：

1. add：添加元素，`list.add("tom")`在集合最后添加，`list.add(1,"tom")`在第2个元素后插入。
2. addAll：在指定位置批量加入`lst.addAll(1,list)`
3. get(int index) :获取指定索引的元素
4. indexOf(Object obj)：返回obj在当前集合中首次出现的位置
5. lastIndexOf(Object obj)：返回obj在当前集合中最后一次出现的位置
6. remove(int index)：移除指定索引位置的元素，并返回该元素
7. set(int index, Object ele)：设置指定index位置的元素为ele，相当于替换
8. subList(int fromIndex,int toIndex)：返回从fromIndex到toIndex位置（不包含toIndex）的子集合

ArrayList的注意事项：

1. ArrayList可以加入null，并且多个
2. ArrayList是由数组来实现数据存储的
3. ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高），在多线程情况下，不建议使用ArrayList

ArrayList的底层操作机制分析

1. ArrayList中维护了一个Object类型的数组elementData，`transient Object[] elementDate`：transient关键字表示瞬间，短暂的，表示该属性不会被序列化。
2. 当创建ArrayList对象时，如果使用的是无参构造器，则初始elementDate容量为0，第一次添加，则扩容elementDate为10，如需再次扩容，则扩容elementDate为1.5倍。
3. 如果使用的是指定大小的构造器，则初始elementDate容量为指定大小，如果需要扩容，则直接扩容elementDate为1.5倍。

### Vector类分析

Vector类的定义
`public class Vector extends AbstrctList implements List,RandomAccess,Cloneable,Serializable{}`

Vector底层也是一个对象数组，`protected Object[] elementData;`

Vector是线程同步的，即线程安全，Vector类的操作方法带有`synchronizedd`

在开发中，需要线程同步安全时，考虑使用Vector

**Vector和ArrayList的比较**

|           | 底层结构 | 版本   | 线程，效率     | 扩容                                                       |
| --------- | -------- | ------ | -------------- | ---------------------------------------------------------- |
| ArrayList | 可变数组 | jdk1.2 | 不安全，效率高 | 如果有参构造1.5倍<br />如果是无参，第一次10，以后1.5倍     |
| Vector    | 可变数组 | jdk1.0 | 安全，效率不高 | 如果是无参，默认10，满后2倍<br />如果指定大小，则每次2倍扩 |

### LinkedList类分析

LinkedList底层实现了双向链表和双端队列特定

可以添加任意元素（元素可以重复），包括null

线程不安全，没有实现同步和互斥

LinkedList的底层机制：

1. LinkedList底层维护了一个双向链表
2. LinkedList中维护了两个属性first和last分别指向首节点和尾节点
3. 每个节点（Node对象），里面又维护了prev，next，item三个属性，其中通过prev指向前一个，通过next指向后一个节点，最终实现双向链表
4. 所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高

ArrayList和LinkedList的比较

|            | 底层结构 | 增删效率           | 改查效率 |
| ---------- | -------- | ------------------ | -------- |
| ArrayList  | 可变数组 | 较低，数组扩容     | 较高     |
| LinkedList | 双向链表 | 较高，通过链表追加 | 较低     |

如何选择ArrayList和LinkedList：

1. 如果我们改查的操作多，选择ArrayList
2. 如果我们增删的操作多，选择LinkedList
3. 一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList
4. 在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，也就是说，要根据业务选择

### Set接口

Set接口：1.无序（添加和取出的顺序不一致，取出的顺序是固定的），没有索引 2.不允许重复元素，所以最多包含一个null，3.jdk api中set接口的实现类常用的有HashSet和TreeSet

**Hashset**实现了Set接口

HashSet实际上是HashMap

可以存放null只，但只能有一个

HashSet不保证元素是有序的，取决于hash后，再确定索引的结果（即不保证存放元素的顺序和取出的一致）

不能有重复元素/对象（new的内容一样的对象是不同的对象）

HashSet底层机制：

HashSet的底层是hashMap，hashMap底层是（数组+链表+红黑树）

1. HashSet底层是hashMap

2. 添加一个元素时，先得到hash值，会转成-》索引值
   2.1.第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（loadFactor）0.75 = 12（添加12个元素就会扩容了）

   2.2、如果table数组使用到了临界值12，就会扩容到16*2=32，新的临界值就是32\*0.75=24,依次类推

3. 找到存储数据表table，看这个索引位置是否已经存放的有元素

4. 如果没有，直接加入

5. 如果有，调用equals（可以根据对象的equals()重写[ides快捷键alt+insert选择equals and hashcode]来确定判断标准）比较，如果相同，就放弃添加，如果不同，则添加到最后

6. 在java8中，如果一条链表的元素个数达到TREEIFY_THRESHOLD(默认是8)，并且table的大小>=MIN_TREEIFY_THRESHOLD(默认64)，就会进行树化（红黑树），否则依然采用数组扩容机制

```java
//重写equals和hashcode案例
public static void main(String[] args) {
       Employee a = new Employee("张三",10000.0,new MyDate(1990,1,1));
        Employee b = new Employee("李四",10000.0,new MyDate(1990,1,1));
        Employee c = new Employee("张三",10000.0,new MyDate(1990,1,1));
        HashSet<Employee> hashSet = new HashSet<>();
        hashSet.add(a);
        hashSet.add(b);
        hashSet.add(c); //c 根据重新的规则，name和birthday相同则认为相同，故c不能写入，只能写入a和b
        System.out.println("hashSet = "+hashSet);
    }
class Employee{
    private String name;
    private double salary;
    private MyDate brithday;
    public Employee(String name, double salary, MyDate brithday) {
        this.name = name;
        this.salary = salary;
        this.brithday = brithday;
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return Objects.equals(name, employee.name) && Objects.equals(brithday.toString(), employee.brithday.toString());
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, brithday.toString());
    }
}
class MyDate{
    private int year;
    private int month;
    private int day;
    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }
    public String toString() {
        return year + "年" + month + "月" + day + "日";
    }
}
```

**LinkedHashSet**是HashSet的子类

LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表

LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的

LinkedHashSet不允许添加重复元素

![QQ20251023-171522](.\img\QQ20251023-171522.png)

**TreeSet实现类**

当我们使用无参构造器，创建Treeset时，仍然是无序的。

使用TreeSet提供的构造器，可以传入一个比较器（匿名内部类）可以排序

```java
TreeSet set = new TreeSet(new Comparator(){
    //匿名内部类可以自行定义排序方法
    //比较方法会传入底层的TreeMap的compare属性
    @Override
    public int compare(Object o1,Object o2){
        //比较字符串长度作为排序规则，如果长度一样，则后加入的元素就被丢弃
        return ((String) o2).length() - ((String) o1).length();
    }
});
```



### Map接口和常用方法

**Map接口的特点：**

1. Map与Collection并列存在。用于保存具有映射关系的数据：key-Value（双列元素）
2. Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中
3. Map中的key不允许重复，原因和HashSet一样
4. Map中的value可以重复
5. Map的key可以为null，value也可以为null，注意key为null，只能有一个，value为null，可以多个
6. 常用String类作为Map的key
7. key和value直接存在单向一对一关系，即通过指定的key总能找到对应的value
8. Map存放数据的key--value示意图，一对k-v是放在一个Node中的，有因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry

#### HashMap实现类

**Map接口常用方法：**

1. put：添加
2. remove：根据键删除映射关系
3. get：根据键获取值
4. size：获取元素个数
5. isEmpty：判断个数是否为0
6. clear：清除
7. containsKey：查找键是否存在

**Map接口的遍历方式：**

1. containsKey：查找键是否存在

2. keySet：获取所有的键

   ```java
   public static void main(String[] args) {
       Map map = new HashMap();
       map.put("no1","张三");
       map.put("no2","李四");
       map.put("no3","王五");
       map.put("no4","王二");
       map.put("no5","麻子");
       Set keySet = map.keySet();
       // 增强for遍历
       for (Object key : keySet) {
           System.out.println(key+":"+map.get(key));
       }
       // 迭代器
       Iterator iterator = keySet.iterator();
       while (iterator.hasNext()) {
           Object key = iterator.next();
           System.out.println(key+":"+map.get(key));
       }
   }
   ```

3. entrySet：获取所有关系

   ```java
   // 通过entrySet来获取k-v
   Set entrySet = map.entrySet();
   for (Object entry : entrySet) {
       // 将entry转成Map.Entry就可以使用Map.Entry的getkey和getvalue方法
       Map.Entry m = (Map.Entry) entry;
       System.out.println(m.getKey()+":"+m.getValue());
   }
   ```

4. values：获取所有的值

   ```java
   // 把所有的values取出
   Collection values = map.values();
   for (Object value : values) {
       System.out.println(value);
   }
   ```

   

**hashMap小结**

1. Map接口的常用实现类：HashMap，HashTable和Properties。
2. HashMap是Map接口使用频率最高的实现类
3. HashMap是以key-val对的方式来存储数据（HashMap$Node类型）
4. key不能重复，但是值可以重复，允许使用null键和null值
5. 如果添加相同的key，则会覆盖原来的key-val，等同于修改（key不会替换，val会替换）
6. 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的
7. HashMap没有实现同步，因此是线程不安全的
8. HashMap的扩容机制和HashSet相同

#### Hashtable实现类

Hashtable基本介绍

1. Hashtable存放的元素是键值对：即k-v
2. Hashtable的键和值都不能为null，否则会抛出NullpointerException
3. Hashtable使用方法基本上和HashMap一样
4. Hashtable是线程安全的（synchronized），HashMap是线程不安全的
5. Hashtable的初始大小是11，扩容机制是原容量*2+1


Hashtable和HashMap对比

|           | 版本 | 线程（同步） | 效率 | 允许null键null值 |
| --------- | ---- | ------------ | ---- | ---------------- |
| HashMap   | 1.2  | 不安全       | 高   | 可以             |
| Hashtable | 1.0  | 安全         | 低   | 不可以           |

#### Properties实现类

Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存数据。

他的使用特点和Hashtable类似

Properties还可以用于从XXX.Properties文件中，加载数据到Properties类对象，并进行读取和修改

工作中XXXX.Properties文件通常作为配置文件，这个知识点在IO流举例。

#### TreeMap实现类

同TreeSet一样，使用默认的构造器，TreeMap也是无序的，使用TreeMap(new Comparator{

​	//重写compare方法实现排序
​	@Override

​	public int compare(Object o1,Object o2){
​	//比较的结果是如果根据比较方法两个元素相等，则直接返回0，即后面准备放入集合的元素不会加入到集合中，就丢弃了，如果不相等，就正常加入

​	}

})实现排序。

如果添加的元素对象没有实现compareable方法，并且没有传入comparator重写的compare则，会报错，TreeSet方法同理

### 集合总结

在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类的特性进行选择，分析如下：

1. 先判断存储的类型（一组对象[单列]或一组键值对[双列]）

2. 一组对象：Collection接口
   允许重复：List
         增删多：LinkedList（底层维护了一个双向链表）
         改查多：ArrayList（底层维护Object类型的可变数组）
   不允许重复：Set
        无序：HashSet【底层是HashMap，维护了一个哈希表，即数组+链表+红黑树】
        排序：TreeSet

   ​     插入和取出顺序一致：LinkedHashSet【维护数组+双向链表】

3. 一组键值对：Map

   ​	键无序：HashMap（底层是：哈希表，jdk7：数组+链表，jdk8：数组+链表+红黑树）

   ​	键排序：TreeMap
   ​	键插入和取出顺序一致：LinkedHashMap

   ​	读取文件：properties

### Collections工具类

Collections是一个操作Set，List和Map等集合的工具类

Collections中提供了一系列静态的方法对集合元素进行排序，查找和修改等操作

- 排序操作（均为static方法）
  1.reverse（List）：反转List中元素的顺序

  2.shuffle(List)：对List集合元素进行随机排序

  3.sort（List）：根据元素的自然顺序对指定List集合按升序排序

  4.sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序

  5.swap（List，int i，int j）：将指定list集合中的i索引元素和j索引元素进行交换

- 查找，替换
  1.Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素

  2.Object max(Collection,Comparator)：根据Comparator指定的顺序，返回给定集合中的最大元素

  3.Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素

  4.Object min(Collection,Comparator)：根据Comparator指定的顺序，返回给定集合中的最小元素

  5.int frequency（Collection，Object）：返回指定集合中指定元素的出现次数

  6.void copy（List dest。List src）将src中的内容复制到dest中（注意：copy前应先对dest的空间做处理不小于src的大小，不然就会报错）

  7.boolean replaceAll（List list，Object oldval，Object newval）：使用新值替换list对象的所有旧值

## 泛型

泛型的引出，传统方法的问题

1. 不能对加入到集合ArrayList中的数据类型进行约束（不安全）
2. 遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响

泛型的好处：

1. 编译时，检查添加元素的类型，提高了安全性
2. 减少了类型转换的次数，提高效率
   - 不使用泛型
     Dog--加入--》Object-取出-》Dog //放入到ArrayList会先转成Object，在取出时，还需要转成Dog
   - 使用泛型
     Dog-->Dog-->Dog //放入时，和取出时，不需要类型转换，提高效率
3. 不再提示编译警告

泛型的理解：

泛型又称参数化类型，是jdk5.0出现的新特性，解决数据类型的安全性问题

在类声明或实例化时只要制定好需要的具体的类型即可

Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁，健壮

泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。

```java
class Person<E>{
    E s; //E 表示 s的数据类型，该数据类型在定义Person对象的时候指定，即在编译期间，就确定E是什么类型
    public Person(E s){ //E 也可以是参数类型
        this.s = s;
    }
    public E f(){ //返回类型使用 E
        return s;
    }
}
```

### 泛型的语法

泛型的声明

interface 接口<T>{}

class 类<K,V>{}

说明：1.其中，T，K，V不代表值，而是表示类型 2.任意字母都可以，常用T表示，是Type的缩写。

泛型的实例化：

1. List<String> strList = new ArrayList<String>();
2. Ierator <Customer> iterator = customers.iterator();

泛型的注意事项：

1. 给泛型指定数据类型时，要求是引用类型，不能是基本数据类型
2. 在给泛型指定具体类型后，可以传入该类型或者其子类类型
3. 如果我们这样写 List list3 = new ArrayList();默认给它的泛型是【<E> E就是Object】，我们在今后的使用中可以简写成只定义变量前的泛型，后面的对象泛型会自动推断`ArrayList<String> list = new ArrayList<>();`

### 自定义泛型

基本语法

class 类名<T,R...>{ // ...表示可以有多个泛型

成员

}

注意细节

1.普通成员可以使用泛型（属性，方法）

2.使用泛型的数组，不能初始化（因为没有确定泛型的类型，所以无法在内存开空间）

3.静态方法中不能使用类的泛型

4.泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）

5.如果在创建对象时，没有指定类型，默认是Object

- **自定义泛型接口**

基本语法

interface 接口名 <T,R,...>{ }

注意细节

1. 接口中，静态成员也不能使用泛型（这个和泛型类规定一样）
2. 泛型接口的类型，在继承接口或者实现接口时确定
3. 没有指定类型，默认为Object

- **自定义泛型方法**

基本语法

修饰符 <T,R...> 返回类型 方法名(参数列表){ }

注意细节

1. 泛型方法，可以定义在普通类中，也可以定义在泛型类中

   ```java
   class A{
       //普通类
       //泛型方法
       public <T,R> void fly(T t,R r){
           // <T,R> 就是泛型方法的标志，不带<T,R>的fly（T t，R r）只是使用了泛型的方法，并不是泛型方法
       }
   }
   class Fish<T,R>{
       //泛型类
       public void run(){
           //普通方法
       }
       public <U,M> void eat(U u,M m){
           //泛型方法
       }
   }
   ```

2. 当泛型方法被调用时，类型会确定

3. public void eat(E e){ },修饰符后没有<T,R...> eat方法不是泛型方法，而是使用了泛型

### 泛型的继承和通配符

1. 泛型不具备继承性
   `List <Object> = new ArrayList<String>();//错误的，不允许，泛型不能继承`
2. <?>：支持任意泛型类型
3. <? extends A>：支持A类以及A类的子类，规定了泛型的上限
4. <？super A>：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限

Junit使用：在方法上添加@Test标注，然后Alt+enter加载Junit引用

## 坦克大战（1）

### java绘图坐标体系

坐标原点位于左上角，以像素为单位，在java坐标系中，第一个是X坐标，表示当前位置为水平方向，距离坐标原点x个像素（像素是密度单位），第二个是y坐标，表示当前位置为垂直方向，距离坐标原点y个像素

![QQ20251027-154548](.\img\QQ20251027-154548.png)

### 绘图原理

Component类提供了两个和绘图相关最重要的方法：

1. paint(Graphics g）绘制组件的外观
2. repaint() 刷新组件的外观

当组件第一次在屏幕显示的时候，程序会自动的调用paint()方法来绘制组件。

在以下情况paint()将会被调佣：

1. 窗口最小化，再最大化
2. 窗口的大小发生变化
3. repaint函数被调用

### Graphics类

graphics类可以理解为画笔，为我们提供了各种绘制图形的方法：

1. 画直线：drawLine（int x1,int y1,int x2,int y2）
2. 画矩形边框 drawRect(int x, int y,int width,int height)
3. 画椭圆边框 drawOval(int x, int y,int width,int height)
4. 填充矩形 fillRect(int x, int y,int width,int height)
5. 填充椭圆 fillOval(int x,int y, int width, int height)
6. 画图片 drawImage(Image img,int x,int y,...)
7. 画字符串 drawString(String str,int x,int y) x,y 是string的左下角坐标
8. 设置画笔的字体 setFont(Font font)
9. 设置画笔的颜色 setColor(Color c)

### java事件处理机制

```java
// 首先创建一个面板继承Jpanel类，引入键盘监听事件
class Myanel extends JPanel implements KeyListener {
    int x=100;
    int y=100;
    //myPanel对象就是一个画板
    //Graphics g  Graphics类  画笔 提供了很多绘图的方法
    public void paint(Graphics g){
        super.paint(g); //调用父类的方法完成初始化
        // 绘制一个圆形
        g.drawOval(x,y,100,100);
        //圆形的外框矩形的右上角坐标(10,10)  矩形的宽度100  高度100 就是一个圆形
    }
    //键盘输入事件
    @Override
    public void keyTyped(KeyEvent e) {

    }
	//键盘按下事件
    @Override
    public void keyPressed(KeyEvent e) {
        if(e.getKeyCode()== KeyEvent.VK_DOWN){
            //System.out.println("向下箭头键被按下");
            y++;
        }else if(e.getKeyCode()== KeyEvent.VK_UP){
            y--;
        }else if(e.getKeyCode()== KeyEvent.VK_LEFT){
            x--;
        }else if(e.getKeyCode()== KeyEvent.VK_RIGHT){
            x++;
        }
        this.repaint(); //重绘图形
    }
	//键盘按键松开事件
    @Override
    public void keyReleased(KeyEvent e) {

    }
}

//还需要在窗口中加入键盘监听事件,不然窗口中的面板获取不到监听事件
mp = new Mypanel();
this.addKeyListener(mp);
```

java事件处理是采取“委派事件模型”。当事件发生时，产生事件的对象，会把此“信息”传递给“事件的监听者”处理，这里所说的“信息”实际上就是java.awt.ent事件类库里某个类所创建的对象，把它称为“事件的对象”。

## 程序的进程线程

进程是指运行中的程序，比如我们使用QQ，就启动了一个进程，操作系统就会为该进程分配内存空间，当我们使用迅雷，又启动了一个进程，操作系统将为迅雷分配新的内存空间。

进程是程序的一次执行过程，或是正在运行的一个程序。是动态过程：有它自身的产生，存在和消亡的过程。

**什么是线程？**

线程是由进程创建的，是进程的一个实体。一个进程可以拥有多个线程。

1. 单线程：同一个时刻，只允许执行一个线程

2. 多线程：同一个时刻，可以执行多个线程，比如：一个QQ进程，可以同时多个聊天窗口，一个迅雷进程，可以同时下载多个文件
3. 并发：同一个时刻，多个任务交替执行，造成一种“貌似同时”的错觉，简单的说，单核cpu实现的多任务就是并发。
4. 并行：同一个时刻，多个任务同时执行。多核cpu可以实现并行。

### 线程的使用

使用线程的两种方法：

1. 继承Thread类
2. 实现Runnable接口

```java
//使用继承Thread类实现多线程
public class Thread01 {
    public static void main(String[] args) {
        //创建一个Cat线程对象,可以当做线程来使用
        Cat cat = new Cat();
        //启动线程
        cat.start();
    }
}
//1.当一个类继承了Thread类，就可以当作线程来使用
//2.重写run方法，实现自己的业务逻辑，线程启动后，会调用run方法
//3.Thread类的run方法，是实现Runnable接口的run方法
class Cat extends Thread {

    @Override
    public void run() {
        int count = 0;
        while (true) {
            //重写run方法，实现自己的业务逻辑，线程启动后，会调用run方法
            System.out.println("喵喵，我是一个小猫咪" + count++);
            //让线程休眠1秒，模拟喵喵喵的过程
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            if (count == 10) { //当count等于10时，跳出循环,即结束线程
                break;
            }
        }

    }
}
```

真正让程序实现多线程的不是Thread类的run方法，而是Thread类中的start0()方法，这个方法是一个native(本地)方法，直接由jvm机调用，其他不能使用。

```java
//使用实现Runnable接口的方法实现多线程
public class Thread02 {
    public static void main(String[] args) {
        //创建一个线程对象，把dog对象（实现了Runnable接口）作为参数传递
        Thread thread = new Thread(new Dog());
        //启动线程
        thread.start();
    }
}

class Dog implements Runnable {

    @Override
    public void run() {
        int count = 0;
        while (true) {
            System.out.println("小狗汪汪叫" + (++count) +"线程名称="+Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                //获取中断异常
                throw new RuntimeException(e);
            }
            if (count == 10) {
                break;
            }
        }
    }
}
```

**继承Thread vs 实现Runnable的区别**

1. 从java的设计来看，通过继承Thread或者实现Runable接口来创建线程本质上没有区别，从jdk帮助文档我们可以看到Thread类本身就实现了Runnable接口。
2. 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制。建议使用Runnable方式。

### 线程终止

1. 当线程完成任务后，会自动退出
2. 还可以通过使用变量来控制run方法退出的方式停止线程，即通知方式

### 线程常用方法

1. setName：设置线程名称，使之与参数name相同
2. getName：返回该线程的名称
3. start：使该线程开始执行
4. run：调用线程对象的run方法
5. setPriority：更改线程的优先级
6. getPriority：获取线程的优先级
7. sleep：在指定的毫秒数内让当前正在执行的线程休眠
8. interrupt：中断线程

注意事项和细节

1. start底层会创建新的线程，调用run，run就是一个简单的方法调用，不会启动新线程。
2. 线程优先级的范围（MAX_PRIORITY =10,MIN_PRIORITY=1,NORM_PRIORITY=5）
3. interrupt 中断线程，但并没有真正的结束线程。所以一般用于中断正在休眠的线程，使线程提前继续执行。
4. sleep线程的静态方法，使当前线程休眠

常用方法2：

9. yield：线程的礼让，让出cpu，让其他线程执行，但礼让的时间不确定，所以也不一定礼让成功
10. join：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务

### 用户线程和守护线程

用户线程：也叫工作线程，当线程的任务执行完或通知方式结束

守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束

常见的守护线程：垃圾回收机制

```java
//把线程设置成守护线程
DaemonThread t = new t();
t.setDeamon(true); //设置成守护线程,主线程结束后，守护线程就自动结束
t.start();
```

### 线程的生命周期

Thread.state 线程的状态：

- NEW  尚未启动的线程
- RUNNABLE 在jvm机中执行的线程（此状态中又有Ready和Running两种状态）
- BLOCKED  被阻塞等待监视器锁定的线程
- WAITING  正在等待另一个线程执行特定动作的线程
- TIME_WAITING 正在等待另一个线程执行动作达到等待时间的线程（超时等待）
- TERMINATED 已退出的线程

![QQ20251104-161858](.\img\QQ20251104-161858.png)

### Synchronized

线程同步机制

1.在多线程编程，一些敏感数据不允许被多个线程同时访问，次数就使用同步访问技术，保证数据在任何同一时刻，最多有一个线程访问，以保证数据的完整性

2.也可以这样理解：线程同步，即当有一个线程在对内存进行操作时，其他线程都不能对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作。

同步具体方法

1.同步代码块

```java
synchronized (对象){ //非静态代码块可以对象可以用this或类名，静态代码块只能用类名
    //需要被同步代码
}
```

2.synchronized还可以放在方法声明中，表示整个方法为同步方法

```java
public synchronized void m(String name){
    //需要被同步的代码
}
```

同步方法来解决超卖问题：

```java
class Sall extends Thread {
    private static int count = 100; //共有100张票
    private boolean loop =  true; // 通知变量，控制退出线程
    //small方法设为synchronized，确保在多线程环境下，每次只能有一个线程执行small方法
    private synchronized void small() {
        if(count<=0){
            loop = false;
            return;
        }
        System.out.println(Thread.currentThread().getName()+"卖出一张票，还有" + (--count) + "张票");
    }
    @Override
    public void run() {
        while (loop) {
            small();
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }
    }
}
```

### 互斥锁

1.java语言中，引入了对象互斥锁的概念，来保证共享数据操作的完整性。

2.每个对象都对应于一个可称为“互斥锁”的标记，这个标记用来保证在任一时刻，只有一个线程访问该对象。

3.关键字synchronized来与对象的互斥锁联系，当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问

4.同步的局限性：导致程序的执行效率要降低

5.同步方法（非静态的）的锁可以是this，也可以是其他对象（要求是同一个对象）

6.同步方法（静态的）的锁为当前类本身。

注意事项和细节：

1. 同步方法如果没有使用static修饰，默认锁对象为this
2. 如果方法使用static修饰，默认锁对象：当前类.class
3. 实现的落地步骤：
   - 需要先分析上锁的代码
   - 选择同步代码块或同步方法
   - 要求多个线程的锁对象为同一个即可

### 线程的死锁

多个线程都占用了对方的锁资源，但不肯相让，导致了死锁，在编程时一定要避免死锁的发生。

### 释放锁

下面操作会释放锁：

1. 当前线程的同步方法，同步代码块执行结束（案例：上厕所，完事出来）
2. 当前线程在同步代码块，同步方法中遇到break，return。
3. 当前线程在同步代码块，同步方法中出现了未处理的Error或者Exception，导致异常结束
4. 当前线程在同步代码块，同步方法中执行了线程对象的wait()方法，当前线程暂停，并是否锁。

下面操作不会释放锁：

1. 线程执行同步代码块或同步方法时，程序调用Thread.sleep(),Thread.yield()方法暂停当前线程的执行，不会释放锁

2. 线程执行同步代码块时，其他线程调用了该线程的挂起方法suspend()方法将该线程挂起，该线程不会释放锁。

   提示：应尽量避免使用suspend()和resume()来控制线程，方法不再推荐使用

## IO流

什么是文件

文件对我们并不陌生，文件是保存数据的地方，比如我们经常使用的word文档，txt文件，都是文件，它即可以保存一张图片，也可以保存视频，声音。

**文件流**

文件在程序中是以流的形式来操作的

流：数据在数据源（文件）和程序（内存）之间经历的路径

输入流：数据从数据源（文件）到程序（内存）的路径

输出流：数据从程序（内存）到数据源（文件）的路径

**常用的文件操作**

- 创建文件对象相关构造器和方法

  相关方法：
  new File(String pathname) //根据路径构建一个File对象

  new File(File parent,String child) //根据父目录文件+子路径构架

  new File(String parent,String child)  //根据父目录+子路径构架

  createNewFile  创建新文件

- 获取文件的相关信息
  getName （文件名）、getAbsolutePath（绝地路径）、getParent（父目录）、length（文件大小字节）、exists（是否存在）、isFile（是否是文件）、isDirectory（是否是目录）

- 目录的操作和文件删除
  mkdir 创建一级目录
  mkdirs 创建多级目录

  delete 删除空目录或文件

### IO流原理及流的分类

1. I/O是Input/output的缩写，I/O技术是非常实用的技术，用于处理数据传输，如读写文件，网络通信等
2. java程序中，对于数据的输入/输出操作以“流（stream）”的方式进行。
3. java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过方法输入或输出数据
4. 输入Input：读取外部数据（磁盘，光盘等存储设备的数据）到程序（内存）中。
5. 输出Output：将程序（内存）数据输出到磁盘，光盘等存储设备中。

**流的分类**

按操作数据单位不同分为：字节流（8bit）【二进制文件无损】，字符流（按字符）【文本文件速度快】。

按数据流的流向不同分为：输入流，输出流

按流的角色的不同分为：节点流，处理流/包装流

| 抽象基类 | 字节流       | 字符流 |
| -------- | ------------ | ------ |
| 输入流   | InputStream  | Reader |
| 输出流   | OutputStream | Writer |

java的io流共涉及40多个类，实际上非常规则，都是从如上4个抽象基类派生的

由这四个类派生出来的资料名称都是以其父类名作为子类名后缀。

### InputStream

字节输入流，InputStream抽象类是所有字节输入流的超类

InputStream常用的子类：

1. FileInputStream ：文件输入流
2. BufferedInputStream：缓冲字节输入流
3. ObjectInputStream：对象字节输入流

```java
public static void main(String[] args) {
        String path = "D:\\WWW\\gitDemo\\java_code\\IO\\src\\File.txt";
        FileOutputStream fileOutputStream = null;  //定义一个空的文件输出流对象

        try {
            fileOutputStream = new FileOutputStream(path);
            //写入一个字符a
            //fileOutputStream.write('a');
            //写入字符串
            String str = "Hello World";
            //将字符串转换为字节数组并写入文件
            fileOutputStream.write(str.getBytes());
            //从索引0开始写入字符串的所有字节
            fileOutputStream.write(str.getBytes(),0,str.length());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }finally {
            try {
                fileOutputStream.close();
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
    }
```



### FileReader和FileWriter

FileReader和FileWriter是字符流，即按照字符来操作io

- FileReader相关方法：
  1. new FileReader(File/String)
  2. read：每次读取单个字符，返回该字符，如果到文件末尾返回-1
  3. read(char[])：批量读取多个字符到数组，返回读取到的字符数，如果到文件末尾返回-1
  4. 相关Api：
      new String(char[])：将char[]转换成String
      new String(char[],off,len)：将char[]的指定部分转换成String
- FileWriter常用方法
  1. new FileWriter(File/String)：覆盖模式，相当于流的指针在首端
  2. new FileWriter(File/String,true)：追加模式，相当于流的指针在尾端
  3. write(int)：写入单个字符
  4. write(char[])：写入指定数组
  5. wirte(char[],off,len)：写入指定数组的指定部分
  6. write(string)：写入整个字符串
  7. wirte(string,off,len)：写入字符串的指定部分
  8. 相关Api，String类：toCharArray：将String转换成char[]
  9. 注意：FileWriter使用后，必须要**关闭（close）或刷新（Flush）**，否则写入不到指定的文件！

```java
//复制文件到其他地方
public static void main(String[] args) {
        String path = "D:\\WWW\\gitDemo\\java_code\\IO\\src\\File.txt";
        String path2 = "D:\\WWW\\gitDemo\\java_code\\IO\\src\\Filecopy.txt";
        FileReader fileReader = null;
        FileWriter fileWriter = null;
        try{
            // 以默认模式创建文件读取流
            fileReader = new FileReader(path);
            // 以追加模式创建文件写入流
            fileWriter = new FileWriter(path2,true);
            // 读取文件内容
            char[] buffer = new char[1024];
            int length;
            // 循环读取文件内容，直到读取到文件末尾
            while((length = fileReader.read(buffer)) != -1){
                try{
                    // 写入读取到的字符数组内容
                    fileWriter.write(buffer,0,length);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
        }catch(Exception e){
            e.printStackTrace();
        }finally {
            if(fileReader != null){
                try {
                    // 关闭文件读取流
                    fileReader.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(fileWriter != null){
                try {
                    // 关闭文件写入流
                    fileWriter.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

    }
```

### 节点流和处理流

节点流可以从一个特定的数据源**读写数据**，如FileReader、FileWriter

处理流（也叫包装流）是“连接”在已存在的流（节点流或处理流）之上，为程序提供更为强大的读写功能，也更加灵活。如BufferedReader，BufferedWriter【其原理是，例如bufferReader类内定义了一个Reader属性，即可以封装任意一个节点流，只要它是Reader的子类就行】

节点流和处理流的区别和联系

1. 节点奖是底层流/低级流，直接根数据源相接。
2. 处理流包装节点流，即可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入输出。
3. 处理流（也叫包装流）对节点流进行包装，使用了修饰器设计模式，不会直接与数据源相连

处理流的功能注意提现在以下两个方面：

1. 性能的提高：主要以增加缓冲的方式来提高输入输出的效率。
2. 操作的便捷：处理流可能提供了一系列便捷的方法来一次输入输出大批量的数据，使用更加灵活方便

**处理流BuffererReader和BufferedWriter**

BufferedReader和BufferedWriter属于字符流，是按照字符来读取数据的，关闭处理流时，只需要关闭外出流即可（即关闭buffer即可，它会自动关闭传入的节点流）。

BufferedInputStream 和 BufferedOutputStream是字节流，在创建BufferedInputStream时，会创建一个内部缓冲区数组。

```java
// 使用BufferedReader和BufferedWriter拷贝数据
public static void main(String[] args){
    //注意：BufferedReader和BufferedWriter是通过字符操作，不要去操作二进制文件，可能造成文件损坏
    String srcFilePath = "D:\\WWW\\gitDemo\\java_code\\IO\\src\\File.txt";
    String srcFilePath2 = "D:\\WWW\\gitDemo\\java_code\\IO\\src\\File2.txt";
    BufferedReader br = null;
    BufferedWriter bw = null;
    String line;
    try{
        br = new BufferedReader(new FileReader(srcFilePath));
        bw = new BufferedWriter(new FileWriter(srcFilePath2));
        // readLine 读取一行内容,但是没有换行，读取到没有内容就返回null
        while((line = br.readLine())!=null){
            //每读取一行，就写入
            bw.write(line);
            // 插入一个换行
            bw.newLine();
        }
    }catch(Exception e){
       e.printStackTrace();
    }finally{
        if(br!=null){
            br.close();
        }
        if(bw!=null){
            bw.close();
        }
    }
}
```

### 序列化和反序列化

对象处理流**ObjectInputStream/ObjectOutputStream**，为了实现对象处理流，对象需要进行序列化。

1. 序列化就是在保存数据时，保存数据的值和数据类型

2. 反序列化就是在恢复数据时，恢复数据的值和数据类型

3. 需要让某个对象支持序列化机制，则必须让其类是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一：

   Serializable  //这是一个标记接口，没有方法，推荐这个
   Externalizable  //该接口有方法需要实现，不推荐

序列化和反序列化的细节：

1. 读写的顺序要一致
2. 要求实现序列化或反序列化的对象，需要实现Serializable
3. 序列化的类中建议添加SerialVersionUID，为了提高版本的兼容性
4. 序列化对象时，默认将里面所有属性都进行序列化，但除了static或transient修饰的成员
5. 序列化对象时，要求里面属性的类型也需要实现序列化接口
6. 序列化具备可继承性，也就是如果某类已经实现了序列化，则它的所有子类也已经默认实现了序列化

### 标准输入输出流

System.in  标准输入     类型：InputStream    默认设备：键盘

System.out  标准输出   类型：PrintStream    默认设备：显示器

### 转换流

InputStreamReader 和OutputStreamWriter 把字节流转换成字符流

InputStreamReader(InputStream,Charset)可以传入一个InputStream对象，而且可以指定处理的编码，所以转换流经常用于处理乱码问题。

OutputStreamWriter (OutputStream,Charset) 同理也可以将OutputStream输出字节流包装成Writer（输出字符流），并可以指定编码。

```java
public static void main(String[] args){
    String file = "e:\\a.txt";
    // 把FileInputStream 转成 InputStreamReader 并指定gbk
    InputStreamReader isr=new InputStreamReader(new FileInputStream(file));
    // 把InputStreamReader传入BufferedReader 提高效率
    BuffererReader br = new BuffererReader(isr);
    // 读取数据
    String s = br.readLine();
    System.out.println(s);
    br.close();
}
```

### 打印流

打印流 printStream（字节打印流）和PrintWriter（字符打印流）

打印流只有输出流没有输入流

```java
//更改打印输出流输出的位置（设备）
PrintStream sys = new PrintStream("e:\\f1.txt");
// PrintStream 的默认是System.out 即输出到显示器
//System 更改打印位置可以使用System.setOut(sys)
sys.print("你好，北京"); //也可以使用write()方法。
sys.close();
```

### Properties类

properties类常用于配置文件的保存和读取。

要求配置文件的格式：

键=值  这种格式

注意：键值对不需要有空格，值不需要用引号括起来，默认类似是String

Properties的常用方法

- load：加载配置文件的键值对到Properties对象
- list：将数据显示到指定设备（流对象）
- getProperty(key)：根据键获取值
- setProperty(key,val)：设置键值对到Properties对象
- store：将Properties中的键值对存储到配置文件，在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码。

```java
//使用Properties类来读取配置文件
public static void main(String[] args) {
   // 创建Properties对象
    Properties pr = new Properties();
    // 加载指定的配置文件
    pr.load(new FileReader("src\\mysql.properties"));
    // 把k-v显示到控制台
    pr.list(System.out);
    // 根据key获取对应的值
    String ip = pr.getProperty("ip");
    //设置更改k-v
    pr.setProperty("charset","utf8");
    //将k-v保存到文件中
    pr.store(new FileWriter('src\\mysql2.properties'),null);//此处的null 是注释内容
}
```

## 网络相关

网络通信

概念：两台设备之间通过网络实现数据传输

网络通信：将数据通过网络从一台设备传输到另一台设备

java.net包下提供了一系列的类或接口，供程序员使用，完成网络通信

### IP地址

概念：用于唯一标识网络中的每台计算机

查看ip地址：ipConfig

ip地址的标识形式：点分十进制 XXX.XXX.XXX.XXX

每一个十进制数的范围：0~255

ip地址的组成 = 网络地址+装机地址

ilpv6 是互联网工程任务组设计的用于替代ipv4的下一代ip协议，其地址数量号称可以为全世界的每一粒沙子编上一个地址

由于ipv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展，ipv6的使用，不仅能解决网络地址资源数量的问题，而且也解决了多种设备连入互联网的障碍。

域名：解决记忆ip困难的问题。

端口号：用于标识计算机上某个特定的网络程序，用2个字节表示端口即2^16,所以端口的范围是0~65535。0 ~1024已经被知名的程序占用，比如ssh22，ftp：21，smtp：25，http 80

常见的网络程序端口号：tomcat8080 ，mysql3306 ，oracle1521， sqlserver 1433

### 网络通信协议

ICP/IP 协议，中文译名传输控制协议/因特网互联协议，又叫做网络通讯协议。这个协议是Internet最基本的协议，Internet国际互联网络的基础，简单的说，就是由网络层的ip协议和传输层的Tcp协议组成的。

Tcp协议：传输控制协议

1. 使用tcp协议前，须建立Tcp连接，形成传输数据通道
2. 传输前，采用“三次握手”方式，是可靠 
3. Tcp协议进行通信的两个应用进程：客户端，服务端
4. 在连接中可进行大数据量的传输
5. 传输完毕，需释放已建立的连接，效率低

![QQ20251114-143929](.\img\QQ20251114-143929.png)

UDP协议：用户数据协议

1. 将数据，原，目的封装成数据包，不需要建立连接
2. 每个数据报的大小限制在64k内，不适合传输大量数据
3. 因无需连接，故是不可靠的
4. 发送数据结束时无需释放资源，速度快
5. 例如：发短信

### InetAdress类

相关方法：

1. 获取本机InetAddress对象 getLocalHost
2. 根据指定主机名/域名获取ip地址对象 getByName
3. 获取InetAddress 对象的主机名 getHostName
4. 获取InetAddress对象的地址  getHostAddress

### Socket

1. 套接字（Socket）开发网络应用程序被广泛采用，以至于成为事实上的标准
2. 通信的两端都要有Socket，是两台机器间通信的端点
3. 网络通信起始就是Socket间的通信
4. Socket允许程序把网络连接当成一个流，数据在两个Socket间通过IO传输
5. 一般主动发起通信的应用程序属客户端，等待通信请求的为服务端。

```java
// Server端
public static void main(String[] args) throws IOException {
        System.out.println("服务器启动，监听9999端口");
        // 实例化一个ServerSocket对象，监听9999端口
        ServerSocket serverSocket = new ServerSocket(9999);
        // 调用accept()方法，等待客户端连接
        // 这个serverSocket可以通过accept()返回多个Socket连接【多个客户端同时连接服务器】
        Socket socket = serverSocket.accept();
        System.out.println("客户端连接"+socket.getClass());
        // 建立输入流，读取客户端发送的消息
        InputStream inputStream = socket.getInputStream();
        // 读取客户端发送的消息
        byte[] bytes = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(bytes)) != -1) {
            //根据读取到是实际长度，截取有效数据
            System.out.println(new String(bytes, 0, readLen));
        }
    	// 获取Socket相关联的输出流
        OutputStream outputStream = socket.getOutputStream();
        // 发送消息给客户端
        outputStream.write("hello client".getBytes());
        // 发送完信息，必须设置结束标记，否则客户端会一直阻塞等待
        socket.shutdownOutput();
        // 关闭输入流
        inputStream.close();
        // 关闭socket
        socket.close();
    }
```

```java
// Client 端
public static void main(String[] args) throws  IOException {
        System.out.println("客户端启动");
        // 实例化一个Socket对象，连接服务器的9999端口
        Socket socket = new Socket("localhost", 9999);
        System.out.println("连接服务器成功"+socket.getClass());
        //发送hello 给服务器
        OutputStream outputStream = socket.getOutputStream();
    	// 使用转换流将字节流转成字符流发送消息给服务器
        BufferedWriter osw = new BufferedWriter(new OutputStreamWriter(outputStream));
        //outputStream.write("hello".getBytes()); //使用字节流
    	osw.write("你好，服务器"); // 使用字符流
    	osw.newLine();// 发送换行符，结束消息,但对方必须使用readLine()方式接收才能生效
        osw.flush(); // 使用字符流，需要手动刷新缓存，否则消息不会发送到服务器
    	//设置输出流结束标记，否则服务端会一直等待
        //socket.shutdownOutput();
    	
        // 获取Socket的输入流
        InputStream inputStream = socket.getInputStream();
    	
        // 读取服务端发送的消息
        byte[] bytes = new byte[1024];
        int readLen = 0;
        while ((readLen = inputStream.read(bytes)) != -1) {
            //根据读取到是实际长度，截取有效数据
            System.out.println(new String(bytes, 0, readLen));
        }
    	osw.close(); //关闭最外层的流即可，内层的会自动关闭
        //关闭输入流
        //inputStream.close();
        //关闭流
        outputStream.close();
        //关闭socket
        socket.close();
    }
```

netstat指令

1. netstat -an 可以查看当前主机网络情况，包括端口监听情况和网络连接情况
2. netstat -an | more  可以分页显示 空格下一页
3. netstat -anb 可以查看是那个程序在监听端口
4. 要求在dos控制台下执行

当客户端连接到服务端后，实际上客户端也是通过一个端口和服务端进行通讯的，这个端口是TCP/IP来分配的，是不确定的，是随机的。

### UDP编程

1. 类DatatramSocket和DatagramPacket实现了基于UDP协议网络程序。
2. UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据一定能够安全送到目的地，也不能确定什么时候可以抵达。
3. DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号一级接收端的ip地址和端口号
4. UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。

UDP说明：

1. 没有明确的服务端和客户端，演变成数据的发送端和接收端
2. 接收数据和发送数据是通过DatagramSocket对象完成。
3. 将数据封装到DatagramPacket对象中，发送
4. 当接收到DatagramPacket对象，需要进行拆包，取出数据
5. DatagramSocket可以指定在哪个端口接收数据

基本流程：

1. 建立发送端，接收端
2. 发送数据前，建立数据包 DatagramPacket对象
3. 调用DatagramSocket的发送，接收方法
4. 关闭DatagramSocket

```java
//Udp 接收和发送
public static void main(String[] args) throws IOException {
      //创建一个DatagramSocket对象，准备在8888接收数据
      DatagramSocket socket = new DatagramSocket(8888);
      //构建一个DatagramPacket对象，准备接收数据
      byte[] bytes = new byte[64*1024]; //udp数据报最大64k
      DatagramPacket packet = new DatagramPacket(bytes, bytes.length);
      //调用socket的receive方法，将数据接收在packet中，当本机的8888端口有数据时，就会自动接收，
        // 如果没有数据，就会阻塞等待
      socket.receive(packet);
      //从packet中拆包提取数据
      int len = packet.getLength(); //实际接收到的数据长度
      byte[] data = packet.getData();
      System.out.println(new String(data, 0, len));
      // 接收结束
      // 回复发送端
      byte[] sendData = "好的 明天见".getBytes();
      //构建一个DatagramPacket对象，准备发送数据 给发送方
      DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, packet.getAddress(), packet.getPort());
      //调用socket的send方法，将数据发送到packet中
      socket.send(sendPacket);
      //关闭socket
      socket.close();
    }
```

### 多用户即时通信系统

需求分析：

1. 用户登录
2. 拉取在线用户列表
3. 无异常退出（客户端，服务端）
4. 私聊
5. 群聊
6. 发文件
7. 服务器推送新闻

![QQ20251114-155801](.\img\QQ20251114-155801.png)



## 反射（reflection）

### 反射机制

1. 反射机制允许程序在执行期借助于Reflection Api取得任何类的内部信息（比如成员变量，构造器，成员方法等等），并能操作对象的属性及方法。反射在设计模式和框架底层都会用到
2. 加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，形象的称之为：反射

![QQ20251124-172053](.\img\QQ20251124-172053.png)

**Java反射机制可以完成**

1. 在运行时判断任意一个对象所属的类
2. 在运行时构造任意一个类的对象
3. 在运行时得到任意一个类所具有的常用变量和方法
4. 在运行时调用任意一个对象的成员变量和方法
5. 生成动态代理

**反射相关的主要类：**

1. java.lang.Class：代表一个类，Class对象表示某个类加载后在堆中的对象
2. java.lang.reflect.Method：代表类的方法，Method对象表示反射类的方法
3. java.lang.reflect.Field：代表类的成员变量，Field对象表示反射类的成员变量，getField('age')：只能获取public属性的变量。
4. java.lang.reflect.Constructor：代表类的构造方法

**反射优点和缺点**

1. 优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活，没有反射机制，框架技术就失去底层支撑。
2. 缺点：使用反射基本是解释执行，对执行速度有影响。

**反射调用优化：关闭访问检查** 

1. Method和Field、Constructor对象都有setAccessible()方法
2. setAccessible作用是启动和禁用访问安全检查的开关
3. 参数值为true表示 反射的对象在使用时取消访问检查，提高反射的效率。参数为false则表示反射的对象执行访问检查

### Class类

1. Class也是类，因此也继承Object类
2. Class类对象不是new出来的，而是系统创建的
3. 对于某个类的Class类对象，在内存中只有一份，因为类只加载一次
4. 每个类的实例都会记得自己是由哪个Class实例所生成
5. 通过Class对象可以完整地得到一个类的完整结构，通过一系列API
6. Class对象是存放在堆的
7. 类的字节码二进制数据，是放在方法区的，有的地方称为类的元数据（包括方法代码，变量名，方法名，访问权限等等）

**Class类的常用方法：**

| 方法名                                            | 功能说明                                                     |
| ------------------------------------------------- | ------------------------------------------------------------ |
| static Class forName(String name)                 | 返回指定类名name的Class对象                                  |
| Object newInstance()                              | 调用缺省构造函数，返回该Class对象的一个实例                  |
| getName()                                         | 返回此Class对象所表示的实体（类，接口，数组类，基本类型等）名称 |
| Class getSuperClass()                             | 返回当前Class对象的父类的Class对象                           |
| Class[] getInterfaces()                           | 返回当前Class对象的接口                                      |
| ClassLoader getClassLoader()                      | 返回该类的类加载器                                           |
| Class getSuperclass()                             | 返回表示此Class所表示的实体的超类的Class                     |
| Constructor[] getConstructors()                   | 返回一个包含某些Constructor对象的数组                        |
| Field[] getDeclaredFields()                       | 返回Field对象的一个数组                                      |
| Method getMethod(String name,Class... paramTypes) | 返回一个Method对象，此对象的形参类型为paramType              |

```java
class Ref{
    public static void main(String[] args){
        String path = "dpwl.cn.Car"; // 类的路径
        Class<?> cls = Class.forName(path);
        System.out.println(cls.getPackage().getName()); // 输出类的包名
        Car car = (Car)cls.newInstance(); //通过反射创建对象实例
        Field brand = cls.getField("brand"); //通过反思获取属性brand
        String val = brand.get(car); //获取car对象的brand属性的值，这里只能获取public类型的，private类型则会报错。
        brand.set(car,"奔驰"); // 通过反射给car对象的属性赋值
        Field[] fields = cls.getFields(); //得到所有的属性
        for(Field f:fields){
            System.out.println(f.getName());
        }
    }
}
```

### 获取Class类对象

1. 已知一个类的全类名，且该类在类路径下，可以通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException。示例：`Class cls = Class.forName("java.lang.Cat");`
   应用场景：多用于配置文件，读取类全路径，加载类。

2. 若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高。示例：`Class cls=Cat.class;`
   应用场景：多用于参数传递，比如通过反射得到对应构造器对象。

3. 已知某个类的实例，抵用该实例的getClass()方法获取Class对象。示例：`Class cla = 对象.getClass();`
   应用场景：通过创建好的对象，获取Class对象

4. 其他方式：通过类加载器（有4种）

   `ClassLoader cl = 对象.getClass().getClassLoader();`
   `Class cla = cl.loadClass("类的全类名");`

5. 基本数据（int,char,boolean,float,double,byte,long,short）按如下方式得到Class对象
   `Class cls = int.class`

6. 基本数据类型对应的包装类，可以通过TYPE得到Class类对象
   `Class cls = String.TYPE`

### 哪些类型有Class对象

如下类型有Class对象

1. 外部类，成员内部类，静态内部类，局部内部类，匿名内部类
2. interface：接口
3. 数组
4. enum：枚举
5. annotation：注解
6. 基本数据类型
7. void

### 类加载

反射机制是java实现动态语言的关键，也就是通过反射实现类动态加载。

1. 静态加载：编译时加载相关的类，如果没有则报错，依赖性太强
2. 动态加载：运行时加载需要的类，如果运行时不用该类，即使类不存在也不报错，降低了依赖性

```java
Dog dog = new Dog(); // 静态加载，依赖性强，若Dog类不存在，编译时就会报错
dog.cry();

Class cls = Class.forName('Person'); // 动态加载person类，Person类不存在时编译时不会报错
Object o = cls.newInstance();  // 只有代码运行到使用该类时，才会抛出异常
Method m = cls.getMethod("hi");
m.invoke(o);
```

类加载时机：

1. 当创建对象时（new） //静态加载
2. 当子类被加载时 //静态加载
3. 调用类中的静态成员时 //静态加载
4. 通过反射  //动态加载

**类加载过程**

![QQ20251127-110937](.\img\QQ20251127-110937.png)

![QQ20251127-111241](.\img\QQ20251127-111241.png)

**加载阶段**

JVM在该阶段的主要目的是将字节码从不同的数据源（可能是class文件，也可能是jar包，甚至网络）转化成**二进制字节流加载到内存中**，并生成一个代表该类的java.lang.Class对象

**连接阶段--验证**

1. 目的是为了确保Class文件的字节流中包含的信息复合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
2. 包括：文件格式验证（是否以魔数oxcafebabe开头）、元数据验证，字节码验证和符号引用验证
3. 可以考虑使用-Xverify：none 参数来关闭大部分的类验证措施，缩短虚拟机类加载的时间。

**连接阶段--准备**

1. JVM会在该阶段对静态变量，分配内存并默认初始化（对应数据类型的默认初始值，如0,0L，null，false等）。这些变量所使用的内存都将在方法区中进行分配

```java
Class A{
    //分析类加载的链接阶段-准备 属性是如何处理
    public int n1 = 10;
    // n1 是实例属性，不是静态变量，因此在准备阶段，是不会分配内存
    public static int n2 = 20;
    // n2 是静态属性， 分配内存 进行默认初始化0，而不是20，初始化成20要等到类加载的初始化阶段才可以
    public static final int n3 = 30;
    // n3 是static final 是常量，它和静态变量不一样，因为一旦赋值就不改变，所以直接初始化成30
}
```

**连接阶段--解析**

虚拟机将常量池内的符号引用替换为直接引用的过程。

**Initialization--初始化**

1. 到初始化阶段，才真正开始执行类中定义的java程序代码，此阶段是执行<clinit>()方法的过程。
2. <clinit>()方法是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有**静态变量**的赋值动作和**静态代码块**中的语句，并进行合并。
3. 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。

### 通过反射获取类的结构信息

java.lang.Class类

1. getName：获取全类名
2. getSimpleName：获取简单类名
3. getFields：获取所有public修饰的属性，包含本类以及父类的
4. getDeclaredFields：获取本类中所有属性
5. getMethods：获取所有public修饰的方法，包含本类以及父类的
6. getDeclaredMethods：获取本类中所有方法
7. getConstructors：获取所有public修饰的构造器
8. getDeclaredConstructors：获取本类中所有构造器
9. getPackage：以Package形式返回包信息
10. getSuperClass：以Class形式返回父类信息
11. getInterfaces：以Class[]形式返回接口信息
12. getAnnotations：以Annotation[]形式返回注解信息

java.lang.reflect.Field类

1. getModifiers：以int形式返回修饰符【说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16】
2. getType：以Class形式返回类型
3. getName：返回属性名

java.lang.reflect.Method类

1. getModifiers：以int形式返回修饰符【说明：默认修饰符是0，public是1，private是2，protected是4，static是8，final是16】
2. getReturnType：以Class形式获取 返回类型
3. getName：返回方法名
4. getParameterTypes：以Class[]返回参数类型数组

java.lang.reflect.Constructor类

1. getModifiers：以int形式返回修饰符
2. getName：返回构造器名（全类名）
3. getParameterTypes：以Class[]返回参数类型数组

### 通过反射访问类中的成员

通过反射创建对象

1. 方式一：调用类中的public修饰的无参构造器
2. 方式二：调用类中的指定构造器
3. Class类相关方法
   - newInstance：调用类中的无参构造器，获取对应类的对象
   - getConstructor(Class...clazz)：根据参数列表，获取对应的public构造器对象
   - getDecalaredConstructor(Class...clazz)：根据参数列表，获取对应的所有构造器对象
4. Constructor类相关方法
   - setAccessible：爆破 ，使用反射可以访问private构造器
   - newInstance(Object...obj)：调用构造器

通过反射访问属性

1. 根据属性名获取Field对象
   Field f = clazz对象.getDeclaredField(属性名);
2. 爆破
   f.setAccessible(true)； // f是Field，设置成爆破模式，可以对私有属性进行赋值和访问。
3. 访问
   f.set(o,值);
   syso(f.get(o));
4. 如果是静态属性，则set和get中的参数o，可以写成null

通过反射访问类中的方法

1. 根据方法名和参数列表获取Method方法对象：Method m = clazz.getDeclaredMethod(方法名,XX.class);
2. 获取对象：Object o = clazz.newInstance();
3. 爆破：m.setAccessible(true)；
4. 访问：Object ReturnValue = m.invoke(o,实参列表);
5. 注意：如果是静态方法，则invoke的参数o，可以写成null。
5. 在反射中，如果方法有返回值，统一返回的是Object，但是他运行类型和方法定义的返回类型一致。

## Mysql

连接到mysql服务的指令

`net stop mysql` 停止mysql服务

`net start mysql` 启动mysql服务

`mysql -h 主机IP -P 端口 -u 用户名 -p密码` 连接mysql数据库

`show databases;` 展示所有的数据库

`use XXXXX;`  更改正在使用的数据库

`show tables;` 展示正在使用数据库中的所有表

`quit` 退出mysql数据库

注意：-p密码 不要有空格，-p后没有写密码，回车后会要求输入密码
-h 和-P 不写，默认就是连接到本地，端口默认是3306

**Sql语句分类**

DDL：数据定义语句 [create 库，表]

DML：数据操作语句 [insert，update，delete]

DQL：数据查询语句 [select]

DCL：数据控制语句 [管理数据库：比如用户权限 grant revoke]

### 创建数据库

`CREATE DATABASE [IF NOT EXISTS] db_name [参数1] [参数2];`

[IF NOT EXISTS]：判断数据库是否存在，防止重复

参数1：character set：指定数据库采用的字符集，如果不指定默认是utf-8；

参数2：collate：指定数据库字符集的校队规则（常用的utf8_bin[区分大小写],utf8_general_ci[不区分大小写]）默认的是utf8_general_ci

`DROP DATABASE db_name;` 删除数据库

`show create database db_name；` 显示数据库创建语句

`drop database [if exists] db_name;` 判断数据库是否存在，存在就删除数据库【慎用】

注意：在创建数据库，表的时候，为了规避关键字，可以使用反引号括起来。

### 备份和恢复

备份命令：必须早dos下运行

`mysqldump -u 用户名 -p密码 -B 数据库1 数据库2 数据库n > 文件名.sql`

备份数据表

`mysqldump -u 用户名 -p密码 数据库 表1 表2 表n > d:\\文件名.sql`

恢复数据库命令（注意：进入mysql命令行再执行）

`Source 文件名.sql`

### 创建表

`CREATE TABLE table_name (field1 datatype,field2 datatype,field3 datatype) character set 字符集 collate 校对规则 engine 引擎;`

field: 指定列名 datatype：指定列类型（字段类型）

character set：字符集如不指定则采用所在数据库的字符集

collate：如不指定则采用所在数据库的校对规则

engine：存储引擎 常用的有myisam 或者innodb

### Mysql常用数据类型

| 分类             | 数据类型               | 说明                                                         |
| ---------------- | ---------------------- | ------------------------------------------------------------ |
| 数值类型         | BIT(M)                 | 位类型，m指定位数bit(8)就表示一个字节0-255，默认值1，范围1-64 |
|                  | TINYINT[UNSIGNED]      | 带符号的范围是-128到127，无符号0到255，默认是由符号占用1个字节 |
|                  | SMALLINT[UNSIGNED]     | 带符号是负2^15到2^15-1，无符号0到2^16-1占用2个字节           |
|                  | MEDIUMINT[UNSIGNED]    | 带符号是负2^23到2^23-1，无符号0到2^24-1占用3个字节           |
|                  | INT[UNSIGNED]          | 带符号是负2^31到2^31-1，无符号0到2^32-1占用4个字节           |
|                  | BIGINT[UNSIGNED]       | 带符号是负2^63到2^63-1，无符号0到2^64-1占用8个字节           |
|                  | FLOAT[UNSIGNED]        | 占用空间4个字节                                              |
|                  | DOUBLE[UNSIGNED]       | 表示比float精度更大的小数，占用空间8个字节                   |
|                  | DECIMAL(m,d)[UNSIGNED] | 定点数M指定长度，D表示小数点的位数，如果D=0表示没有小数，M最大65默认是10，D最大是30默认是0 |
| 文本，二进制类型 | CHAR(size)             | 固定长度字符串，最大255个**字符**。                          |
|                  | VARCHAR(size)          | 可变长度字符串0~65535[2^16-1]个**字节**。utf8编码（3个字节表示1个字符）最大21844个字符，1-3个字节用于记录大小。字符计算公式：size=(65535-3)/编码1个字符占用的字节数 |
|                  | BLOB和LONGBLOB         | 二进制数据BLOB(0~2^16-1),LONGBLOB(0~2^32-1)                  |
|                  | TEXT 和LONGTEXT        | 文本text(0~2^16-1)，longtext(0~2^32-1)                       |
| 时间日期         | DATE                   | 日期类型（YYYY-MM-DD）                                       |
|                  | DATETIME               | （YYYY-MM-DD HH:mm:ss）                                      |
|                  | TimeStamp              | 表示时间戳，它可用于自动记录insert，update操作的时间         |

数据类型选用规则：在能够满足需求的情况下，尽量选择占用空间小的类型。（保小不保大）

字符串使用细节“

1. char(4) ：这个4表示字符数（最大255），不是字节数，不管是中文还是字母都是放4个，按字符计算。
   varchar(4)：这个4表示字符数，不管是字母还是中文都以定义好的表的编码来存放数据。
   不管是中文还是英文字母，都是最多存放4个，是按照字符来存放的。
2. char(4) 是定长（固定的大小），就是说，即使你插入‘11’，也会占用分配的4个字符的空间
   varchar(4)是变长，就是说，如果你插入了'aa'，实际占用空间大小并不是4个字符，而是按照实际占用空间来分配（varchar本身还需要用1-3个字节来记录存放内容长度）
3. 什么时候使用char，什么时候使用varchar
   - 如果数据是定长，推荐使用char，比如md5的密码，邮编，手机号，身份证号等
   - 如果一个字段的长度是不确定，我们使用varchar，比如留言，文章
   - 查询速度：char > varchar
4. 在存放文本时，也可以使用text数据类型，可以将text列视为varchar列，注意text不能有默认值，大小0-2^16字节，如果希望存放更多字符，可以选择 mediumtext（0-2^24）或者longtext（0-2^32）

```sql
CREATE TABLE `test` (
  `id` int(11) DEFAULT NULL,
  `time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
    # 设置添加和修改自动更新时间戳
) ENGINE=InnoDB DEFAULT CHARSET=utf8
```

###  修改表

使用ALTER TABLE语句追加，修改或删除列的语法

添加列：

`ALTER TABLE tablename ADD(column datatype [DEFAULT expr] [,colunm datatype]...) ;` expr 可以是 after 列名（列添加到某列后）

修改列：

`ALTER TABLE tablename MODIFY (column datatype [DEFAULT expr] [,colunm datatype]...);`

```alter table tablename change `列名` `新列名` varchar(64) not null default ' ';``` 修改列名

删除列：

`ALTER TABLE tablename DROP (column);`

查看表的结构：` desc tabename;`  显示所有列

修改表名：`Rename table 表名 to 新表名;`

修改表字符集：`alter table 表名 character set 字符集;`

### CRUD

添加数据

`INSERT INTO table_name [(column[,column...])] VALUES (value [,value...]);`

修改数据

`UPDATE tb_name SET col_name=expr [,col_name2=expr2...] [WHERE where_definition];`

删除数据

`DELETE from tb_name [WHERE where_definition];`

查询数据

`SELECT [DISTINCT] *|{column1,column2,column3...} FROM tablename;`

注意事项：

1. select指定查询那些列的数据。
2. column指定列名
3. *号代表查询所有列
4. From指定查询哪张表
5. **DISTINCT**可选，指显示结果时，去除重复数据

使用表达式对查询的列进行运算

`SELECT *|{column1|expression,column2|expression...} FROM tablename;`

在select语句中可以使用as语句

`SELECT column as 别名 from 表名;`

在where子句中经常使用的运算符

| 比较运算符 | >、 <、 >=、 <= 、= 、<> 、!= | 大于，小于，大于（小于）等于，不等于           |
| ---------- | ----------------------------- | ---------------------------------------------- |
|            | BETWEEN...AND                 | 显示在某一区间的值（是闭区间）等价于 >= and <= |
|            | in（set）                     | 显示在in列表中的值，例：in(100,200)            |
|            | LIKE '', NOT LIKE ''          | 模糊查询                                       |
|            | IS NULL                       | 判断是否为空（不能使用 = null）                |
| 逻辑运算符 | and                           | 多个条件同时成立                               |
|            | or                            | 多个条件任一成立                               |
|            | not                           | 不成立，例：where not (salary>100)             |

使用order by 子句排序查询结果

`SELECT column1,column2,column3... From tb_name order by column asc|desc,...`

1. Order by 指定排序的列，排序的列既可以是表中的列名，也可以是select 语句后指定的列名
2. ASC 升序[默认]，desc降序
3. order by 子句应位于select语句的结尾。

### 统计函数

**Count** 返回行的总数

`select count(*)|count(列名) from tablename [WHERE where_definition]`;

count(*) 返回满足条件的记录的行数

count(A列)：统计满足条件的A列有多少个，但是会排除A列为null的情况

**SUM** 函数返回满足where条件的行的和（一般用在数值列）

`select sum(列名) {,sum(列名)...} from tablename [where where_definition];`

注意：sum只对数值起作用，否则没有意义。

**AVG** 返回列的平均值

**Max** 返回列的最大值

**Min** 返回列的最小值

### 分组查询

group by 子句对列进行分组

`SELECT column1,column2,column3...From table group by column [,column2]`

having 子句对分组后的结果进行过滤

`SELECT column1,column2,column3...From table group by column having ...`

### 字符串相关函数

| CHARSET(str)                             | 返回字符串的字符集                                   |
| ---------------------------------------- | ---------------------------------------------------- |
| CONCAT(string2[,...])                    | 连接字符串                                           |
| INSTR(string,substring)                  | 返回substring在string中出现的位置，没有返回0         |
| UCASE(string)                            | 转成大写                                             |
| LCASE(string)                            | 转成小写                                             |
| LEFT(string,length),RIGHT(string,length) | 从string中的左边起取length个字符,右边取              |
| LENGTH(string)                           | string长度【按照字节】                               |
| REPLACE(str,search_str,replace_str)      | 在str中用replace_str替换search_str                   |
| STRCMP(string1,string2)                  | 逐字符比较两字串大小相等返回0                        |
| SUBSTRING(str,position[,length])         | 从str的position位开始（从1开始计算），去length个字符 |
| LTRIM(string), RTRIM(string)，trim       | 去除前端空格或后端空格或前后都去                     |

### 数学相关函数

| ABS(num)                    | 绝对值                                                       |
| --------------------------- | ------------------------------------------------------------ |
| BIN(decimal_number)         | 十进制转二进制                                               |
| CEILING(num)                | 向上取证，得到比num大的最小整数                              |
| CONV(num,from_base,to_base) | 进制转换                                                     |
| FLOOR(num)                  | 向下取整，得到比num小的最大整数                              |
| FORMAT(num,decimal_places)  | 保留decimal_places位的小数（四舍五入）                       |
| HEX(decimalNumber)          | 转十六进制                                                   |
| LEAST(number,number2[,...]) | 求最小值                                                     |
| MOD(num,denominator)        | 求余                                                         |
| RAND([seed])                | 随机数，rand()的范围大于等于0，小于等于1，使用了seed（seed不变）就会产生相同的随机数 |

### 时间日期相关函数

| CURRENT_DATE()                                               | 当前日期                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| CURRENT_TIME()                                               | 当前时间                                                     |
| CURRENT_TIMESTAMP()                                          | 当前时间戳                                                   |
| DATE(datetime)                                               | 返回datetime的日期部分                                       |
| DATE_ADD(date2,interval d value_type)                        | 在date2中加上d日期或时间                                     |
| DATE_SUB(date2,interval d value_type)                        | 在date2上减去一个d日期或  时间                               |
| DATEDIFF(date1,date2)                                        | 两个日期差（天）                                             |
| TIMEDIFF(time1,time2)                                        | 两个时间差（多少小时多少分钟多少秒）                         |
| NOW()                                                        | 当前时间                                                     |
| YEAR\|Month\|DATE(datetime) FROM_UNIXTIME()<br />unix_timestamp() | 年月日,unix_timestamp()从1970-01-01到现在的秒数，FROM_UNIXTIME()把时间戳转成一个指定格式的日期时间 |

```sql
-- 日期增加80年
select DATE_ADD('1989-04-27',interval 80 year) from dual;
-- DATE_ADD和DATE_SUB的value_type可以是Year，month，day，hour，minute，second,并且date可以是date，datetime，timestamp中的任一种。
-- sql中的日期时间都是 yyyy-mm-dd HH：ii：ss的格式
```

### 加密和系统的函数

| USER()                                         | 查询用户 （返回用户@IP地址）                                 |
| ---------------------------------------------- | ------------------------------------------------------------ |
| DATABASE()                                     | 数据库名称                                                   |
| MD5(str)                                       | 为字符串算出一个MD5 32的字符串常用（用户密码）加密           |
| PASSWORD(str)<br />select * from mysql.user \G | 从原文密码str 计算并返回密码字符串，通常用于对mysql数据库的用户密码加密 |

### 流程控制函数

| IF(expr1,expr2,expr3)                                        | 如果expr1位true，则返回expr2，否则返回expr3                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| IFNULL(expr1,expr2)                                          | 如果expr1不为空null，则返回expr1，否则返回expr2              |
| select CASE when expr1 then expr2 when expr3 then expr4 ELSE expr5 END；【类似多重分支】 | 如果expr1位true，则返回expr2，如果expr3为t，返回expr4，否则返回expr5 |

### 查询加强

使用where子句

在mysql中，日期类型可以直接比较 `select * from emp where hiredate >'1992-01-01';`

日期比较时，必须注意格式

使用like操作符

%：表示0到多个任意字符

_：表示单个任意字符

分页查询

`select ... limit start,rows`表示从start+1行开始取，取出rows行，start从0开始计算
分页公式：limit 每页显示记录数X（第n页-1），每页显示记录数

如果select 语句同时包含有group by，having，limit，order by 那么他们是顺序是group by，having，order by，limit。

```sql
# select 和 update 混用 
UPDATE dp_alumnus a INNER JOIN (SELECT id,SUBSTR(SUBSTR(bybj,4),1,length(SUBSTR(bybj,4))-1) as bj FROM dp_alumnus) b on a.id = b.id SET a.bybj=b.bj
ALTER TABLE dp_alumnus MODIFY bybj INT(2) DEFAULT NULL
```

### 多表查询

`select * from emp,dept;`

同时查询两张表在默认情况下：1.从第一张表中取出一行和第二张表的每一行进行组合，返回结果[含有两张表的所有列]2. 一共返回的记录数是第一张表的行数*第二张表的行数3.这样多表查询默认处理返回的结果，称为笛卡尔集。4.解决这个多表的关键就是要写出正确的过滤where条件 `select * from emp,dept where emp.depno = dept.deptno;`

小技巧：多表查询的条件不能少于表的个数-1，否则会出现笛卡尔集

**自连接**

自连接是指在同一张表的连接查询【将同一张表看做两张表】

`select * from emp，emp;`这种写法报表名不是唯一的错误，正确的写法应该是：

`select * from emp woker,emp boss;` 给表设置一个别名，然后通过正确的where来过滤

`select woker.ename as '职员名',boss.ename as '上级名' from emp woker,emp boss where woker.mgr = boss.empno;`

自连接的特点：1. 把同一张表当做两张表使用 2. 需要给表取别名： `表名 表别名`， 3.列名不明确可以指定列的别名：`列名 as 列别名` 4.别名的as 可以用空格代替，因此如果是两个单词之间有空格的必须用“ ”括起来。

### 子查询

子查询是指嵌入在其他sql语句中的select语句，也叫嵌套查询

单行子查询是指只返回一行数据的子查询语句

`select * from emp where deptno =(select deptno from emp where name='simth');`

多行子查询指返回多行数据的子查询 使用关键词 in

`select name,job,sal,deptno from emp where job in(select distinct job from emp where deptno =10) and deptno <> 10; `

把子查询当做一张临时表可以解决很多复杂的查询

`select goods_id,ecs_goods.cat_id,goods_name,shop_price from ecs_goods,(select cat_id,max(shop_price) as max_price from ecs_goods group by cat_id) temp where ecs_goods.cat_id=temp.cat_id and ecs_goods.shop_price=temp.max_price;`

**all 操作符**

`select ename,sal,deptno from emp where sal> All(select sal from emp where deptno = 30);` #查询工资比30号部门的所有员工的工资都高的员工的姓名，工资和部门（相当于sal>max）

**ANY 操作符**

查询工资比30号部门的任何一个员工的工资都高的员工的姓名，工资和部门(相当于sal>min)

`select ename,sal,deptno from emp where sal> ANY(select sal from emp where deptno = 30);`

**多列子查询**

多列子查询是指查询返回多个列数据的子查询语句

语法：`(字段1，字段2...)=(select 字段1,字段2 from...)`

```sql
# 查询与smith同部门同岗位的其他所有员工
# 1.分析，得到smith的部门和岗位
select deptno，job from emp where ename = 'smith';
#2.查询同部门同岗位的 使用多列子查询匹配
select ename from emp where (deptno,job)=(select deptno，job from emp where ename = 'smith') and ename != 'smith';
```

### 表复制

自我复制数据（蠕虫复制）

有时，为了对某个sql语句进行效率测试，我们需要海量数据时，可以使用此法为表创建海量数据。

```insert into my_table (id,`name`,sal,job,deptno) select empno,ename,sal,job,deptno from emp;``` 复制emp表的数据到my_table表

自我复制：`insert into my_table select * from my_table;`

复制表结构：`create table my_tab like emp;`

去除表中的重复记录：思路分析1.可以先创建一个临时表 like 要去重的表2.select DISTINCT * 查询去重的数据3.insert into 临时表 select distinct * from 要去重的表 4.清除去重的表数据5.把临时表的数据insert 到去重的表5.drop临时表

### 合并查询

有时在实际应用中，为了合并多个select语句的结果，可以使用集合操作符号union，union all

1. union all ：该操作符用于取得两个结果集的并集。当使用该操作符时，不会取消重复行。
   `select ename,sal,job from emp where sal>2500 union all select ename,sal,job from emp where job='manager';`
2. union ：该操作符与union all相似，但是会自动去掉结果集中重复行

### 外连接

前面学习的多表查询，是利用where子句对多表形成的笛卡尔集进行筛选，根据关联条件，显示所有匹配的记录，匹配不上的，则不显示。

1. 左外连接（如果左侧的表完全显示我们就说是左外连接，即左侧的表和右侧的表没有匹配的，也把左侧的表数据完全显示出来）`select ..from  左表 left join 右表 on 条件`
2. 右外连接（如果右侧的表完全显示我们就说是右外连接）`select ..from  左表 right join 右表 on 条件`

### mysql 约束

约束用于确保数据库的数据满足特定的商业规则。

在mysql 中，约束包括：not null(不为空）,unique(唯一）,primary key(主键）,foreign key(外键）和check(检查）五种。

**primary key**：用于唯一的标识表行的数据，当定义主键约束后，该列不能重复。

`语法：字段名 字段类型 primary key`

主键的细节：

1. primary key 不能重复而且不能为null
2. 一张表最多只能有一个主键，但可以是复合主键（`primary key (id,ename)`id+name才是主键）
3. 主键的指定方式有两种：直接在字段名后指定：字段名 primary key，在表定义最后写 primary key(列名);
4. 使用desc 表名，可以看到primary key的情况。

**not null**： 如果在列上定义了not null，那么当插入数据时，必须为列提供数据。
`语法：字段名 字段类型 not null`

**unique**：当定义了唯一约束后，该列的值是不能重复的。
`语法：字段名 字段类型 unique`

细节：如果没有指定not null，则unique字段可以有多个null，一张表可以有多个unique字段。

**foreign key**：用于定义主表和从表之间的关系：外键约束要定义在从表上，主表则必须具有主键约束或是unique约束，当定义外键约束后，要求外键列数据必须在主表的主键列存在或为null，要先确保主表存在，才能外键约束。

`foreign key (本表字段名) references 主表名(主键名或unique字段名)`

![2025-12-02_194126](.\img\2025-12-02_194126.png)

![2025-12-02_194809](.\img\2025-12-02_194809.png)

外键细节：

1. 外键指向的表的字段，要求是primary key或者是unique
2. 表的类型是innodb，这样的表才支持外键
3. 外键字段的类型要和主键字段的类型一致（长度可以不同）
4. 外键字段的值，必须在主键字段中出现过，或者为null[前提是外键字段运行为null]
5. 一旦建立主外键的关系，数据不能随意删除了。

**check**：用于强制行数据必须满足的条件，假定在sal列上定义了check约束，并要求sal列值在1000-2000之间如果不在1000-2000之间就会提示出错。

oracle和sql server均支持check，但是mysql5.7目前还不支持check，只做语法校验，但不会生效。

`语法：列名 类型 check (check条件)`

**自增长**

`语法：字段名 整型 primary key auto_increment`

自增长细节：

1. 一般来说自增长是和primary key 配合使用的
2. 自增长也可以单独使用[但是需要配合一个unique]
3. 自增长修饰的字段为整数型的（虽然小数也可以但是非常非常少这样用）
4. 自增长默认从1开始，也可以通过如下命令修改`alter table 表名 auto_increment = 数字;`
5. 如果添加数据时，给自增长字段指定的有值，则以指定的值为准

### mysql索引

说起提高数据库性能，索引是最物美价廉的东西了，不用加内存，不用改程序，不用调sql，查询速度就可以提高百倍千倍。

创建索引本身会占用空间，数据库表的体积会变大

创建索引后，只对创建了索引的列有效，查询没有索引的字段依然会比较慢

没有索引会进行全表扫描，使用索引会形成一个索引的数据结构，比如二叉树。

索引的代价：1. 增加磁盘占用 2.对dml（update，delete，insert）语句的效率影响

**索引的类型**

1. 主键索引，主键自动的为主索引（类型primary）
2. 唯一索引（UNIQUE）
3. 普通索引（INDEX）
4. 全文索引（FULLTEXT）【适用于MyISAM】，一般开发中，不使用mysql自带的全文索引，而是考虑使用：java框架的全文搜索Solr和Elasticsearch（ES）

**索引使用**

1.添加索引
`create [unique] index index_name on tbname(col_name [(length)] [ASC|DESC], ...);` 添加[唯一]普通索引

`alter table tbname ADD INDEX [index_name] (index_col_name,...);` 添加普通索引

2.添加主键（索引）

` alter table 表名 ADD PRIMARY KEY （列名，...）;`

3.删除索引

`DROP INDEX index_name ON tb_name;`

`alter table tbname drop index index_name;`

4.删除主键索引 比较特别

`alter table tbname drop primary key;`

5.显示表索引

`show index from tbname; `

`show indexes from tbname; `

`show keys from tbname; `

6.如何选择索引：如果某列的值，是不会重复的，则优先考虑使用unique索引，否则使用普通索引。

哪些列上适合使用索引：

1. 较频繁的作为查询条件字段应该创建索引
2. 唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件
   `select * from emp where sex='男'`
3. 更新非常频繁的字段不适合创建索引
4. 不会出现在wehere子句中字段不该创建索引

### mysql事务

事务用于保证数据的一致性，它由一组相关的dml语句组成，该组的dml语句要么全部成功，要么全部失败。如：转账就要用事务来处理，用以保证数据的一致性。

**事务和锁**

当执行事务操作时（dml语句），mysql会在表上加锁，防止其他用户改表的数据。这对用户来讲是非常重要的。

mysql 数据库控制台事务的几个重要操作

1. start transaction  --开始一个事务
2. savepoint 保存点名 --设置保存点
3. rollback to 保存点名 --回退事务
4. rollback  --回退全部事务
5. commit  --提交事务，所有的操作生效，不能回退

事务细节：

1. 如果不开始事务，默认情况下，dml操作是自动提交的，不能回滚。
2. 如果开始一个事务，你没有创建保存点，你可以执行rollback，默认是回退到事务开始的状态
3. 你可以再这个事务中（还没有提交时），创建多个保存点，比如：savepoint aaa；执行dml，savepoint bbb；
4. 你可以再事务没有提交前，选择回退到那个保存点。（提交后所有的保存点删除，如果之间回滚到aaa，则中间的保存到（bbb）就会被删除，不能再回到bbb。）
5. mysql的事务机制需要innodb的存储引擎才可以使用，MyISAM不好使
6. 开始一个事务 start transaction 或 set autocommit=off；

**事务的隔离级别**

多个连接开启各自事务操作数据库中数据时，数据库系统要负责隔离操作，以保证各个连接在获取数据时的准确性。

脏读（dirty read）：当一个事务读取另一个事务尚未提交的改变时，产生脏读

不可重复读（nonrepeatable read）：同一查询在同一事务中多次进行，由于其他提交事务所做的修改或删除，每次返回不同的结果集，此时发生不可重复读。

幻读（phantom read）：同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻读。

mysql隔离级别定义了事务与事务之间的隔离程度。

| mysql隔离级别                | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| ---------------------------- | ---- | ---------- | ---- | ------ |
| 读未提交（read uncommitted） | √    | √          | √    | 不加锁 |
| 读已提交（read committed）   | ×    | √          | √    | 不加锁 |
| 可重复读（repeatable read）  | ×    | ×          | ×    | 不加锁 |
| 可串行化（serializable）     | ×    | ×          | ×    | 加锁   |

`select @@tx_isolation;` 查询当前mysql会话的隔离级别

`select @@global.tx_isolation;` 查看系统的隔离级别

`set session transaction isolation level read uncommitted` 设置当前会话的隔离级别

`set global transaction isolation level read uncommitted` 设置系统的隔离级别

mysql默认的事务隔离级别是repeatable read，一般情况下，没有特殊要求，没有必要修改（因为该级别可以满足绝大部分项目需求）

**事务的acid特性**

原子性（Atomicity）

原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。

一致性（Consistency）
事务必须使数据库从一个一致性状态变换到另外一个一致性状态

隔离性（Isolation）

事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

持久性（Durability）

持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

### mysql 表类型和存储引擎

mysql的表类型由存储引擎（storage Engines）决定，主要包括MyISAM，innodb，memory等。

mysql数据报主要支持六种类型，分别是：csv，menory，archive，MRG_MyISAM，MyISAM，innodb。

这六种又分为两类，一个是“事务安全型”（transaction-safe），比如：Innodb，其余都属于第二类，称为“非事务安全型”（non-transaction-safe）[myisam和memory]。

| 特点         | Myisam | Innodb | Memory | Archive |
| ------------ | ------ | ------ | ------ | ------- |
| 批量插入速度 | 高     | 低     | 高     | 非常高  |
| 事务安全     |        | 支持   |        |         |
| 全文索引     | 支持   |        |        |         |
| 锁机制       | 表锁   | 行锁   | 表锁   | 行锁    |
| 存储限制     | 没有   | 64TB   | 有     | 没有    |
| B树索引      | 支持   | 支持   | 支持   |         |
| 哈希索引     |        | 支持   | 支持   |         |
| 集群索引     |        | 支持   |        |         |
| 数据缓存     |        | 支持   | 支持   |         |
| 索引缓存     | 支持   | 支持   | 支持   |         |
| 数据可压缩   | 支持   |        |        | 支持    |
| 空间使用     | 低     | 高     | N/A    | 非常低  |
| 内存使用     | 低     | 高     | 中等   | 低      |
| 支持外键     |        | 支持   |        |         |

表的存储引擎选择：

1. 如果不需要事务，处理的只是基本的crud操作，那么MyISAM是不二选择，速度快。
2. 如果需要支持事务，选择innodb
3. Memory存储引擎就是将数据存储在内存中，由于没有磁盘I/O的等待，速度极快。但由于是内存存储引擎，所做的任何修改在mysql服务重启后都将消失。

`alter table tbname engine=存储引擎;` 修改表的存储引擎

### 视图

视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含列，其数据来自对应的真实表（基表），通过视图可以修改基表的数据，基表的改变也会影响到视图的数据。

create view 视图名 as select 语句  ：创建视图

alter view 视图名 as select 语句  ：修改视图

show create view 视图名  ：显示视图创建语句

drop view 视图名1，视图名2  ：删除视图

desc 视图名  ：显示视图结构

**视图的最佳实践**

1. 安全。一些数据表有着重要的信息，有些字段是保密的，不能让用户直接看到。这时就可以创建一个视图，在这张视图中只保留一部分字段。这样，用户就可以查询直接需要的字段，不能查看保密的字段。
2. 性能。关系数据库的数据常常会分表存储，使用外键建立这些表的之间关系。这时数据库查询通常会用到链接（join）。这样做不但麻烦，效率相对也必将低。如果建立一个视图，将相关的表和字段组合在一起，就可以避免使用join查询数据。
3. 灵活。如果系统中有一张旧的表，这张表由于设计的问题，即将被废弃。然而，很多应用都是基于这张表，不易修改。这时就可以建立一张视图，视图中的数据直接映射到新建的表。这样，就可以少做很多改动，也达到了升级数据表的目的。

### mysql用户管理

mysql中的用户，都存储在系统数据库mysql中的user表

其中user表的重要字段说明：

1. host：运行登录的“位置”，localhost表示该用户只允许本机登录，也可以指定ip地址，比如：192.168.1.100
2. user： 用户名
3. authentication_string： 密码，是通过mysql的password()函数加密之后的密码。

创建用户

`create user '用户名'@'允许登录位置' identified by '密码';`

删除用户

`drop user '用户名'@'允许登录位置';`

**修改密码**

修改自己的密码：`set password=password('新密码');`

修改他人的密码（需要有修改用户密码的权限）：

`set password for '用户名'@'登录位置' = password('新密码');`

**用户权限**

| 权限                    | 意义                                                         |
| ----------------------- | ------------------------------------------------------------ |
| ALL [PRIVILEGES]        | 设置除GRANT OPTION之外的所有简单权限                         |
| ALTER                   | 允许使用alter table                                          |
| ALTER ROUTINE           | 更改或取消已存储的子程序                                     |
| CREATE                  | 允许使用create table                                         |
| CREATE ROUTINE          | 创建已存储的子程序                                           |
| CREATE TABLESPACE       |                                                              |
| CREATE TEMPORARY TABLES | 允许使用create temporary table                               |
| CREATE USER             | 允许使用create user，drop user，rename user和revoke all privileges |
| CREATE VIEW             | 允许使用create view                                          |
| DELETE                  | 允许使用delete                                               |
| DROP                    | 允许使用drop table                                           |
| EVENT                   |                                                              |
| EXECUTE                 | 允许用户允许已存储的子程序                                   |
| FILE                    | 允许使用select...into outfile和load data infile              |
| GRANT OPTION            | 允许授予权限                                                 |
| INDEX                   | 允许使用create index和drop index                             |
| INSERT                  | 允许使用insert                                               |
| LOCK TABLES             | 允许对您拥有select权限的表使用lock tables                    |
| PROCESS                 | 允许使用show full processlist                                |
| PROXY                   |                                                              |
| REFERENCES              | 未被实施                                                     |
| RELOAD                  | 允许使用flush                                                |
| REPLICATION CLIENT      | 允许用户询问从属服务器或主服务器的地址                       |
| REPLICATION SLAVE       | 用于复制型从属服务器（从主服务器中读取二进制日志事件）       |
| SELECT                  | 允许使用select                                               |
| SHOW DATABASES          | show databases显示所有数据库                                 |
| SHOW VIEW               | 允许使用show create view                                     |
| SHUTDOWN                | 允许使用mysqlasmin shutdown                                  |
| SUPER                   | 允许使用change master,kill,purge master logs和set global语句，mysqladmin debug命令，允许您连接（一次），即使已达到max_connections |
| TRIGGER                 |                                                              |
| UPDATE                  | 允许使用update                                               |
| USAGE                   | “无权限”的同义词                                             |

**给用户授权** 基本语法：

`grant 权限列表 on 库.对象名 to '用户名'@'登录位置' [identified by '密码'];`

说明：

1. 权限列表，多个权限用逗号分开

   `grant select on...`

   `grant select,delete,create on ...`

   `grant all [privileges] on ...`

2. 特别说明
   \*.\*：代表本系统重的所有数据库的所有对象（表，视图，存储过程）
   库.\*：表示某个数据库中的所有数据对象(表，视图，存储过程等)

3. identified by 可以省略，也可以写出。

   - 如果用户存在，就是修改该用户的密码。
   - 如果该用户不存在，就是创建该用户

**回收用户授权**

基本语法：`revoke 权限列表 on 库.对象名 from '用户名'@'登录位置';`

**权限生效指令**
基本语法：`flush privileges;`

mysql管理的细节：

1. 在创建用户的时候，如果不指定host，则为%，%表示所有ip都有连接权限`create user XXX;`
2. 你也可以这样指定`create user 'XXX'@'192.168.1.%'`表示XXX用户在192.168.1.*的ip可以登录mysql
3. 在删除用户的时候，如果host不是%，需要明确指定`'用户'@'host值'`

## JDBC和连接池

JDBC为了访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题。java程序员使用jdbc，可以连接任何提供了jdbc驱动程序的数据库系统，完成对数据库的各种操作。

JDBC API是一系列的接口，它统一和规范了应用程序与数据库的连接、执行sql语句，并得到返回结果等各类操作，相关类和接口在java.sql与javax.sql包中。

JDBC程序编写步骤

1. 注册驱动 - 加载Driver类
2. 获取连接 - 得到Connection
3. 执行增删改查 - 发送SQl给mysql执行
4. 释放资源

### 获取数据连接的方式

**方式1**：手动实例化mysql驱动类

```java
// 1.获取Driver实现类对象
Driver driver = new com.mysql.jdbc.Driver();
//2. 得到连接
String url = "jdbc:mysql://localhost:3306/xgzhongyuan";
// jdbc:mysql://是固定的协议通过jdbc方式连接mysql，
// localhost是数据库的主机地址还可以是ip，3306是数据库的端口号，
// xgzhongyuan是数据库的名称
// mysql的连接本质就是前面学过的socket连接
Properties properties = new Properties();
// 将用户名和密码放入properties对象中
properties.setProperty("user","root"); // 用户
properties.setProperty("password","123456"); // 密码
Connection connect = driver.connect(url, properties); // 连接数据库
```

**方式2**：通过反射动态获取mysql驱动实现类

```java
// 使用class类动态获取mysql驱动
Class<?> aClass = Class.forName("com.mysql.jdbc.Driver");
// 通过newInstance()反射driver实现类
Driver driver = (Driver) aClass.newInstance();
String url = "jdbc:mysql://localhost:3306/xgzhongyuan";
Properties properties = new Properties();
properties.setProperty("user","root"); // 用户
properties.setProperty("password","123456"); // 密码
Connection connect = driver.connect(url, properties); // 连接数据库
```

**方式3**：使用DriverManager替代Diver进行统一管理

```java
// 使用class类动态获取mysql驱动
Class<?> aClass = Class.forName("com.mysql.jdbc.Driver");
// 通过newInstance()反射driver实现类
Driver driver = (Driver) aClass.newInstance();
String url = "jdbc:mysql://localhost:3306/xgzhongyuan";
String user = "root"; // 用户
String password = "123456"; // 密码
DriverManager.registerDriver(driver);//注册Driver驱动
Connection connect = DriverManager.getConnection(url,user,password);// 连接数据库
```

**方式4**：使用class.forName自动完成注册驱动，简化代码（这种方法是使用最多的）

```java
// 使用反射加载Driver类
//在加载Driver类时，Driver类的静态代码块已经完成了DriverManager注册
/*
static {
        try {
            DriverManager.registerDriver(new Driver());
        } catch (SQLException var1) {
            throw new RuntimeException("Can't register driver!");
        }
    }
*/
Class.forName("com.mysql.jdbc.Driver");
String url = "jdbc:mysql://localhost:3306/xgzhongyuan";
String user = "root"; // 用户
String password = "123456"; // 密码
Connection connect = DriverManager.getConnection(url,user,password);// 连接数据库
```

小提示：1.mysql驱动5.1.6可以无需`Class.forName("com.mysql.jdbc.Driver");`

2.从jdk1.5以后使用了jdbc4，不再需要显示调用Class.forName()注册驱动而是自动调用驱动jar包下META-INF\services\java.sql.Driver文本中的类名称去注册

3.建议还是写上，更加明确

**方式5**：在方式4的基础上改进,增加配置文件，让连接mysql更加灵活

```java
// 创建配置文件，mysql.properties
username=root
password=123456
url=jdbc:mysql://localhost:3306/test
driver=com.mysql.jdbc.Driver
    
public void connect() throws IOException {
        Properties properties = new Properties();
        // 加载properites配置文件
        properties.load(new FileInputStream("mysql.properties"));
        String url = properties.getProperty("url");
        String username = properties.getProperty("username");
        String password = properties.getProperty("password");
        String driver = properties.getProperty("driver");
        try {
            Class.forName(driver); //建议写上更明确
            Connection connection = DriverManager.getConnection(url, username, password); // 注册驱动
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
```



### ResultSet结果集

1. 表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。
2. ResultSet对象保持一个光标指向其当前的数据行。最初，光标位于第一行之前
3. next方法将光标移动到下一行，并且由于在ResultSet对象中没有更多行时返回false，因此可以再while循环中来遍历结果集。

```java
Properties properties = new Properties();
properties.load(new FileInputStream("mysqlTest\\src\\mysql.properties"));
String url = properties.getProperty("url");
String username = properties.getProperty("username");
String password = properties.getProperty("password");
String driver = properties.getProperty("driver");
Class.forName(driver);
Connection connection = DriverManager.getConnection(url, username, password); // 注册驱动
Statement statement = connection.createStatement();
String sql = "select * from common";
ResultSet resultSet = statement.executeQuery(sql); //查询使用executeQuery(),DML语句使用executeUpdate()
while (resultSet.next()) {  //循环读取结果集数据
    //resultSet.getString("2") 如果是数字则表示第二列的数据
    System.out.println(resultSet.getString("title")); //字符表示获取字段为title的数据
}
resultSet.close(); // 关闭结果集
statement.close(); // 关闭执行语句
connection.close(); // 关闭连接
```

### Statement

1. Statement对象用于执行静态sql语句并返回其生成的结果的对象
2. 在连接建立后，需要对数据库进行访问，执行命令或者sql语句，可以通过Statement、PreparedStatement[预处理]、CallableStatement[存储过程]
3. Statement对象执行sql语句，存在sql注入风险
4. Sql注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的Sql语句段或命令，恶意攻击数据库。
5. 要防范Sql注入，只要用preparedStatement（从Statement扩展而来）取代Statement就可以了

**preparedStatement** 预处理查询

preparedStatement执行的sql语句中的参数用问号(?)来表示，调用preparedStatement对象的setXXX()方法来设置这些参数。setXXX(int,type)方法有两个参数，第一个参数是要设置的sql语句中的参数的索引(从1开始)，第二个是设置的Sql语句中的参数的值

调用executeQuery(),返回ResultSet对象

调用executeUpdate()：执行更新，包括增，删，修改

execute()：执行任意的sql，返回布尔值

预处理好处：

1. 不再使用+拼接sql语句，减少语法错误
2. 有效的解决了sql注入问题
3. 大大减少了编译次数，效率较高

```java
// 模拟preparedStatement执行sql

Scanner scanner = new Scanner(System.in);
System.out.print("请输入管理员账号：");
String admin_name=scanner.nextLine();
System.out.print("请输入管理员密码：");
String pass=scanner.nextLine();

Properties properties = new Properties();
properties.load(new FileInputStream("mysqlTest\\src\\mysql.properties"));
String url = properties.getProperty("url");
String username = properties.getProperty("username");
String password = properties.getProperty("password");
String driver = properties.getProperty("driver");
Class.forName(driver);
Connection connection = DriverManager.getConnection(url, username, password); // 注册驱动
String sqlstr = "select * from admin where name=? and pass=?";//组织Sql语句
// PreparedStatement对象实现了PreparedStatement接口的实现类的对象，生成预处理对象
PreparedStatement preparedstatement = connection.preparedStatement(sqlstr);
preparedStatement.setString(1,admin_name); // 1表示sql语句中的第一个问号
preparedStatement.setString(2,pass);  // 2表示sql语句中的第2个问号
ResultSet resultSet = preparedstatement.executeQuery(); //执行查询，不需要再传入sqlstr参数，因为上面已经预处理了
while (resultSet.next()) {  //循环读取结果集数据
    //resultSet.getString("2") 如果是数字则表示第二列的数据
    System.out.println(resultSet.getString("title")); //字符表示获取字段为title的数据
}
resultSet.close(); // 关闭结果集
preparedstatement.close(); // 关闭执行语句
connection.close(); // 关闭连接
```

### 封装JDBCUtils

在jdbc操作红，获取连接和释放资源的经常使用到，可以将其封装jdbc链接的工具类JDBCUtils。

```java
package JDBCUtils;

import java.io.FileInputStream;
import java.sql.*;
import java.util.Properties;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2025/12/5 9:43
 */
public class JDBCUtils {
    // 数据库连接信息,因为只需要读取一次,所以设置为静态变量
    public static String url;
    public static String user ;
    public static String password ;
    public static String driver ;

    static {
        try {
            Properties properties = new Properties();
            properties.load(new FileInputStream("mysqlTest\\src\\mysql.properties"));
            url = properties.getProperty("url");
            user = properties.getProperty("username");
            password = properties.getProperty("password");
            driver = properties.getProperty("driver");
            Class.forName(driver);

        } catch (Exception e) {
            // 在实际开发中，我们可以这样处理
            //1.将编译异常转成运行时异常
            //2.这时调用者，可以选择捕获异常，也可以选择默认处理该异常，比较方便
            throw new RuntimeException(e);
        }
    }

    public static Connection getConnection() {
        try {
            // 返回数据库连接对象
           return DriverManager.getConnection(url, user, password); // 注册驱动
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    // 关闭数据库连接
    /**
     * 关闭数据库连接 需要关闭的对象可能有 1. ResultSet 2. PreparedStatement 或者 Statement 3. Connection
     * @param set 数据集对象,如果没有数据集对象或数据不需要关闭则传入null
     * @param connection 数据库连接对象
     * @param statement 数据库操作对象
     */
    public static void close(ResultSet set, Statement statement,Connection connection) {
        if (set != null) {
            try {
                set.close();
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }
        if (statement != null) {
            try {
                statement.close();
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }
        if (connection != null) {
            try {
                connection.close();
            } catch (SQLException e) {
                throw new RuntimeException(e);
            }
        }

    }
}

```

使用JDBCUtils工具类

```java
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import JDBCUtils.JDBCUtils;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2025/12/5 10:36
 */
public class JDBCUtils_use {

    @SuppressWarnings({"all"})
    public static void main(String[] args) {
        Connection connection = null;
        PreparedStatement statement = null;
        ResultSet set = null;
        try {
            // 获取mysql连接
            connection = JDBCUtils.getConnection();
            // 组织sql语句
            String sql = "select * from common where title like ?";
            // 预处理sql
            statement = connection.prepareStatement(sql);
            // 替换sql语句中的参数
            statement.setString(1, "%孝感%");
            // 执行sql语句，返回结果集
            set = statement.executeQuery();
            while (set.next()) {
                System.out.println(set.getString("title"));
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            // 释放资源
            JDBCUtils.close(set, statement, connection);
        }
    }
}

```

### 事务

JDBC程序中当一个Connection对象创建时，默认情况下是自动提交事务，每次执行一个sql语句时，如果执行成功，就会想数据库自动提交，而不能回滚。

JDBC程序中为了让多个SQL语句作为一个整体执行，需要使用**事务**

调用Connection的setAutoCommit(false)可以取消自动提交事务

在所有的SQL语句都成功执行后，调用Connection的commit();方法提交事务

在其中某个操作失败或出现异常是，调用Connection的rollback();方法回滚事务

```java
connection = JDBCUtils.getConnection(); // 得到mysql连接
// 将connection设置为手动提交
connection.setAutoCommit(false); //开启了事务
try{
    PreparedStatement ps = connection.preparedStatement(sql);
    ps.executeUpdate(); //执行sql语句1
    ps = connection.preparedStatement(sql2);
    ps.executeUpdate(); //执行sql语句2
    connection.commit();//提交事务
}catch(SQLException e){
    //发生异常，数据回滚
    connection.rollback();
}
```



### 批处理

当需要成批插入或者更新记录时，可以采用java的批量更新机制，这一机制允许多语句一次性提交给数据库处理。通常情况下比单独提交处理更有效率。

JDBC的批量处理语句包括下面方法：

addBatch()：添加需要批量处理的SQl语句或参数

executeBatch()：执行批量处理语句

clearBatch()：清空批处理包的语句

JDBC连接mysql时，如果要使用批处理功能柜，请在url中加参数？**rewriteBatchedSattement=true**

批处理往往和PreparedStatement一起搭配使用，可以既减少编译次数，又减少运行次数，效率大大提高。

```java
// 批处理案例
public void batch(){
    Connection connection = JDBCUtils.getConnection();
    String sql = "insert into admin values(null,?,?)";
    PreparedStatement ps = connection.preparedStatement(sql);
    for(int i =0;i<5000;i++){
        ps.setString(1,"jack"+i);
        ps.setString(2,"888");
        //sql 语句加入到批处理包中
        ps.addBatch();
        //当有1000条记录时，执行一次批处理
        if((i+1)%1000==0){
            ps.executeBatch(); //执行批处理命令
            ps.clearBatch(); //清空批处理命令，加入新的sql语句
        }
    }
    JDBCUtils.close(null,ps,connection);
}
```



### 数据库连接池

传统的JDBC数据库连接使用DriverManager来获取，每次向数据库建立连接的时候都要将Connection加载到内存中，再验证ip地址，用户名和密码（0.05~1s时间）。需要数据库连接的时候，想向数据库要求一个，频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃。

每一次数据连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄露，最终将导致重启数据库。

传统获取连接的方式，不能控制创建的连接数量，如连接过多，也可能导致内存泄露，mysql崩溃。

解决传统开发中的数据库连接问题，可以采用数据库连接池技术（Connection pool）。

**数据库连接池基本介绍**

预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。

数据库连接池负责分配，管理和释放数据库连接，它允许应用程序**重复使用**一个现有的数据库连接，而不是重新建立一个。

当应用程序想连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中

**数据库连接池种类**

1. JDBC的数据库连接池使用javax.sql.DataSource来表示，DataSource只是一个接口，该接口通常由第三方提供实现
2. **C3P0**数据库连接池，速度相对较慢，稳定性不错（hibernate，spring）
3. DBCP数据库连接池，速度相对c3p0较快，但不稳定
4. Proxool数据库连接池，有监控连接池状态的功能，稳定性较c3p0差一点
5. BoneCP数据库连接池，速度快
6. **Druid**（德鲁伊）是阿里提供的数据库连接池，集DBCP，C3P0，Proxool优点于一身的数据库连接池

```java
//使用Druid升级JBDCUtils数据库连接工具
package JDBCUtils;
import com.alibaba.druid.pool.DruidDataSourceFactory;

import javax.sql.DataSource;
import java.io.FileInputStream;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2025/12/8 10:05
 * @description: 数据库连接池工具类，使用Druid连接池
 */
public class JDBCUtilsByDruid {
    private static DataSource ds;
    static {
        Properties properties = new Properties();
        try {
            properties.load(new FileInputStream("mysqlTest\\src\\druid.properties"));
            ds = DruidDataSourceFactory.createDataSource(properties);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    // 获取连接池对象
    public static Connection getConnection() throws SQLException {
        return ds.getConnection();
    }

    // 关闭连接池,在数据库连接池技术中，关闭连接并不是真正的断开了数据库的连接，
    // 而是将连接对象回收至连接池，等待下一次使用。
    public static void close(ResultSet rs, Statement st, Connection conn) {
        try {
            if(rs != null){
               rs.close();
            }
            if(st != null){
                st.close();
            }
            if (conn != null) {
               conn.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}

```

### Apache-DBUtils

commons-dbutils是apache组织提供的一个开源JDBC工具类库，它是对JDBC的封装，使用dbutils能极大简化jdbc编码的工作量。

DbUtils类

1. QueryRunner类：该类封装了SQL的执行，是线程安全的。可以实现增、删、改、查、批处理
2. 使用QueryRunner类实现查询
3. ResultSetHandler接口：该接口用于处理java.sql.ResultSet，将数据按要求转换成另一种形式。

```java
ArrayHandler: 把结果集中的第一行数据转成对象数组。
ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。
BeanHandler：将结果集中的第一行数据封装到一个对应的javaBean实例中。
BeanListHandler：将结果集中的每一行数据封装到一个对应的javaBean实例中，存放到list里
ColumnListHandler：将结果集中某一列的数据存放到list中
KeyedHandler(name)：将结果集中的每行数据都封装到Map里，再把这些map存到一个map里，其key为指定的key。
MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。
MapListHandler：将结果集中的每一行数据都封装到一个map里，暗黑再存放到list
```

### BasicDAO

DAO：data access Object 数据访问对象

BasicDao是专门和数据库交互的，即完成对数据库（表）的crud操作，在basicdao的基础上，实现一张表对应一个dao，更好的完成功能，比如:Customer表--Customer.java类（javabean）--CustomerDao.java

```java
import JDBCUtils.JDBCUtilsByDruid;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2025/12/8 15:20
 * 开发BasicDao，是其他Dao的父类，使用apache-dbutils工具类
 */
public class BasicDao<T> {
    // <T> 表示泛型,可以代表任意类型
    private QueryRunner qr = new QueryRunner();

    // DML操作（增删改）
    public int update(String sql, Object... params) {
        Connection connection = null;
        try {
            connection = JDBCUtilsByDruid.getConnection();
            int row = qr.update(connection, sql, params);
            return row;
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }finally {
            JDBCUtilsByDruid.close(null, null, connection);
        }
    }

    // 返回多行结果集（查询）
    public List<T> queryMulti(String sql, Class<T> clazz, Object... params) {
        Connection connection = null;
        try {
            connection = JDBCUtilsByDruid.getConnection();
            return qr.query(connection, sql, new BeanListHandler<T>(clazz), params);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }finally {
            JDBCUtilsByDruid.close(null, null, connection);
        }
    }

    // 返回单行结果集（查询）
    public T querySingle(String sql, Class<T> clazz, Object... params) {
        Connection connection = null;
        try {
            connection = JDBCUtilsByDruid.getConnection();
            return qr.query(connection, sql, new BeanHandler<T>(clazz), params);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }finally {
            JDBCUtilsByDruid.close(null, null, connection);
        }
    }

    // 返回单列结果集（查询）
    public Object queryScalar(String sql, Object... params) {
        Connection connection = null;
        try {
            connection = JDBCUtilsByDruid.getConnection();
            return qr.query(connection, sql, new ScalarHandler<>(), params);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }finally {
            JDBCUtilsByDruid.close(null, null, connection);
        }
    }
}

```

## Mybatis

MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java **POJO**（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。

JDBC查询数据库的缺点：1.硬编码 （注册驱动，获取链接，sql语句）2.操作繁琐（设置sql语句参数，手动封装结构集）

### Mapper代理开发

目的：解决原生方式中的硬编码，简化后期执行sql

mapper代理方式的规则：

1. 定义与sql映射文件同名的Mapper接口，并将Mapper接口和SQL映射文件放置在同一目录下
2. 设置sql映射文件的namespace属性为Mapper接口全限定名
3. 在Mapper接口中定义方法，方法名就是sql映射文件中sql语句的id，并保持参数类型和返回值类型一致
4. 查询代码变成mapper代理（1.通过SqlSession的getMapper方法获取Mapper接口的代理对象 2. 调用对应方法完成sql的执行）

细节：如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化Sql映射文件的加载。

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!--环境配置-->
    <environments default="development">
        <!--开发环境配置，可以配置多个数据库，通过修改default属性来切换数据库-->
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <!--                数据库连接信息-->
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/myyunmengfayuan?useSSL=false&amp;serverTimezone=Asia/Shanghai"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
<!--正常方式加载sql映射文件-->
<!--        <mapper resource="net/dpwl/mapper/UserMapper.xml"/>-->
<!--        mapper代理方法，可以使用包扫描，来简化配置，自动加载包路径下所有的sql映射文件-->
            <package name="net.dpwl.mapper"/>
    </mappers>
</configuration>
```



### MyBatis核心配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <typeAliases>
<!--        为net.dpwl.pojo包下的所有类设置别名，别名就是类名，不区分大小写,这样mapper映射文件的返回类型就可以简化了-->
        <package name="net.dpwl.pojo"/>
    </typeAliases>
    <environments default="development">
<!--开发环境配置，可以配置多个数据库，通过修改default属性来切换数据库-->
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
<!--                数据库连接信息-->
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/myyunmengfayuan?useSSL=false&amp;serverTimezone=Asia/Shanghai"/>
                <property name="username" value="root"/>
                <property name="password" value="123456"/>
            </dataSource>
        </environment>
        <environment id="test">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/myyunmengfayuan?useSSL=false&amp;serverTimezone=Asia/Shanghai"/>
                <property name="username" value="root"/>
                <property name="password" value="H3u94c94kod0UjGuNmkfmqw0JMJRMF"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
<!--        加载sql映射文件-->
<!--        <mapper resource="net/dpwl/mapper/UserMapper.xml"/>-->
<!--        mapper代理方法，可以使用包扫描，来简化配置，自动加载包路径下所有的sql映射文件-->
            <package name="net.dpwl.mapper"/>
    </mappers>
</configuration>
```



细节：配置各个标签是，需要遵守前后顺序，顺序如下：

- configuration（配置）
  - [properties（属性）](https://mybatis.p2hp.com/configuration.html#properties)
  - [settings（设置）](https://mybatis.p2hp.com/configuration.html#settings)
  - [typeAliases（类型别名）](https://mybatis.p2hp.com/configuration.html#typeAliases)
  - [typeHandlers（类型处理器）](https://mybatis.p2hp.com/configuration.html#typeHandlers)
  - [objectFactory（对象工厂）](https://mybatis.p2hp.com/configuration.html#objectFactory)
  - [plugins（插件）](https://mybatis.p2hp.com/configuration.html#plugins)
  - environments（环境配置）
    - environment（环境变量）
      - transactionManager（事务管理器）
      - dataSource（数据源）
  - [databaseIdProvider（数据库厂商标识）](https://mybatis.p2hp.com/configuration.html#databaseIdProvider)
  - [mappers（映射器）](https://mybatis.p2hp.com/configuration.html#mappers)

### 配置文件完成增删改查

mybatisX插件，可以快速完成xml和pojo类的对应和跳转。

mybatis完成增删改查的步骤：

1.编写Mapper接口方法：Mapper接口 参数：id  返回结果集：User
2.编写SQL语句：XML配置文件中 SQL映射
3.执行方法，测试

数据库表的字段名称和实体类的属性名称不一样，则不能自动封装数据需要手动处理，方法有两种：

1. 查询数据库字段起别名，别名和实体类的属性一致（缺点：每次查询都要定义一次别名,可以使用sql片段处理）
2. resultMap映射（定义resultMap标签，在<select>标签中，用resultMap替换resultType）

```xml
<!--定义sql片段，sql片段可以在查询中直接引用，避免相同内容重复写-->
<sql id="user_column">
    id，brand_name as brandName,company_name as companyName,carid,state
</sql>
<!--resultMap映射-->
<resultMap id="userResultMap" type="user">
<!--id是映射的唯一标识，type是和那个实体类映射-->
    <id column="id" property="userid"></id><!--id是主键字段映射column是数据库字段，property是实体类属性-->
    <result column="company_name" property="companyName"></result><!--resultMap是普通字段映射column是数据库字段，property是实体类属性-->
</resultMap>
<!--如果使用resultMap映射需要把reslutType改成resultMap其值为resultMap的id-->
<select id="selectAll" resultType="user">
    select
    <include refid="user_column" /> <!--引入片段-->
    from dp_user;
</select>
<select id="selectByid" parameterType="int" resultType="user">
    select
    <include refid="user_column" /> <!--引入片段-->
    from dp_user where id = #{id};
</select>

```

mybatis的xml中参数占位符：

1. #{}：会将其替换成？，为了防止sql注入
2. ${}：直接拼sql，会存在sql注入

两个占位符的使用时机，1.当用户传入的参数时一律使用#{},2.当我们需要动态查询不同的table或字段时，可以使用${}来动态拼接sql

参数类型：parameterType：可以省略

特殊字符处理：l例如：< 是xml的标签开始标记所以在sql语句中直接使用小于号`<`是会报错的。解决办法：

1. 转义字符：`<`使用对应的转码字符`&lt;`
2. CDATA区: 把特殊字符用`<![CDATA[ < ]]`括起来使用

多条件查询参数传递

1. 散装参数：如果方法中有多个参数，需要使用@param("SQL参数占位符名称")

   ```java
   //UserMapper.java
   interface UserMapper {
   	List<User> selectAllUserByCondition(@Param("yz")int yz,@Param("name")String name,@Param("sex")int sex);  
       //@param()中的名称要和mapper.xml中的参数名称一一对应，即把int yz变量的值传入到xml中和@param对应的变量名
   }
   ```

   

2. 对象参数：对象的属性名称要和sql参数占位符一致

   ```java
   //UserMapper.java
   interface UserMapper {
   	List<User> selectByCondition(User user);
       // 传入一个User对象，user对象的属性和sql条件的名称一致
   }
   User user = new User();
   user.setYz(yz);
   user.setName(name);
   user.setSex(sex);
   List<User> list = userMapper.selectByCondition(user);
   ```

   

3. map集合参数：map的键名和sql参数占位符名称一致

   ```java
   //UserMapper.java
   interface UserMapper {
   	List<User> selectByCondition(Map map);
       // 传入一个Map集合，map中的键和sql条件的名称一致
   }
   Map map = new HashMap();
   map.put("yz",yz);
   map.put("name",name);
   map.put("sex",sex);
   List<User> list = userMapper.selectByCondition(map);
   ```

   

### 注解完成增删改查

使用注解开发会比配置文件开发更加方便

```java
@Select("select * from dp_user where id = #{id}")
public User selectById(int id);
```

- 查询注解：@Select
- 添加注解：@Insert
- 修改注解：@Update
- 删除注解：@Delete

提示：注解完成简单功能，配置文件完成复杂功能



### 动态SQL

多条件查询时如何随着用户的输入或外部条件的变化而变化，我们称为动态SQL。

Mybaits对动态sql有很强大的支撑：

- if

  ```xml
  <where>
      <!--if标签，test内写入逻辑表达式-->
      <if test="yz != null">
          yz = #{yz}
      </if>
      <!--xml中多添加不能用&&符号，只能用and 或者 or -->
      <if test="name != null and name ！= ‘’ ">
          and name = '%' #{name} '%'
      </if>
  </where>
  ```

  存在的问题，当第一个条件的逻辑运算为false时，第一个条件就不存在了，后面的条件就多出了一个and。

  解决方法： 

  1. 使用恒等式让所有条件格式都一样
  1. 使用<where>标签替换SQl语句中的where关键字，包住所有的<if>标签

- choose（when，otherwise）
  单条件的动态查询

  ```xml
  <select id="findActiveBlogLike" resultType="Blog">
    SELECT * FROM BLOG WHERE 
    <choose><!--相当于switch-->
      <when test="title != null">
         title like #{title}
      </when>
      <when test="author != null and author.name != null">
         author_name like #{author.name}
      </when>
      <otherwise> <!--相当于default，当其他的条件都不成立时，这个条件生效，防止sql语句where后无条件，也可以不要这个标签，把sql中的where关键字换成<where>标签包裹住<choose>标签-->
        1 = 1
      </otherwise>
    </choose>
  </select>
  ```

  

- trim（where，set）
  set可以对update语句进行动态查询

  ```xml
  <update id="updateUser" parameterType="User">
      update dp_user
      <set>
          <if test="nickname !=null and nickname !=''">
              nickname=#{nickname},
          </if>
          <if test="sex !=null ">
              sex=#{sex},
          </if>
          <if test="headimg !=null and headimg !=''">
              headimg=#{headimg},
          </if>
          <if test="name !=null and name !=''">
              name=#{name},
          </if>
          <if test="tel !=null and tel !=''">
              tel=#{tel},
          </if>
          <if test="adr !=null and adr !=''">
              adr=#{adr}
          </if>
      </set>
      where
      id=#{id}
  </update>
  ```

  

- foreach

  ```xml
  <!--
      mybatis会将数组参数，封装成一个Map集合
      *默认：array = 数组
      * 使用@param注解改变map集合的默认key的名称
      separator 分隔符
  	open 循环开始前拼接的字符串
  	close 循环结束后拼接的字符串
      -->
  <delete id="deleteByIds">
      delete form dp_user where id in 
      <foreach collection="ids" item="id" separator="," open="(" close=")">
          #{id}
      </foreach>
      ;
  </delete>
  ```

  

当添加,修改，删除数据库时，`SqlSession sqlSession = sqlSessionFactory.openSession();`默认jdbc是开启事务的，所以需要手动提交事务`sqlSession.commit();`或直接设置事务自动提交`SqlSession sqlSession = sqlSessionFactory.openSession(true); //设置自动提交`

```xml
在insert语句中设置useGeneratedKeys=“true” 和 keyProperty=“主键名”可以获取添加后的主键返回
<insert id="addUser" parameterType="User" useGeneratedKeys="true" keyProperty="id">
insert into dp_user (openid,nickname, sex, headimg, name, tel,adr,logintime,yz) values (#{openid}, #{nickname}, #{sex}, #{headimg}, #{name},#{tel},#{adr},#{logintime},#{yz})
</insert>
```

参考文档：https://mybatis.p2hp.com/dynamic-sql.html

### MyBatis参数传递

myBatis参数封装：

- 单个参数：

  1. Pojo类型：直接使用，属性名 和 参数占位符名称 一致

  2. Map集合：直接使用，键名 和 参数占位符名称 一致

  3. Collection：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名
     map.put("arg0",Collection集合);
     map.put("collection",Collection集合);

  4. List：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名

     map.put("arg0",List集合);
     map.put("collection",List集合);
     map.put("list",List集合);

  5. Array：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名
     map.put("arg0",数组);
     map.put("array",数组);

  6. 其他类型：比如int，String 直接使用

- 多个参数：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名

  默认参数：

  map.put("arg0",参数值1);

  map.put("Param1",参数值1);

  map.put("arg1",参数值2);

  map.put("Param2",参数值2);

## Mybaits-Plus

使用MybaitsPlus的基本步骤：

1. 引入mybatisPlus依赖，代替Mybaits依赖

```xml
<!--mybatis-plus依赖-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus</artifactId>
    <version>3.5.15</version>
</dependency>
```

2. 定义Mapper接口并继承BaseMapper

   ```java
   public interface UserMapper extends BaseMapper<User> {}
   ```

### 常见注解

MybaitsPlus通过扫描实体类，并基于反射获取实体类信息作为数据库表信息。约定通过命名获取对应的表信息。

- 类名驼峰转下划线作为表名：比如User对应的表就是user，UserInfo对应的是user_info表
- 名为id的字段作为主键
- 变量名驼峰转下划线作为表的字段名

如果命名和表信息不对应，就需要用下面的注解指定：

- @TableName：用来指定表名

- @TableId：用来指定表中的主键字段信息

  ```java
  @TableName("tb_user")
  public class User{
      // @TableId(value="id",type=IdType.AUTO) IdType枚举：AUTO（数据库自增长），INPUT（通过set方法自行输入），ASSIGN_ID（分配id，接口identifierGenerator的方法nextid来生成id，默认实现类为DefaultIdentifierGenerator雪花算法）
      @TableId("id")
      private int carid;
      @TableField("username")  // 成员变量名和数据库字段名不一致需要注解
      private String name;
      @TableField("is_married")  // 成员变量名以is开头，并且是布尔值的默认会去掉is即married，所以也需要注解
      private Boolean isMarried;
      @TableField("`order`")  // 成员变量名和数据库关键字冲突也需要注解
      private Integer order;
      @TableField(exist=false) //成员变量名在数据库中不存在该字段需要用注解排除
      private String address；
  }
  ```

- @TableField：用来指定表中的普通字段信息

### 常见配置

MybaitsPlus的配置项继承了Mybaits原生配置和一些自己特有的配置，在application.yml中根据需要添加配置。如下

![QQ20251230-165244](.\img\QQ20251230-165244.png)

### 条件构造器

使用wrapper构造查询条件，不需要使用mapper.xml配置简化操作

```java
public class TestUserMapper {
    @Test
    void testQueryWrapper(){
        // 1.构建查询条件
        QueryWrapper<User> wrapper = new QueryWrapper<User>()
            .select("id","name","info","balance")
            .like("name","o")
            .ge("blance",1000);
        // 2.查询
        List<User> users = userMapper.selectList(wrapper);
        users.forEach(System.out::println);
    }
    // 使用lambda语法,可以解决硬编码问题
    @Test
    void testLambdaQueryWrapper(){
        // 1.构建查询条件
        LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<User>()
            .select(User::getId,User::getName,User::getInfo,User::getBalance)
            .like(User::getName,"o")
            .ge(User::getBlance,1000);
        // 2.查询
        List<User> users = userMapper.selectList(wrapper);
        users.forEach(System.out::println);
    }
    @Test
    void testUpdateByQueryWrapper(){
        // 1.要更新的数据
        User user =new User();
        user.setBalance(2000);
        // 2.更新的条件
        QueryWrapper<User> wrapper = new QueryWrapper<User>("username","jack");
        // 3.执行更新
        userMapper.update(user,wrapper);
    }
    @Test
    void testUpdateWrapper(){
        List<int> ids = List.of(1,2,4);
        // 1.更新的条件
        UpdateWrapper<User> wrapper = new UpdateWrapper<User>().setSql("balance = balance - 200").in("id",ids);
        // 2.执行更新
        userMapper.update(null,wrapper);
    }
    
}
```

条件构造器的用法：

- QueryWrapper和LambdaQueryWrapper通常用来构建select，delete，update的where条件部分
- UpdateWrapper和LambdaUpdateWrapper通常只有在set语句比较特殊才实用
- 尽量使用LambdaQueryWrapper和LambdaUpdateWrapper，避免硬编码

### 自定义SQL

我们可以利用MybaitsPlus的Wrapper来构建复制的where条件，软化自己定义sql语句中剩下的部分。

1. 基于wrapper构建where条件

   ```java
   List<int> ids = List.of(1,2,4);
   int amount = 200;
   // 1.构造条件
   LambdaQueryWrapper<User> wrapper = new LambdaQueryWrapper<User>().in(User::getId,ids);
   // 2.自定义sql方法调用
   userMapper.updateBalanceByIds(wrapper,amount);
   ```

   

2. 在mapper方法参数中用Param注解声明wrapper变量名称，必须是ew

   ```java
   void updateBalanceByIds(@Param("ew") LambdaQueryWrapper<User> wrapper,@Param("amount") int amout); 
   ```

3. 自定义sql，并使用wrapper条件

   ```xml
   <update id="updateBalanceByIds">
   	UPDATA dp_user SET balance = balance - #{amount} ${ew.customSqlsegment}
   </update>
   ```

### Service接口

mp的service接口使用流程：

1. 自定义Service接口继承IService接口

   ```java
   public interface UserService extends IService<User> {}
   ```

2. 自定义Service实现类，实现自定义接口并继承ServiceImpl类

   ```java
   public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {}
   ```

   案例，使用lambda语法查询用户判断余额并扣除余额，如果余额扣完则更改用户状态
   
   ```java
   @Override
   @Transactional  //事务注解
   public void deductBalance(Integer id,Integer money){
       // 1. 查询用户
       User user = getById(id);
       // 2. 校验用户状态
       if(user == null || user.getStatus() == 2){
           throw new RuntimeException("用户状态异常");
       }
       // 3. 校验用户余额
       if(user.getBalance() < money){
           throw new RuntimeException("用户余额不足！");
       }
       // 4. 扣除余额 update tb_user set balance = balance -?
       int remainBalance = user.getBalance - money;
       lambdaUpdate().set(User::getBalance,remainBalance).set(remainBalance == 0, User::getStatus,2).eq(User::getId,id).eq(User::getBalance,user.getBalance()) //乐观锁，判断当前余额和查询的余额是否相等，不相等就不修改
           .update(); //前面是构建sql语句，update才是执行，所以不能缺省
   }
   ```

IService批量新增

批量for循环插入10万条大概需要4分钟

IService的批量插入 基于预编译的批处理，性能不错  减少大量网络请求大概需要20秒

开启mysql连接参数`rewriteBatchedStatements=true`，mysql批处理 （插入语句拼接成一条语句） 大概需要6秒

### MP的扩展功能

1. mybatispulus插件可以根据数据库信息自动生成表对应的实体类，service，Controller等通用的内容，减少工作量

2. 静态工具：当需要查询多个表时，按照传统的service注入的方式，很容易出现service相互调用的问题，此时就可以使用静态工具`Db`,避免循环依赖。

   ```java
   public void queryUserAndArticleByIds(List<Integer> ids) {
       // 1.查询用户 使用Service接口的listByIds方法
           List<User> user = listByIds(ids);
           if (CollUtil.isEmpty(users)) {
               //throw new RuntimeException("用户不存在");
               return Collections.emptylist();
           }
        // 2.查询文章
       // 2.1获取用户id集合(通过流，搜集User::getId转成list)
       List<Integer> userIds = users.stream().map(User::getId).collect(Collectors.tolist());
           // 2.2查询相关的文章 使用Db静态方法不需要注入 Article的service依赖
           List<Article> articles = Db.lambdaQuery(Article.class).in(Article::getUid, userIds).list();
       // 2.3 转换文章vo
       List<ArticleVO> articleVOList = BeanUtil.copyToList(articles,ArticleVO.class);
       Map<Integer,List<ArticleVO>> articleMap = new HashMap<>();
       // 健壮性处理，判断articleVOList非空才能转vo，否则会报错
       if(CollUtil.isNotEmpty(articleVOList)){
       //2.4 梳理文章集合（分组），分类整理，相同用户的文章放入一个集合（组）中
       articleMap = articleVOList.stream().collect(Collectors.groupingBy(ArticleVO::getUid));
           }
       // 3.转vo返回
       List<UserVO> list = new ArrayList<>(users.size());
       for(User user: users){
           // 3.1转换user的po为vo
           UserVO vo = BeanUtil.copyProperties(user,UserVO.class);
           list.add(vo);
           // 3.2转换articleVO
           vo.setArticle(articleMap.get(user.getId()));
       }
       return list;
       }
   ```

3. 逻辑删除
   逻辑删除就是基于代码逻辑模拟删除效果，但不会真正的删除数据。思路如下：

   - 在表中添加一个字段标记数据是否被删除
   - 当删除数据时把标记设置为1
   - 查询时只查询标记为0的数据

MybaitsPlus提供了逻辑删除功能，无效改变方法调用的方式，而是在底层帮我们自动修改crud的语句。我们要做的的就是在application.yaml文件中配置逻辑删除的字段名称和值即可。

```yaml
mybatis-plus:
	global-config:
		db-config:
			logic-delete-field:del # 全局逻辑删除的实体字段名，字段类型可以是boolean，integer
			logic-delete-value:1 # 逻辑已删除值（默认为 1）
			logic-not-delete-value:0 # 逻辑未删除值（默认为0）
```

逻辑删除的问题: 1. 会导致数据库表垃圾数据越来越多，影响查询效率 2. SQl中全都需要对逻辑删除字段做判断，影响查询效率。因此，我们不太推挤采用逻辑删除功能，如果数据不能删除，可以采用把数据迁移到其他表的办法。

4. 枚举处理器
   mp枚举处理器使用步骤：1. 创建枚举类 2.设置mybatisplus配置 3.实体类中的数据类型就可以替换成枚举对象了

   ```java
   // 创建用户状态的枚举
   @Getter
   public enum UserStatus{
      NORMAL(1,"正常"),
       FREEZE(2,"冻结");
       
       @EnumValue // 该注解标注枚举中那个字段对应数据库存储的值
       private final int value;
       @JsonValue // 该注解标注枚举类型的数据在前端返回时返回数据项
       private final String desc;
       
       UserStatus(int value,String desc){
           this.value = value;
           this.desc = desc;
       }
   }
   ```

   ```yaml
   mybatis-plus:
   	configuration:
   		default-enum-type-handler: com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler # 设置枚举处理器
   ```

   ```java
   public class User{
       // private int status; 原本int类型的实体属性 就可以换成枚举对象的了
       private UserStatus status;
       // 在后续的service中字段的赋值和比较都可以使用UserStatus.NORMAL 枚举即可。
   }
   ```

5. JSON处理器
   JSON处理器使用：

   ```java
   // 1.创建json数据对应的实体
   @Data
   @noArgsConstructor
   @AllArgsConstructor(staticName="of")
   public class UserInfo{
       private Integer age;
       private String intro;
       private String gender;
   }
   
   // 2.改造User实体类
   @Data
   @TableName(value = "dp_user", autoResultMap = true) // 4.设置自动映射开启
   public class User{
       // private String info; 原本String类型存放json字符串的实体属性 就可以换成对应的json数据实体了
       // 3.注解开启json处理器
       @TableField(typeHandler=JacksonTypeHandler.class)
       private UserInfo info;
   }
   ```

### 插件功能

分页插件

```xml
<!--mybatis plus 3.5.15版本里 Pagination分页拦截器插件被放到这个包里了-->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-jsqlparser</artifactId>
    <version>3.5.12</version>
</dependency>
```

```java
// 1.配置Mybaits plus拦截器
package net.dpwl.webapi.config;

import com.baomidou.mybatisplus.annotation.DbType;
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2026/1/6 14:13
 */
@Configuration
public class MybatisPlusConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        // 1.初始化核心插件
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        // 2.添加分页插件
        PaginationInnerInterceptor pageInterceptor = new PaginationInnerInterceptor(DbType.MYSQL);
        pageInterceptor.setMaxLimit(1000L); //设置分页上限
        // 把分页插件拦截器添加到核心插件
        interceptor.addInnerInterceptor(pageInterceptor);
        return interceptor;
    }
}

// 2.创建page对象，并查询
@Test
void testPageQuery(){
    // 1.前端传递分页参数
    int pageNo = 1,pageSize = 5;
    // page对象，并设置分页参数
    Page<User> page = Page.of(pageNo,pageSize);
    // 排序参数，通过OrderItem来指定，可以设置多个排序
    page.addOrder(new OrderItem("balance",false)); //false 降序
    page.addOrder(new OrderItem("id",true)); // balance 相等时，按照id升级排
    // 分页查询
    Page<User> p = userService.page(page);
    // 总条数
    System.out.println("total= "+p.getTotal());
    // 总页数
    System.out.println("pages= "+p.getPages());
    // 分页数据
    List<User> records = p.getRecords();
}
```

通用分页实体

```java
// 把前端传递的分页数据抽象成一个类
package net.dpwl.webapi.query;

import com.baomidou.mybatisplus.core.metadata.OrderItem;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;
import net.dpwl.webapi.entity.User;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2026/1/6 16:24
 */
@Data
@Schema(description = "分页查询参数实体")
public class PageQuery {
    @Schema(description = "当前页码")
    private Integer pageNum = 1;

    @Schema(description = "每页数量")
    private Integer pageSize = 10;

    @Schema(description = "排序字段")
    private String sortField = "id"; // 默认按id排序

    @Schema(description = "是否升序排序")
    private Boolean isAsc = true;

    public <T> Page<T> toMpPage() {
        Page<T> page = Page.of(pageNum, pageSize);
        // 1.2 排序条件（使用静态工厂方法替代直接new）
        if (isAsc) {
            page.addOrder(OrderItem.asc(sortField));
        } else {
            page.addOrder(OrderItem.desc(sortField));
        }
        return page;
    }
}

// 把po转vo的部分也抽象成一个DTO类
package net.dpwl.webapi.dto;

import cn.hutool.core.bean.BeanUtil;
import cn.hutool.core.collection.CollUtil;
import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;
import net.dpwl.webapi.vo.UserVO;

import java.util.List;
import java.util.function.Function;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2026/1/6 16:30
 */
@Data
@Schema(description = "分页查询结果实体")
public class PageDTO<T> {
    @Schema(description = "总页码")
    private Long pages;

    @Schema(description = "总记录数")
    private Long total;

    @Schema(description = "分页数据")
    private List<T> list;

    public static <PO,VO> PageDTO<VO> of(Page<PO> p, Class<VO> clazz){
        PageDTO<VO> pageDTO = new PageDTO<>();
        pageDTO.setPages(p.getPages());
        pageDTO.setTotal(p.getTotal());
        List<PO> records = p.getRecords();
        if(CollUtil.isEmpty(records)){
            // 判断分页时间是否为空
            pageDTO.setList(List.of());
            return pageDTO;
        }
        pageDTO.setList(BeanUtil.copyToList(records, clazz));
        return pageDTO;
    }
    // 使用函数式接口转换分页数据
    public static <PO,VO> PageDTO<VO> of(Page<PO> p, Function<PO,VO> convertor){
        PageDTO<VO> pageDTO = new PageDTO<>();
        pageDTO.setPages(p.getPages());
        pageDTO.setTotal(p.getTotal());
        List<PO> records = p.getRecords();
        if(CollUtil.isEmpty(records)){
            // 判断分页时间是否为空
            pageDTO.setList(List.of());
            return pageDTO;
        }
        pageDTO.setList(records.stream().map(convertor).toList());
        return pageDTO;
    }
}

// 经过抽象分类后的user Service实现
@Override
    public PageDTO<UserVO> queryUsersPage(UserQuery query) {
        // 1. 构建分页条件
        // 1.1 分页条件 
        Page<User> page = query.toMpPage(); //直接调用抽象出来的方法不用所有分页页面都写一遍提高复用性
        // 2. 分页查询
        Page<User> p = lambdaQuery().ge(User::getYz, query.getYz())
                .like(query.getNickname() != null, User::getNickname, query.getNickname())
                .eq(query.getSex() != null, User::getSex, query.getSex())
                .like(query.getTel() != null, User::getTel, query.getTel())
                .page(page);

        // 4. 返回分页结果
        return pageDTO.of(p, UserVO.class);  //使用转vo的抽象类，只需传入数据和需要转成的vo类的class类对象，即可返回正常的vo对象，如果vo还需要进一步改造的可以使用羡慕的方法。
        // 使用函数式接口转换分页数据
        return pageDTO.of(p, user -> {
            UserVO userVO = BeanUtil.copyProperties(user, UserVO.class);
            // 可以做特殊处理，比如只显示名字的部分
            userVO.setName(userVO.getName().substring(0, 1) + "**");
            return userVO;
        });
    }
```



## 正则表达式

正则表达式是处理文本的利器。是对字符串执行模式匹配的技术。

regular expression =》RegExp

matcher.find() 匹配到正则的结果，如果匹配到则返回true，没有匹配到返回false。

matcher.group(0)：表示匹配到的子字符串

matcher.group(1)：表示匹配到的子字符串的第一个分组

### 正则表达式语法

如果想要灵活的运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大致分为：

1. 限定符
2. 选择匹配符
3. 分组组合和反向引用符
4. 特殊字符
5. 字符匹配符
6. 定位符

```java
//正则案例
String content="Java是一门面向对象的编程语言，由Sun公司于1995年正式发布，" +
                "其设计理念源于对C 语言的改进，摒弃了多继承和指针等复杂概念，实现了功能" +
                "强大与简单易用的结合 [1] [9]。作为静态面向对象编程语言的代表，Java通过JVM" +
                "（Java虚拟机）实现跨平台运行，具备分布式、健壮性、安全性、多线程等特性，支持" +
                "桌面应用、Web应用和嵌入式系统开发 [2] [26] [62]。\n" +
                "该语言经历多个重要版本迭代，2006年Sun公司将Java开源 [13]，2009年甲骨" +
                "文公司完成对Sun的收购后持续推进技术更新 [14]。2014年Java 8引入函数式" +
                "编程特性，2017年Java 9实现模块化系统 [15] [56]。2024年3月甲骨文发布" +
                "Java 22，针对性能、安全性和开发效率进行数千项优化，提供对云原生应用和现代硬" +
                "件架构的增强支持";
        // 需求：提取出所有的数字
        String regExp="\\d{4}"; // 匹配4个数字
        Pattern pattern = Pattern.compile(regExp); // 编译正则表达式
        Matcher matcher = pattern.matcher(content); // 创建匹配器
        while (matcher.find()){ 
            System.out.println(matcher.group(0));
        }
```



### 元字符-特殊字符

`\\`符号说明：在我们使用正则表达式去检索某些特殊字符的时候，需要用到转义符号，否则检索不到结果，甚至会报错。

在java的正则表达式中，用`\\`代表其他语言中的一个`\`

需要用到转义符号的特殊字符有以下：` . * + ( ) $ / \ ? [ ] ^ { }`



### 元字符-字符匹配符

| 符号  | 含义                                                 | 示例           | 解释                                                 |
| ----- | ---------------------------------------------------- | -------------- | ---------------------------------------------------- |
| []    | 可接收的字符列表                                     | [efgh]         | e、f、g、h中的任意1个字符                            |
| [^]   | 不接收的字符列表                                     | [^abc]         | 除a、b、c之外的任意1个字符，包括数字和特殊符号       |
| -     | 连字符                                               | A-Z            | A到Z任意单个大写字母                                 |
| .     | 匹配除\n以外的任何字符                               | a..b           | 以a开头，b结尾，中间包括2个任意字符的长度为4的字符串 |
| `\\d` | 匹配单个数字字符，相当于[0-9]                        | `\\d{3}(\\d)?` | 包含3个或4个数字的字符串                             |
| `\\D` | 匹配单个非数字字符，相当于`[^0-9]`                   | `\\D(\\d)*`    | 以单个非数字字符开头，后接任意个数字的字符串         |
| `\\w` | 匹配单个数字，大小写字母字符，相当于[0-9a-zA-Z]      | `\\d{3}\\w{4}` | 以3个数字字符开头的长度为7的数字字母字符串           |
| `\\W` | 匹配单个非数字，大小写字母字符，相当于`[^0-9a-zA-Z]` | `\\W+\\d{2}`   | 以至少1个非数字字母字符开头的2个数字字符结尾的字符串 |

**应用实例**

1. [a-z]说明：[a-z]表示可以匹配a-z中任意一个字符
2. java正则表达式默认是区分字母大小写的，如何实现不区分大小写
   - (?i)abc 表示abc都不区分大小写
   - a(?i)bc 表示bc不区分大小写
   - a((?i)b)c 表示只有b不区分大小写
   - Pattern pat = Pattern.compile(regEX,Pattern.CASE_INSENSITIVE); 编译正则表达式不区分大小写
3. [^a-z]说明：表示可以匹配不是a-z中的任意一个字符
4. [abcd]说明：表示可以匹配`abcd`中的任意一个字符
5. [^abdc]：表示可以匹配不是abcd中的任意一个字符
6. `\\d` 表示可以匹配0-9的任意一个数字，相当于[0-9]
7. `\\D` 表示可以匹配不是0-9中的任意一个数字，相当于`[^0-9]`
8. `\\w` 匹配任意英文字符、数字和下划线。相当于[a-zA-Z0-9_]
9. `\\W` 相当于`[^a-zA-Z0-9_]`是`\\w`刚好相反
10. `\\s` 匹配任何空白字符（空格，制表符等）
11. `\\S` 匹配任何非空白字符，和`\\s`刚好相反
12. `.`匹配出`\n`之外的所有字符，如果要匹配`.`本身则需要使用`\\.`

### 元字符-选择匹配符

在匹配某个字符串的时候是选择性的，即：既可以匹配这个，又可以匹配那个，这时你需要用到选择匹配符号`|`

| 符号 | 含义                     | 示例   | 解释     |
| ---- | ------------------------ | ------ | -------- |
| \|   | 匹配\|之前或之后的表达式 | ab\|cd | ab或者cd |

### 元字符-限定符

用于指定其前面的字符和组合项连续出现多少次

| 符号  | 含义                                  | 示例        | 说明                                               |
| ----- | ------------------------------------- | ----------- | -------------------------------------------------- |
| *     | 指定字符重复0次或n次（无要求）0到多   | (abc)*      | 仅包含任意个abc的字符串，等效于\w*                 |
| +     | 指定字符重复1次或n次（至少一次）1到多 | m+(abc)*    | 以至少1个m开头，后接任意个abc的字符串              |
| ？    | 指定字符重复0次或1次（最多一次）0到1  | m+abc？     | 以至少1个m开头，后接ab或abc的字符串                |
| {n}   | 只能输入n个字符                       | [abcd]{3}   | 由abcd中字母组成的任意长度为3的字符串              |
| {n,}  | 指定至少n个匹配                       | [abcd]{3,}  | 由abcd中字母组成的任意长度不小于3的字符串          |
| {n,m} | 指定至少n个但不多于m个匹配            | [abcd]{3,5} | 由abcd中字母组成的任意长度不小于3，不大于5的字符串 |

Java匹配默认**贪婪匹配**，即尽可能匹配多的。

如果想匹配**非贪婪的匹配**，则需要在限定符后面加`?`,例如：`+?`

```java
String content="1111aaaaaahello";
String regStr="a{3,4}"; // 表示匹配aaa或aaaa，因为贪婪匹配所以优先匹配aaaa
String regStr="1+"; //表示匹配1个或多个1，因为贪婪匹配，会把字符串中所有的1都匹配了所有输出的是1111
Pattern pattern = Pattern.compile(regStr); // 编译正则表达式
Matcher matcher = pattern.matcher(content); // 创建匹配器
while (matcher.find()){ 
    System.out.println(matcher.group(0));
}
```

### 元字符-定位符

定位符，规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置，这个也是相当有用的，必须掌握。

| 符号  | 含义                   | 示例               | 说明                                                         |
| ----- | ---------------------- | ------------------ | ------------------------------------------------------------ |
| ^     | 指定起始字符           | ^[0-9]+[a-z]*      | 以至少1个数字开头，后接任意个小写字母的字符串                |
| $     | 指定结束字符           | `^[0-9]\\-[a-z]+$` | 以至少1个数字开头，后接“-”，并以至少1个小写字母结尾的字符串  |
| `\\b` | 匹配目标字符串的边界   | `han\\b`           | 这里说的字符串的边界指的是子串间有空格，或者是目标字符串的结束位置 |
| `\\B` | 匹配目标字符串的非边界 | `han\\B`           | 和\b的含义刚好相反                                           |

### 分组

| 常用分组构造形式   | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| （pattern）        | 非命名捕获。捕获匹配的子字符串编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其他捕获结果则根据左括号的顺序从1开始自动编号 |
| （?<name>pattern） | 命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号替代尖括号，例如（?'name'） |

```java
String content="1111aaaaaahello";
String regStr="(?<g1>\\d\\d)(?<g2>\\d\\d)"; //命名分组
Pattern pattern = Pattern.compile(regStr); // 编译正则表达式
Matcher matcher = pattern.matcher(content); // 创建匹配器
boolean matches = Pattern.matches(regStr,content); //整体匹配，用于验证整个字符串是否满足正则的条件，可以不使用开头和结尾定位符，因为要匹配字符串整体，所以部分匹配依然返回false。
String newcontent = matcher.replaceAll("2000"); //匹配替换，返回的字符串是替换后的字符串，原来的content不变化
while (matcher.find()){ 
    System.out.println(matcher.group(0)); // 匹配到的字符串
    System.out.println(matcher.group(1)); // 通过编号获取分组1匹配到的内容
    System.out.println(matcher.group("g1")); // 通过组名获取匹配的内容
}
```

**特别分组**

| 常用分组构造形式 | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| (?:pattern)      | 匹配pattern但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储以后使用的匹配。这对于用“or”字符(\|)组合模式部件的情况很有用。列如：`industr(?:y|ies)`是比'industry\|industries'更经济的表达式。 |
| (?=pattern)      | 它是一个非捕获匹配。例如'windows(?=95\|98\|2000\|NT)'匹配“windows 2000”中的"windows"，但不匹配"windows 3.1"中的windows |
| (?!pattern)      | 该表达式匹配不处于匹配pattern的字符串的起始点的搜索字符串。它是一个非捕获匹配。例如'windows(?!95\|98\|2000\|NT)'匹配"windows 3.1"中的windows但不匹配“windows 2000”中的"windows" |

### 分组，捕获，反向引用

1. **分组**：我们可以用圆括号组成一个比较复制的匹配模式，那么一个圆括号的部分我们可以看作是一个子表达式/一个分组。

2. **捕获**：把正则表达式中子表达式/分组匹配的内容，保存到内存中以数字编号或显式命名的组里，方便后面引用，从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。组0代表的是整个正则式

3. **反向引用**：圆括号的内容被捕获后，可以再这个括号内被使用，从而写出一个比较实用的匹配模式，这个我们称为反向引用，这种引用既可以是在正则表达式内部，也可以是在正则表达式外部，内部反向引用`\\分组号`，外部反向引用`$分组号`
   要匹配两个连续的相同数字：`(\\d)\\1`

   要匹配五个连续的相同数字：`(\\d)\\1{4}`
   要匹配个位与千位相同，十位与百位相同的数：`(\\d)(\\d)\\2\\1`
   
   ```java
   // 结巴程序案例，要求去掉重复的字变成正常的句子
   String content=“我我要学学学学学编程java！”; 
   content = Pattern.compile("(.)\\1+").matcher(content).replaceAll("$1");
   // (.)\\1 中的\\1是表达式内反向引用，replaceAll('$1')中的$1是表达式外反向引用
   ```
   
   

### 正则实例

1. 匹配汉字

   ```java
   String regStr="^[\u4e00-\u9fa5]+$"; //基础常用汉字的范围
   ```

2. 邮政编码：要求是1-9开头的一个六位数
   `String regStr="^[1-9]\\d{5}$"; `

3. QQ号码，要求是1-9开头的一个（5-10位数）
   `String regStr="^[1-9]\\d{4,9}$";`

4. 手机号码，要求：必须以13,14,15,18开头的11位数
   `String regStr="^1[3|4|5|8]\\d{9}$";`

5. 验证url
   `String regStr="^((http|https)://)?([\\w-]+\\.)+[\\w-]+(\\/[\\w-?=&/%.#]*)?$"; `
   
6. 验证邮箱：要求整那个有一个@，@前面是用户名可以是a-zA-Z0-9_-字符，@后面是域名，并且域名只能是英文字母，比如sohu.com或者tsinghua.org.cn
   `String regStr="^[\\w-]+@([a-zA-Z]+\\.)+[a-zA-Z]{2,}$";`

7. 判断是整数还是小数，需要考虑正数还是负数
   `String regStr="^[-+]?([1-9]\\d*|0)(\\.\\d+)?$";`

8. **校验数字的表达式**

   ```java
   数字：^[0-9]*$
   n位的数字：^\d{n}$
   至少n位的数字：^\d{n,}$
   m-n位的数字：^\d{m,n}$
   零和非零开头的数字：^(0|[1-9][0-9]*)$
   非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$
   带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$
   正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$
   有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
   有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
   非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$
   非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$
   非负整数：^\d+$ 或 ^[1-9]\d*|0$
   非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$
   非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$
   非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$
   正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$
   负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$
   浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$
   ```

9. **校验字符的表达式**

   ```java
   汉字：^[\u4e00-\u9fa5]{0,}$
   英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$
   长度为3-20的所有字符：^.{3,20}$
   由26个英文字母组成的字符串：^[A-Za-z]+$
   由26个大写英文字母组成的字符串：^[A-Z]+$
   由26个小写英文字母组成的字符串：^[a-z]+$
   由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
   由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$
   中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$
   中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$
   可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+
   禁止输入含有~的字符：[^~\x22]+
   ```

   

10. **特殊需求表达式**

   ```java
   Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
   域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?
   InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$
   手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$
   电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 
   国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}
   身份证号(15位、18位数字)：^\d{15}|\d{18}$
   短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$
   帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
   密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$
   强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$  
   日期格式：^\d{4}-\d{1,2}-\d{1,2}
   一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$
   一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 
   钱的输入格式：
   	1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$ 
   	2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 
   	3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 
   	4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 
   	5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$ 
   	6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 
   	7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 
   	8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 
   备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
   xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$
   中文字符的正则表达式：[\u4e00-\u9fa5]
   双字节字符：[^\x00-\xff]    (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
   空白行的正则表达式：\n\s*\r    (可以用来删除空白行)
   HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? />    (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)
   首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$)    (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
   腾讯QQ号：[1-9][0-9]{4,}    (腾讯QQ号从10000开始)
   中国邮政编码：[1-9]\d{5}(?!\d)    (中国邮政编码为6位数字)
   IP地址：\d+\.\d+\.\d+\.\d+    (提取IP地址时有用)
   ```

注意：[ ]内的特殊字符表示普通的字符不再表示限定，匹配等特殊字符

### String类中使用正则表达式

```java
String str="asdfas";
str = str.replaceAll("正则","替换字符"); //String类的字符替换
// 判断功能
boolean pd = str.matches("正则"); //判断字符串是否满足整体匹配
// 分割功能
String[] split = str.split("#|-|~|\\d+");
```

## 算法优化

编程中算法很多，比如八大排序算法（冒泡、选择、插入、快排、归并、希尔、基数、堆排序）、查找算法、分治算法、动态规划算法、KMP算法、贪心算法、普里姆算法、克鲁斯卡尔算法、迪杰斯特拉算法、弗洛伊德算法

马踏棋盘算法也被称为骑士周游问题：将马随机放在国际象棋的8X8棋盘`Board[0~7][0~7]`某个方格中，马按走棋规则（马走日字）进行移动。要求没个方格只进入一次，走遍棋盘上全部64个方格。

需要使用图的遍历算法（DFS）+贪心算法优化

骑士周游问题的解决步骤和思路分析：

1. 创建棋盘chessBoard是二维数组
2. 将当前位置设置为已经访问，然后根据当前位置，计算马儿还能走那些位置，并放入到一个集合中（ArrayList），最多有8个，每走一步，使用step+1
3. 遍历ArrayList中存放的所有位置，看看那个可以走，如果可以走通，就继续，走不通，就回溯
4. 判断马儿是否完成了任务，使用step和应该走的步数比较，如果没有达到数量，则表示没有完成任务，将整个棋盘设置为0

注意：马儿走的策略不同，则得到的结果也不一样，效率也不一样。

贪心算法分析：

因为下个位置不固定，所以下个位置的下个位置也是不固定的，我们的下一个点位的获取中是按照顺时针顺序来判断挑选的位置，因此选择的下个点位可以走的位置的个数是不确定的。

优化思路：

我们优先选择走下个位置的下个位置可走点位比较少的点，这样的话，即使走不通回溯的步数也比较少，这样就可以大大减少循环的次数。

## Spring

IoC，DI和AOP思想

IoC思想：Inversion Of  Control 控制反转，强调的是原来在程序中创建Bean(对象)的权利反转给第三方。

DI思想：Dependency Injection 依赖注入，强调的Bean之间关系，这种关系第三方负责去设置。

AOP思想：Aspect Oriented Programming 面向切面编程，功能的横向抽取，注意的实现方式就是Proxy

框架的基本特点：

- 框架(Framework)，是基于基础技术之上，从众多业务中抽取出的通用解决方案；
- 框架是一个半成品，使用框架规定的语法开发可以提高开发效率，可以用简单的代码就能完成复杂的基础业务;
- 框架内部使用大量的设计模式、算法、底层代码操作技术，如反射、内省、xml解析、注解解析等；
- 框架一般都具备扩展性；
- 有了框架，我们可以将精力尽可能的投入在纯业务开发上而不用去费心技术实现以及一些辅助业务。

### BeanFactory

BeanFactory的开发步骤：

1. 导入Spring的jar包或Maven坐标；
2. 定义UserService接口及其UserServicelmpl实现类；
3. 创建beans.xml配置文件，将UserServicelmpl的信息配置到该xml中；
4. 编写测试代码，创建BeanFactory，加载配置文件，获取UserService实例对象。

```java
public static void main(String[] args){
    // 1.创建bean工厂
    DefaultListableBeanFactory beanFactory= new DefaultListableBeanFactory();
    // 2.为bean工厂创建xml读取器
    XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory);
    // 3. 读取beans.xml配置文件
    reader.loadBeanDefinitions(location:"beans.xml");
    // 4. beanFactory 创建了一个UserService的bean
    UserService userService = (UserService) beanFactory.getBean(name:"userService");
   
}
```

上面使用BeanFactory完成了loC思想的实现，下面去实现以下DI依赖注入：

1. 定义UserDao接口及其UserDaolmpl实现类；
2. 修改UserServicelmpl代码，添加一个setUserDao(UserDaouserDao)用于接收注入的对象；
3. 修改beans.xml配置文件，在UserDaolmpl的<bean>中嵌入<property>配置注入;
4. 修改测试代码，获得UserService时，setUserService方法执行了注入操作。

```xml
<beans>
    <!--配置UserServiceImpl-->
    <bean id="userService" class="com.itheima.service.impl.UserServiceImpl">
        <!--在UserServiceImpl中创建setUserDao方法，通过此方法可以生成一个userDao的bean，这就提现了DI的思想，property是bean的属性，name就是set方法去掉set后的名字，ref就是要注入的bean的id，此处就是设置依赖注入-->
    	<property name="userDao" ref="userDao"></property>
    </bean>
    <!--配置UserDaoImpl-->
    <bean id="userDao"
    class="com.itheima.dao.impl.UserDaoImpl"></bean>
</beans>
```

### ApplicationContext

ApplicationContext（引用上下文）快速入门
ApplicationContext 称为Spring容器，内部封装了BeanFactory,比BeanFactory功能更丰富更强大,使用ApplicationContext进行开发时，xml配置文件的名称习惯写成ApplicationContext.xml

```java
public static void main(String[] args){
    //创建ApplicationContext，加载配置文件，实例化容器
	ApplicationContext applicationContext =
new ClassPathxmlApplicationContext（“beans.xml");
    //根据beanName获得容器中的Bean实例
    UserService userService = (UserService) applicationContext.getBean("userService"):
    System.out.println(userService);
}
```

BeanFactory与ApplicationContext的关系：

1. BeanFactory是Spring的早期接口，称为Spring的Bean工厂，ApplicationContext是后期更高级接口，称之为Spring 容器;
2. ApplicationContext在BeanFactory基础上对功能进行了扩展，例如：监听功能、国际化功能等。BeanFactory的API更偏向底层，ApplicationContext的API大多数是对这些底层API的封装；
3. Bean创建的主要逻辑和功能都被封装在BeanFactory中，ApplicationContext不仅继承了BeanFactory，而且ApplicationContext内部还维护着BeanFactory的引|用，所以,ApplicationContext与BeanFactory既有继承关系，又有融合关系。
4. Bean的初始化时机不同，原始BeanFactory是在首次调用getBean时才进行Bean的创建（延迟加载），而ApplicationContext则是配置文件加载，容器一创建就将Bean都实例化并初始化好（立即创建）。

只在Spring基础环境下，常用的三个ApplicationContext作用如下：

| 实现类                             | 功能描述                                   |
| ---------------------------------- | ------------------------------------------ |
| ClassPathXmlApplicationContext     | 加载类路径下的xm配置的ApplicationContext   |
| FileSystemXmlApplicationContext    | 加载磁盘路径下的xm配置的ApplicationContext |
| AnnotationConfigApplicationContext | 加载注解配置类的ApplicationContext         |

### springBean的配置

| XML配置方式                              | 功能柜描述                                                   |
| ---------------------------------------- | ------------------------------------------------------------ |
| <bean id="" class="“>                    | Bean的id和全限定名配置，id在容器中会转成bean Name            |
| <bean name="”>                           | 通过name设置Bean的别名，通过别名也能直接获取到Bean实例       |
| <bean scope="“>                          | Bean的作用范围，BeanFactory作为容器时取值singleton和prototype |
| <bean lazy-init="">                      | Bean的实例化时机，是否延迟加载。BeanFactory作为容器时无效    |
| <bean init-method="”>                    | Bean实例化后自动执行的初始化方法，method指定方法名           |
| <bean destroy-method="">                 | Bean实例销毁前的方法，method指定方法名                       |
| <bean autowire="byType">                 | 设置自动注入模式，常用的有按照类型byType，按照名字byName     |
| <bean factory-bean=" factory-method=""/> | 指定哪个工厂Bean的哪个方法完成Bean的创建                     |

**Bean的范围配置**
默认情况下，单纯的Spring环境Bean的作用范围有两个：Singleton和Prototype
singleton：单例，默认值，Spring容器创建的时候，就会进行Bean的实例化，并存储到容器内部的单例池中，每次getBean时都是从单例池中获取相同的Bean实例；
prototype:原型,Spring容器初始化时不会创建Bean实例,当调用getBean时才会实例化Bean,每次getBean都会创建一个新的Bean实例并不会再放入单例池中。

**Spring的实例化方式主要如下两种：**
● 构造方式实例化：底层通过构造方法对Bean进行实例化
● 工厂方式实例化：底层通过调用自定义的工厂方法对Bean进行实例化（可以在创建bean之前或之后做一些其他业务逻辑处理）

```java
// 静态工厂方法
public class MyBeanFactory1{
    public static UserDao userDao(){
        //Bean创建之前可以进行一些其他业务逻辑操作
        return new UserDaoImpl();
    }
}

// 实例工厂方法
public class MyBeanFactory2{
    public UserDao userDao(){
        //Bean创建之前可以进行一些其他业务逻辑操作
        return new UserDaoImpl();
    }
}
```

```xml
<!--静态方法的工厂方式实例化-->
<bean id="userDao1" class="net.dpwl.factory.MyBeanFactory1" factory-method="userDao">
	<!--如果构造bean需要参数可以使用Constructor-arg-->
    <constructor-arg name="参数名" value="参数值" ></constructor-arg>
</bean>

<!--非静态方法的工厂方式实例化 ：1.先创建非静态方法的实例化bean-->
<bean id="myBeanFactory2" class="net.dpwl.factory.MyBeanFactory2" ></bean>
<!--2. 使用创建好的ben去实例化方法-->
<bean id="userDao2" factory-bean="myBeanFactory2" factory-method="userDao"></bean>
```

**Bean的依赖注入有两种方式：**

| 注入方式                   | 配置方式                                                     |
| -------------------------- | ------------------------------------------------------------ |
| 通过Bean的set方法注入      | <property name="userDao" ref="userDao"/><br /><property name="userDao" ref="userDao"/> |
| 通过构造Bean的方法进行注入 | <constructor-arg name="name" ref="userDao"/><br /><constructor-arg name="name" value="haohao"/> |

其中，ref是reference的缩写形式，翻译为：涉及，参考的意思，用于引用其他Bean的id。value用于注入普通属性值。

**依赖注入的数据类型有如下三种：**

- 普通数据类型，例如：String、int、boolean等，通过value属性指定。
- 引l用数据类型，例如:UserDaolmpl、DataSource等，通过ref属性指定。
- 集合数据类型，例如:List、Map、Properties等。

```xml
<!--注入list集合-->
<bean id="userService"
class="com.itheima.service.impl.UserServiceImpl">
    <property name="stringList">
        <list>
            <value>aaa</value>
            <value>bbb</value>
            <value>ccc</value>
        </list>
    </property>
</bean>
```

**扩展：自动装配方式**
如果被注入的属性类型是Bean引l用的话，那么可以在<bean>标签中使用autowire属性去配置自动注入方式，属性值有两个：
byName:通过属性名自动装配,即去匹配 setXxx与id="xxx”(name="xxx”)是否一致;
byType:通过Bean的类型从容器中匹配，匹配出多个相同Bean类型时，报错。
`<bean id="userService" 
class="com.itheima.service.impl.UserServiceImpl"
autowire="byType"></bean>`

**Spring的其他配置标签**
Spring的xml标签大体上分为两类，一种是默认标签，一种是自定义标签
默认标签：就是不用额外导入其他命名空间约束的标签，例如<bean>标签
Spring的默认标签用到的是Spring的默认命名空间,该命名空间约束下的默认标签如下：

| 标签     | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| <beans>  | 般作为xml配置根标签，其他标签都是该标签的子标签，profile="dev"可以区别不同的环境使用不同的配置，程序中使用System.setProperty("spring.profiles.active","dev");指定激活的环境 |
| <bean>   | Bean的配置标签，上面已经详解了，此处不再阐述                 |
| <import> | 外部资源导入标签                                             |
| <alias>  | 指定Bean的别名标签，使用较少                                 |

自定义标签：就是需要额外引入其他命名空间约束，并通过前缀引l用的标签，例如`<context:property-placeholder/>`标签

### spring的get方法

| 方法定义                                | 返回值和参数                                                 |
| --------------------------------------- | ------------------------------------------------------------ |
| Object getBean (String beanName)        | 根据beanName从容器中获取Bean实例，要求容器中Bean唯一，返回值为Object，需要强转 |
| T getBean (Class type)                  | 根据Class类型从容器中获取Bean实例，要求容器中Bean类型唯一，返回值为Class类型实例，无需强转 |
| T getBean (String beanName, Class type) | 根据beanName从容器中获得Bean实例，返回值为Class类型实例，无需强转 |

### spring配置非自定义Bean

以上在xml中配置的Bean都是自己定义的，例如：UserDaolmpl,UserServicelmpl。但是，在实际开发中有些功能类并不是我们自己定义的，而是使用的第三方jar包中的，那么，这些Bean要想让Spring进行管理，也需要对其进行配置

配置非自定义的Bean需要考虑如下两个问题：

- 被配置的Bean的实例化方式是什么？无参构造、有参构造、静态工厂方式还是实例工厂方式；
- 被配置的Bean是否需要注入必要属性。

```xml
<!——静态工厂方法方式-->
<bean id="in" class="org.apache.ibatis.io.Resources" factory-method="getResourceAsStream">
	<constructor-arg name="resource" value="mybatis-config.xml"></constructor-arg>
</bean>
<!——无参构造实例化-->
<bean id="builder" class="org.apache.ibatis.session.SqlSessionFactoryBuilder"></bean>
<!——实例工厂方法-->
<bean id="sqlSessionFactory" factory-bean="builder" factory-method-"build">
	<constructor-arg name="inputstream" ref="in"></constructor-arg>
</bean>
```



### Bean实例化的基本流程

Spring容器在进行初始化时，会将xml配置的<bean>的信息封装成一个BeanDefinition(Bean定义)对象，所有的BeanDefinition存储到一个名为beanDefinitionMap的Map集合中去，Spring框架在对该Map进行遍历，使用反射创建Bean实例对象，创建好的Bean对象存储在一个名为singletonObjects(单例池)的Map集合中，当调用getBean方法时则最终从该Map集合中取出Bean实例对象返回。

Bean实例化的基本流程：

- 加载xml配置文件，解析获取配置中的每个<bean>的信息，封装成一个个的BeanDefinition对象；
- 将BeanDefinition存储在一个名为beanDefinitionMap的Map<String,BeanDefinition>中;
- ApplicationContext底层遍历beanDefinitionMap,创建Bean实例对象；
- 创建好的Bean实例对象，被存储到一个名为singletonObjects的Map<String,Object>中;
- 当执行applicationContext.getBean(beanName)时,从singletonObjects去匹配Bean实例返回。

![QQ20260114-100900](.\img\QQ20260114-100900.png)

### Spring后处理器

Spring的后处理器是Spring对外开发的重要扩展点，允许我们介入到Bean的整个实例化流程中来，以达到动态注册BeanDefinition,动态修改BeanDefinition,以及动态修改Bean的作用。Spring主要有两种后处理器：

- BeanFactoryPostProcessor：Bean工厂后处理器,在BeanDefinitionMap填充完毕,Bean实例化之前执行；
- BeanPostProcessor：Bean后处理器,一般在Bean实例化之后，填充到单例池singletonObjects之前执行。

Bean工厂后处理器-BeanFactoryPostProcessor
BeanFactoryPostProcessor是一个接口规范，实现了该接口的类只要交由Spring容器管理的话，那么Spring就会回调该接口的方法，用于对BeanDefinition注册和修改的功能。

```java
//xml 配置Bean工厂后处理器的bean
<bean class="net.dpwl.processor.MyBeanFactoryPostProcessor"></bean>

//Bean工厂后处理器 测试
public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor{
    @Override
    public void
postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throw Exception{
        System.out.println（"beanDefinitionMap填充完毕后回调该方法");
        // 1.修改某个beanDefinition
      BeanDefinition beanDefinition=beanFactory.getBeanDefinition("userService");
        beanDefinition.setBeanClassName("net.dpwl.dao.impl.UserDaoImpl");
        // 2.注册beanDefinition
        BeanDefinition beanDefinition=new RootBeanDefinition();
        beanDefinition.setBeanClassName("net.dpwl.dao.impl.PersonDaoImpl");
        // 2.2要把bean放入beanDefinitionMap需要强转成DefaultListableBeanFactory
        DefaultListableBeanFactory dbf=(DefaultListableBeanFactory) beanFactory;
        dbf.registerBeanDefinition("personDao",beanDefinition);
    }
}
```

Bean后处理器-BeanPostProcessor
Bean被实例化后，到最终缓存到名为singletonObjects单例池之前，中间会经过Bean的初始化过程，例如：属性的填充、初始方法init的执行等，其中有一个对外进行扩展的点BeanPostProcessor，我们称为Bean后处理。跟上面的Bean工厂后处理器相似，它也是一个接口，实现了该接口并被容器管理的BeanPostProcessor，会在流程节点上被Spring自动调用。

```java
package net.dpwl.webapi.processor;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.Date;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2026/1/14 15:02
 */
public class LogTimeBeanPostProcessor implements BeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);
    }

    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        // 使用动态代理对目标Bean进行增强，返回proxy对象，进而存储到单例池singleObjects中
        Object beanProxy = Proxy.newProxyInstance(
                bean.getClass().getClassLoader(),
                bean.getClass().getInterfaces(),
                (proxy, method, args) -> {
                    // 1.输出开始时间
                    System.out.println("方法：" + method.getName() + "-开始时间：" + new Date());
                    // 2.执行目标方法
                    Object result = method.invoke(bean, args);
                    // 3.输出结束时间
                    System.out.println("方法：" + method.getName() + "-结束时间：" + new Date());
                    return result;
                }
        );
        return BeanPostProcessor.super.postProcessAfterInitialization(beanProxy, beanName);
    }
}
```

![QQ20260114-151926](.\img\QQ20260114-151926.png)

### Spring Bean的生命周期

SpringBean的生命周期是从Bean实例化之后，即通过反射创建出对象之后，到Bean成为一个完整对象，最终存储到单例池中，这个过程被称为SpringBean的生命周期。SpringBean的生命周期大体上分为三个阶段：

- Bean的实例化阶段：Spring框架会取出BeanDefinition的信息进行判断当前Bean的范围是否是singleton的，是否不是延迟加载的，是否不是FactoryBean等，最终将一个普通的singleton的Bean通过反射进行实例化；

- Bean的初始化阶段：Bean创建之后还仅仅是个”半成品”，还需要对Bean实例的属性进行填充、执行一些Aware接口方法、执行BeanPostProcessor方法、执行InitializingBean接口的初始化方法、执行自定义初始化init方法等。该阶段是Spring最具技术含量和复杂度的阶段，Aop增强功能，后面要学习的Spring的注解功能等、spring高频面试题Bean的循环引用问题都是在这个阶段体现的；

  Spring Bean的初始化过程涉及如下几个过程：

  - Bean实例的属性填充

    spring在进行属性注入时，会分为如下几种情况：
    注入普通属性，String、int或存储基本类型的集合时，直接通过set方法的反射设置进去；
    注入单向对象引用属性时，从容器中getBean获取后通过set方法反射设置进去，如果容器中没有，则先创建被注入对象Bean实例（完成整个生命周期）后，在进行注入操作；
    注入双向对象引用属性时，就比较复杂了，涉及了循环引用（循环依赖）问题，下面会详细阐述解决方案。Spring提供了三级缓存存储完整Bean实例和半成品Bean实例，用于解决循环引用问题
    在DefaultListableBeanFactory的上四级父类DefaultSingletonBeanRegistry中提供如下三个Map：

    ```java
    public class DefaultSingletonBeanRegistry...{
        //1、最终存储单例Bean成品的容器，即实例化和初始化都完成的Bean,称之为"一级缓存"
        Map<String, Object> singletonObjects = new ConcurrentHashMap(256);
        //2、早期Bean单例池，缓存半成品对象，且当前对象已经被其他对象引用了，称之为”二级缓存"
        Map<String, Object> earlySingletonObjects = new ConcurrentHashMap (16);
        Q
        //3、单例Bean的工厂池，缓存半成品对象，对象未被引用，使用时在通过工厂创建Bean，称之为"三级缓存"
        Map<String, ObjectFactory<?>> singletonFactories = new HashMap(16);
    }
    ```

    

  - Aware接口属性注入

    常用的Aware接口
    Aware接口是一种框架辅助属性注入的一种思想，其他框架中也可以看到类似的接口。框架具备高度封装性，我们接触到的一般都是业务代码，一个底层功能API不能轻易的获取到，但是这不意味着永远用不到这些对象，如果用到了，就可以使用框架提供的类似Aware的接口，让框架给我们注入该对象。

    | Aware接口               | 回调方法                                                     | 作用                                                    |
    | ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------- |
    | ServletContextAware     | setServletContext(ServletContext context)                    | Spring框架回调方法注入ServletContext对象web环境下才生效 |
    | BeanFactoryAware        | setBeanFactory(BeanFactory factory)                          | Spring框架回调方法注入beanFactory对象                   |
    | BeanNameAware           | setBeanName(String beanName)                                 | Spring框架回调方法注入当前Bean在容器中的beanName        |
    | ApplicationContextAware | setApplicationContext(ApplicationContext applicationContext) | Spring框架回调方法注入applicationContext对象            |

    

  - BeanPostProcessor的before()方法回调

  - InitializingBean接口的初始化方法回调

  - 自定义初始化方法init回调

  - BeanPostProcessor的after()方法回调

- Bean的完成阶段：经过初始化阶段，Bean就成为了一个完整的SpringBean，被存储到单例池singletonObjects中去了，即完成了Spring Bean的整个生命周期。

### Spring xml方式整合第三方框架

xml整合第三方框架有两种整合方案：

- 不需要自定义命名空间（只需使用Spring的xmlns和xsi），不需要使用Spring的配置文件配置第三方框架本身内容，例如：MyBatis；

  ```xml
  <!--配置数据源信息-->
  <bean id="datasource"
  class="com.alibaba.druid.pool.DruidDataSource">
      <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
      <property name="url"
      value="jdbc:mysql://localhost:3306/mybatis"></property>
      <property name="username"
      value="root"></property>
      <property name="password" value="root"></property>
  </bean>
  <!--配置sqlSessionFactoryBean,作用将sqlSessionFactory存储到spring容器-->
  <bean class="org.mybatis.spring.SqlSessionFactoryBean">
  	<property name="dataSource" ref="dataSource"></property>
  </bean>
  <!--MapperScannerConfigurer，作用扫描指定的包，产生Mapper对象存储到spring容器-->
  <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
  	<property name="basePackage" value="com.itheima.mapper"></property>
  </bean>
  ```

  Spring整合MyBatis的原理剖析
  整合包里提供了一个SqlSessionFactoryBean和一个扫描Mapper的配置对象，SqlSessionFactoryBean一旦被实例化，就开始扫描Mapper并通过动态代理产生Mapper的实现类存储到Spring容器中。相关的有如下四个类：
  ● SqlSessionFactoryBean:需要进行配置,用于提供SqlSessionFactory;
  ● MapperScannerConfigurer:需要进行配置，用于扫描指定mapper注册BeanDefinition;
  ● MapperFactoryBean:Mapper的FactoryBean,获得指定Mapper时调用getObject方法；
  ● ClassPathMapperScanner:definition.setAutowireMode(2)修改了自动注入状态,所以
  MapperFactoryBean中的setSqlSessionFactory会自动注入进去。

- 需要引入第三方框架命名空间（需要使用自己的xmlns和xsi），需要使用Spring的配置文件配置第三方框架本身内容，例如：Dubbo。

**spring xml方式整合第三方框架（自定义xml标签）**

通过上述分析，我们清楚的了解了外部命名空间标签的执行流程，如下：

- 将自定义标签的约束与物理约束文件与网络约束名称的约束以键值对形式存储到一个spring.schemas文件里，该文件存储在类加载路径的META-INF里，Spring会自动加载到；
- 将自定义命名空间的名称与自定义命名空间的处理器映射关系以键值对形式存在到一个叫spring.handlers文件里，该文件存储在类加载路径的META-INF里，Spring会自动加载到；
- 准备好NamespaceHandler，如果命名空间只有一个标签，那么直接在parse方法中进行解析即可，一般解析结果就是注册该标签对应的BeanDefinition。如果命名空间里有多个标签，那么可以在init方法中为每个标签都注册一个BeanDefinitionParser,在执行NamespaceHandler的parse方法时在分流给不同的BeanDefinitionParser进行解析（重写doParse方法即可）。

### Bean基本注解开发

Spring除了xml配置文件进行配置之外，还可以使用注解方式进行配置，注解方式慢慢成为xml配置的替代方案。我们有了xml开发的经验，学习注解开发就方便了许多，注解开发更加快捷方便。
Spring提供的注解有三个版本：

- 2.0时代，Spring开始出现注解
- 2.5时代，Spring的Bean配置可以使用注解完成
- 3.0时代，Spring其他配置也可以使用注解完成，我们进入全注解时代

基本Bean注解，主要是使用注解的方式替代原有xml的<bean>标签及其标签属性的配置

```xml
<bean id="" name="" class="" scope="" lazy-init="" init-method="" destroy-method="" abstract="" autowire="" factory-bean="" factory-method=""></bean>
```

使用@Component注解替代`<bean>`标签
@Component就单纯一个value属性，那么xml配置<bean>时那些属性怎么进行配置呢？Spring是通过注解方式去配置的之前<bean>标签中的那些属性，例如：@Scope

| xml配置                    | 注解                 | 描述                                                         |
| -------------------------- | -------------------- | ------------------------------------------------------------ |
| `<bean id=" class=">`      | @Component(value="") | 被该注解标识的类，会在指定扫描范围内被spring加载并实例化     |
| `<bean scope="">`          | @Scope               | 在类上或使用了@Bean标注的方法上，标注Bean的作用范围，取值为singleton或prototype |
| `<bean lazy-init="">`      | @Lazy                | 在类上或使用了@Bean标注的方法上，标注Bean是否延迟加载，取值为true和false |
| `<bean init-method="">`    | @PostConstruct       | 在方法上使用，标注Bean的实例化后执行的方法                   |
| `<bean destroy-method="">` | @PreDestroy          | 在方法上使用，标注Bean的销毁前执行方法                       |

使用注解模式，需要在xml中配置组件扫描的基本包

```xml
<!--注解组件扫描：扫描指定的基本包及其子包下的类，识别使用eComponent注解-->
<context:component-scan base-package="net.dpwl"/>
```

如果Component不配置value则默认使用类的名称首字母小写作为bean的名称。

由于JavaEE开发是分层的，为了每层Bean标识的注解语义化更加明确，@Component又行生出如下三个注解：

| @Component衍生注解 | 描述                |
| ------------------ | ------------------- |
| @Repository        | 在Dao层类上使用     |
| @Service           | 在Service层类上使用 |
| @Controller        | 在Web层类上使用     |

### Bean依赖注入开发

Bean依赖注入的注解，主要是使用注解的方式替代xml的<property>标签完成属性的注入操作

```xml 
<bean id="" class="">
    <property name="" value=""/>
    <property name="" ref=""/>
</bean>
```

Spring主要提供如下注解，用于在Bean内部进行属性注入的：

| 属性注入注解 | 描述                                                   |
| ------------ | ------------------------------------------------------ |
| @Value       | 使用在字段或方法上，用于注入普通数据                   |
| @Autowired   | 使用在字段或方法上，用于根据类型（byType）注入引用数据 |
| @Qualifier   | 使用在字段或方法上，结合@Autowired，根据名称注入       |
| @Resource    | 使用在字段或方法上，根据类型或名称进行注入             |

@Autowired 根据类型进行注入，如果同一类型的Bean有多个，尝试根据名字进行二次匹配,匹配不成功再报错

在方法或字段上@Qualifier结合@Autowired一起使用，作用是根据名称注入相应的Bean

```java
@Autowired
@Qualifier("Bean名称")
```

@Resource  不指定名称参数时根据类型注入，指定名称（name=""）则根据名字注入。

### 非自定义Bean注解开发

非自定义Bean不能像自定义Bean一样使用@Component进行管理，非自定义Bean要通过工厂的方式进行实例化，使用@Bean标注方法即可，@Bean的属性为beanName，如不指定为当前工厂方法名称

```java
//将方法返回值Bean实例以@Bean注解指定的名称存储到spring容器中
@Bean("dataSource")
public DataSource dataSource(){
    DruidDataSource dataSource = new DruidDataSource():
    dataSource.setDriverClassName("com.mysql.jdbc.Driver");
    dataSource.setUrl("jdbc:mysql://1ocalhost:3306/mybatis");
    dataSource.setUsername("root");
    dataSource.setPassword("root"):
    return dataSource;
}    
```

PS:工厂方法所在类必须要被Spring管理

@Bean不设置名字默认使用方法名作为名字

@Bean注解在方法上，方法返回的bean，所有此方法必须是spring能扫描到的类，即该类要有@Component注解。

@Bean注解的方法如果要注入一个其他的bean，默认可以直接自动注入，不用再写@Autowired，spring会根据类型自动注入。

### Bean的配置类的注解开发

@Configuration  标注当前类是一个配置类（替代配置文件）+@Component

@ComponentScan(base-package={"net.dpwl"})  注解组件扫描，base-package可以省略，如果只扫描一个软件包，{}也可以省略。

@PropertySource("classpath:jdbc.properties")  注解资源文件，解析Properties文件后可以直接使用${key}获取配置的值。

@Import()  注解代替`<import>`标签,加载其他配置类

```java
public static void main (String[] args){
    //xml 方式的Spring容器
	//ApplicationContext applicationContext = new ClassPathxmlApplicationContext（“beans.xml");
    //注解方式去加载spring的核心配置类
    ApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringConfig.class);
}

```

### Spring配置其他注解

扩展：@Primary注解用于标注相同类型的Bean优先被使用权，@Primary是Spring3.0引l入的，与@Component和@Bean一起使用，标注该Bean的优先级更高，则在通过类型获取Bean或通过@Autowired根据类型进行注入时，会选用优先级更高的

```java
@Repository("userDao")
public class UserDaoImpl implements UserDao()

@Repository("userDao2")
@Primary
public class UserDaoImpl2 implements UserDao()

@Bean
public UserDao userDaoO1(){return new UserDaoImpl();}

@Bean
@Primary
public UserDao userDao02 (){return new UserDaoImpl2();}
```

扩展：@Profile注解的作用同于xml配置时学习profile属性，是进行环境切换使用的

```xml
<beans profile="test"></beans>
```

注解@Profile标注在类或方法上，标注当前产生的Bean从属于哪个环境，只有激活了当前环境，被标注的Bean才能被注册到Spring容器里，不指定环境的Bean，任何环境下都能注册到Spring容器里

```java
@Repository("userDao")
@Profile("test")
public class UserDaoImpl implements UserDao()
    
@Repository("userDao2")
public class UserDaoImpl2 implements UserDao()
```

可以使用以下两种方式指定被激活的环境：
使用命令行动态参数，虚拟机参数位置加载-Dspring.profiles.active=test
使用代码的方式设置环境变量System.setProperty("spring.profiles.active","test”);

![QQ20260116-152941](.\img\QQ20260116-152941.png)

### Spring注解方式整合第三方框架

第三方框架整合，依然使用MyBatis作为整合对象，之前我们已经使用xml方式整合了MyBatis，现在使用注解方式无非就是将xml标签替换为注解，将xml配置文件替换为配置类而已，原有xml方式整合配置如下

```xml
<!--xml方式整合mybaits-->
<!--配置数据源信息-->
<bean id="datasource"
class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
    <property name="url"
    value="jdbc:mysql://localhost:3306/mybatis"></property>
    <property name="username"
    value="root"></property>
    <property name="password" value="root"></property>
</bean>
<!--配置sqlSessionFactoryBean,作用将sqlSessionFactory存储到spring容器-->
<bean class="org.mybatis.spring.SqlSessionFactoryBean">
	<property name="dataSource" ref="dataSource"></property>
</bean>
<!--MapperScannerConfigurer，作用扫描指定的包，产生Mapper对象存储到spring容器-->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
	<property name="basePackage" value="com.itheima.mapper"></property>
</bean>
```

```java
// 注解方式整合mybatis
@Configuration // 配置注解
@PropertySource("classpath:jdbc.properties") //properties数据源注解
@MapperScan("net.dpwl.mapper") //mybaits提供的注解，mapper接口扫描
public class SpringConfig{
    @Bean //非自定义Bean注解
    public DataSource dataSource(
    	@Value("${jdbc.driver}") String driver,
        @Value("${jdbc.url}") String url,
        @Value("${jdbc.username}") String username,
        @Value("${jdbc.password}") String password,
    ){
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        dataSource.setUserName(username);
        dataSource.setPassword(password);
        return dataSource;
    }
    
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){ //dataSource会根据类型自动注入，不需要再写注解@Autowired
        SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
}
```

Spring与MyBatis注解方式整合有个重要的技术点就是@Import，第三方框架与Spring整合xml方式很多是凭借自定义标签完成的，而第三方框架与Spring整合注解方式很多是靠@Import注解完成的。
@Import可以导入如下三种类：

1. 普通的配置类
2. 实现ImportSelector接口的类（实现ImportSelector接口的selectImports方法需要返回一个数组，数组封装的是需要被注册到spring容器中的bean的全限定名）
3. 实现ImportBeanDefinitionRegistrar接口的类 （常用于总定义的框架和spring集成）

### AOP的概念

AOP，Aspect Oriented Programming，面向切面编程，是对面向对象编程OOP的升华。OOP是纵向对一个事物的抽象，一个对象包括静态的属性信息，包括动态的方法信息等。而AOP是横向的对不同事物的抽象，属性与属性、方法与方法、对象与对象都可以组成一个切面，而用这种思维去设计编程的方式叫做面向切面编程

**AOP思想的实现方案**
动态代理技术，在运行期间，对目标对象的方法进行增强，代理对象同名方法内可
以执行原有逻辑的同时嵌入执行其他增强逻辑或其他对象的方法

**AOP相关概念**

| 概念      | 单词      | 解释                                             |
| --------- | --------- | ------------------------------------------------ |
| 目标对象  | Target    | 被增强的方法所在的对象                           |
| 代理对象  | Proxy     | 对目标对象进行增强后的对象，客户端实际调用的对象 |
| 连接点    | Joinpoint | 目标对象中可以被增强的方法                       |
| 切入点    | Pointcut  | 目标对象中实际被增强的方法                       |
| 通知\增强 | Advice    | 增强部分的代码逻辑                               |
| 切面      | Aspect    | 增强和切入点的组合                               |
| 织入      | Weaving   | 将通知和切入点组合动态组合的过程                 |

### 基于xml配置的AOP

xml方式配置AOP的步骤：
1、导入AOP相关坐标；org.aspectj.aspectjweaver
2、准备目标类、准备通知类，并配置给Spring管理；

 2.1、引入aop的命名空间：`xmlns:aop="http://www.springframework.org/schema/aop"`

`http://www.springframework.org/aop/context http://www.springframework.org/schema/aop/spring-aop.xsd`

3、配置切点表达式（哪些方法被增强）；
4、配置织入（切点被哪些通知方法增强，是前置增强还是后置增强

```xml
<!--aop配置-->
<aop:config>
	<!--配置切点表达式，目的是要指定那些方法被增强-->
    <aop:pointcut id="myPointcut" expression="execution(void net.dpwl.service.impl.UserServiceImpl.show())" />
    <aop:pointcut id="myPointcut1" expression="execution(void net.dpwl.service.impl.UserServiceImpl.show1())" />
    <!--配置织入，目的是要执行那些切点与那些通知进行结合-->
    <aop:aspect ref="myAdvice">
        <!--引用外部的切点-->
    	<aop:before method="beforeAdvice" pointcut-ref="myPointcut"/>
        <!--切点直接配置在织入-->
        <aop:before method="beforeAdvice" pointcut="execution(void net.dpwl.service.impl.UserServiceImpl.show1())"/>
    </aop:aspect>
</aop:config>
```

**xml方式AOP配置详解**
xml配置AOP的方式还是比较简单的，下面看一下AOP详细配置的细节：

1. 切点表达式的配置方式
   可以把切点表达式配置在<aop:aspect>外部通过pointcut-ref引用，也可以直接用pointcut配置切点表达式。（如果一个切点需要配置多个通知，最优是配置在外然后引用）

2. 切点表达式的配置语法
   `execution（[访问修饰符]返回值类型 包名.类名.方法名（参数））`

   访问修饰符可以省略不写；
   返回值类型、某一级包名、类名、方法名可以使用*表示任意；
   包名与类名之间使用单点.表示该包下的类，使用双点表示该包及其子包下的类；
   参数列表可以使用两个点.表示任意参数。

   ```java
   //表示访问修饰符为public、无返回值、在com.itheima.aop包下的rargetImpl类的无参方法show
   execution (public void com.itheima.aop.TargetImpl.show())
   //表述com.itheima.aop包下的TargetImpl类的任意方法
   execution(* com.itheima.aop.TargetImpl.*(..))
   //表示com.itheima.aop包下的任意类的任意方法
   execution(* com.itheima.aop.*.*(..))
   //表示com.itheima.aop包及其子包下的任意类的任意方法
   execution(* com.itheima.aop..*.*(..))
   //表示任意包中的任意类的任意方法
   execution(* *..*.*(..))
   ```

3. 通知的类型
   AspectJ的通知由以下五种类型

   | 通知名称 | 配置方法                | 执行时机                                                 |
   | -------- | ----------------------- | -------------------------------------------------------- |
   | 前置通知 | `<aop:before>`          | 目标方法执行之前执行                                     |
   | 后置通知 | `<aop:after-returning>` | 目标方法执行之后执行，目标方法异常时，不在执行           |
   | 环绕通知 | `<aop:around>`          | 目标方法执行前后执行，目标方法异常时，环绕后方法不在执行 |
   | 异常通知 | `<aop:after-throwing>`  | 目标方法抛出异常时执行                                   |
   | 最终通知 | `<aop:after>`           | 不管目标方法是否有异常，最终都会执行                     |

   ```java
   // 环绕增强通知方法
   public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable{
       System.out.println("环绕前的增强....”");
       Object res=proceedingJoinPoint.proceed();//执行目标方法
       System.out.println("环绕后的增强....");
       return res;
   }
   ```

4. AOP的配置的两种方式
   使用<aspect>配置切面
   使用<advisor>配置切面，需要在通知类实现advice的子接口，来确定是属于增强的类型

```xml
<!--使用advisor-->
<aop:config>
	<aop:pointcut id="myPointcut" expression="execution(void net.dpwl.service.impl.UserServiceImpl.show())" />
	<!--myAdvice2类需要实现advice接口的子接口，确定增强类型-->
    <aop:advisor advice-ref="myAdvice2" pointcut-ref="myPointcut" />
</aop:config>
```

AOP配置的两种语法形式不同点
语法形式不同：
	advisor是通过实现接口来确认通知的类型
	aspect是通过配置确认通知的类型，更加灵活
可配置的切面数量不同：
	一个advisor只能配置一个固定通知和一个切点表达式
	一个aspect可以配置多个通知和多个切点表达式任意组合
使用场景不同：
	允许随意搭配情况下可以使用aspect进行配置
	如果通知类型单一、切面单一的情况下可以使用advisor进行配置
	在通知类型已经固定，不用人为指定通知类型时，可以使用advisor进行配置，例如后面要学习的Spring事务控制的配置

动态代理的实现的选择，在调用getProxy0方法时，我们可选用的AopProxy接口有两个实现类，如上图，这两种都是动态生成代理对象的方式，一种就是基于JDK的，一种是基于Cglib的

| 代理技术          | 使用条件                                                     | 配置方式                                                     |
| ----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| JDK动态代理技术   | 目标类有接口，是基于接口动态生成实现类的代理对象             | 目标类有接口的情况下，默认方式                               |
| Cglib动态代理技术 | 目标类无接口且不能使用final修饰，是基于被代理对象动态生成子对象为代理对象 | 目标类无接口时，默认使用该方式；目标类有接口时，手动配置<aop:config proxy-target-class=“true”>强制使用Cglib方式 |

### 基于注解配置的AOP

Spring的AOP也提供了注解方式配置，使用相应的注解替代之前的xml配置，xml配置AOP时，我们主要配置了三部分：目标类被Spring容器管理、通知类被Spring管理、通知与切点的织入（切面），如下：

 ```java
 //增强类，内部提供增强方法
 @Component
 @Aspect  // aop注解
 public class MyAdvice {
 	//<aop:before method="beforeAdvice" pointcut="execution(* com.itheima.service.impl.*.*(..)" />
     @Before("execution(* com.itheima.service.impl.*.*(..))") //增强类型注解
     public void beforeAdvice(JoinPoint joinPoint){
 		//System.out.printIn("当前目标对象是:"+joinPoint.getTarget());
     	//System.out.printIn("表达式:"+joinPoint.getStaticPart());
    		System.out.println("前置的增强....");
     } 
 }
 ```

```xml
<!--组件扫描-->
<context:component-scan base-package="com.itheima" />

<!--spring的xml配置文件中要配置aop自动代理，注解才能生效-->
<aop:aspectj-autoproxy />
```

![QQ20260120-115955](.\img\QQ20260120-115955.png)

各种注解方式通知类型

```java
// 前置通知
@Before("execution(* com.itheima.service.impl.*.*(..))")
public void before(JoinPoint joinPoint){}
//后置通知
@AfterReturning("execution(* com.itheima.service.impl.*.*(..))")
public void AfterReturning(JoinPoint joinPoint){}
//环绕通知
@Around("execution(* com.itheima.service.impl.*.*(..))")
public void around(ProcceedingJoinPoint joinPoint) throws Throwable{}
//异常通知
@AfterThrowing(pointcut="execution(* com.itheima.service.impl.*.*(..))",throwing="e")
public void AfterThrowing(Throwable e){}
//最终通知
@After("execution(* com.itheima.service.impl.*.*(..))")
public void After(JoinPoint joinPoint){}

// 切点表达式可以抽取出来
@Pointcut("execution(* com.itheima.service.impl.*.*(..))")
public void myPointcut(){}
// 通知引用切点表达式
@Before("MyAdvice.myPointcut()")
public void before(JoinPoint joinPoint){}
```

**配置类替代配置文件**

```java
package net.dpwl.config;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;
@Configuration
@ComponentScan("net.dpwl") //<context:component-scan base-package="net.dpwl" />
@EnableAspectJAutoProxy //<aop:aspectj-autoproxy />
public class SpringConfig{
    
}
// 入口类,使用配置类的方式获取bean
package net.dpwl;
public class ApplicationContext{
    public static void main(String[] args){
        ApplicationContext app = new AnnotationConfigApplicationContext(SpringConfig.class);
        UserService bean = app.getBean(UserService.class);
        bean.show();
    }
}
```

之前在使用xml配置AOP时，是借助的Spring的外部命名空间的加载方式完成的，使用注解配置后，就抛弃了`<aop:config>`标签，而该标签最终加载了名为AspectJAwareAdvisorAutoProxyCreator的BeanPostProcesor，
最终，在该BeanPostProcessor中完成了代理对象的生成。
同样，从aspectj-autoproxy标签的解析器入手

```java
this.registerBeanDefinitionParser("aspectj-autoproxy",new
AspectJAutoProxyBeanDefinitionParser());
```

![QQ20260120-142949](.\img\QQ20260120-142949.png)

### 基于AOP的声明式事务控制

Spring事务编程概述
事务是开发中必不可少的东西，使用JDBC开发时，我们使用connnection对事务进行控制，使用MyBatis时，我们使用SqlSession对事务进行控制，缺点显而易见，当我们切换数据库访问技术时，事务控制的方式总会变化，Spring就将这些技术基础上，提供了统一的控制事务的接口。Spring的事务分为：编程式事务控制和声明式事务控制

| 事务控制方式   | 解释                                                         |
| -------------- | ------------------------------------------------------------ |
| 编程式事务控制 | Spring提供了事务控制的类和方法，使用编码的方式对业务代码进行事务控制，事务控制代码和业务操作代码合到了一起，开发中不使用 |
| 声明式事务控制 | Spring将事务控制的代码封装，对外提供了xml和注解配置方式，通过配置的方式完成事务的控制，可以达到事务控制与业务操作代码解耦合，开发中推荐使用 |

Spring事务编程相关的类主要有如下三个

| 事务控制相关类                           | 解释                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| 平台事务管理器PlatformTransactionManager | 是一个接口标准，实现类都具备事务提交、回滚和获得事务对象的功能，不同持久层框架可能会有不同实现方案 |
| 事务定义TransactionDefinition            | 封装事务的隔离级别、传播行为、过期时间等属性信息             |
| 事务状态TransactionStatus                | 存储当前事务的状态信息，如果事务是否提交、是否回滚、是否有回滚点等 |

虽然编程式事务控制我们不学习，但是编程式事务控制对应的这些类我们需要了解一下，因为我们在通过配置的方式进行声明式事务控制时也会看到这些类的影子

xml方式配置声明式事务

```xml
<!--配置DataSource-->
<bean id="datasource"
class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
    <property name="url"
    value="jdbc:mysql://localhost:3306/mybatis"></property>
    <property name="username"
    value="root"></property>
    <property name="password" value="root"></property>
</bean>
<!--配置sqlSessionFactoryBean,作用将sqlSessionFactory存储到spring容器-->
<bean class="org.mybatis.spring.SqlSessionFactoryBean">
	<property name="dataSource" ref="dataSource"></property>
</bean>
<!--MapperScannerConfigurer，作用扫描指定的包，产生Mapper对象存储到spring容器-->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
	<property name="basePackage" value="com.itheima.mapper"></property>
</bean>
<!--3.配置平台事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
<property name="dataSource" ref="dataSource"/>
</bean>
<!--2.配置Spring提供好的Advice-->
<tx:advice id="txAdvice" transaction-manager="transactionManager">
    <tx:attributes>
        <!--
配置不同的方法的事务属性
name：方法名称  *代表通配符 添加操作addUser，addAccount，addOrders =》add*
isolation：隔离级别，解决事务并发问题
timeout:超时时间 默认-1 无超时时间（单位是秒）
read-only：是否只读 （只能查询操作才设置只读）
propagation:事务的传播行为，解决业务方法调用业务方法（解决事务嵌套问题）
-->
   	 	<tx:method name="*" isolation=“READ_COMMITTED” timeout=“3” />
    </tx:attributes>
</tx:advice>
<!--1.事务增强的aop-->
<aop:config>
	<!--配置切点表达式-->
	<aop:pointcut id="txPointcut" expression="execution(* com.itheima.service.impl.*.*(..))"/>
	<!--配置织入关系通知ladvice-ref引入Spring提供好的Advice-->
	<aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut"/>
</aop:config>
```

isolation属性：指定事务的隔离级别，事务并发存在三大问题：脏读、不可重复读、幻读/虚读。可以通过设置事务的隔离级别来保证并发问题的出现，常用的是READ_COMMITTED和REPEATABLE_READ

| isolation属性    | 解释                                                         |
| ---------------- | ------------------------------------------------------------ |
| DEFAULT          | 默认隔离级别，取决于当前数据库隔离级别，例如MySQL默认隔离级别是REPEATABLE_READ |
| READ_UNCOMMITTED | A事务可以读取到B事务尚未提交的事务记录，不能解决任何并发问题，安全性最低，性能最高 |
| READ_COMMITTED   | A事务只能读取到其他事务已经提交的记录，不能读取到未提交的记录。可以解决脏读问题，但是不能解决不可重复读和幻读 |
| REPEATABLE_READ  | A事务多次从数据库读取某条记录结果一致，可以解决不可重复读，不可以解决幻读 |
| SERIALIZABLE     | 串行化，可以解决任何并发问题，安全性最高，但是性能最低       |

propagation属性：设置事务的传播行为，主要解决是A方法调用B方法时，事务的传播方式问题的，例如：使用单方的事务，还是A和B都使用自己的事务等。事务的传播行为有如下七种属性值可配置

| 事务传播行为      | 解释                                                         |
| ----------------- | ------------------------------------------------------------ |
| REQUIRED(默认值） | A调用B，B需要事务，如果A有事务B就加入A的事务中，如果A没有事务，B就自己创建一个事务 |
| REQUIRED_NEW      | A调用B，B需要新事务，如果A有事务就挂起，B自己创建一个新的事务 |
| SUPPORTS          | A调用B，B有无事务无所谓，A有事务就加入到A事务中，A无事务B就以非事务方式执行 |
| NOT_SUPPORTS      | A调用B，B以无事务方式执行，A如有事务则挂起                   |
| NEVER             | A调用B，B以无事务方式执行，A如有事务则抛出异常               |
| MANDATORY         | A调用B，B要加入A的事务中，如果A无事务就抛出异常              |
| NESTED            | A调用B，B创建一个新事务，A有事务就作为嵌套事务存在，A没事务就以创建的新事务执行 |

注解方式配置声明式事务添加@Transational(isolation="",timeout="",read-only="",propagation="")

xml文件中配置注解驱动

```xml
<!--配置DataSource-->
<bean id="datasource"
class="com.alibaba.druid.pool.DruidDataSource">
    <property name="driverClassName" value="com.mysql.jdbc.Driver"></property>
    <property name="url"
    value="jdbc:mysql://localhost:3306/mybatis"></property>
    <property name="username"
    value="root"></property>
    <property name="password" value="root"></property>
</bean>
<!--配置sqlSessionFactoryBean,作用将sqlSessionFactory存储到spring容器-->
<bean class="org.mybatis.spring.SqlSessionFactoryBean">
	<property name="dataSource" ref="dataSource"></property>
</bean>
<!--MapperScannerConfigurer，作用扫描指定的包，产生Mapper对象存储到spring容器-->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
	<property name="basePackage" value="com.itheima.mapper"></property>
</bean>
<!--配置平台事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
<property name="dataSource" ref="dataSource"/>
</bean>
<!--事务的自动代理（注解驱动）-->
<tx:annotation-driven transaction-manager="transationManager"/>
```

全注解方式

```java
package net.dpwl.config;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;
@Configuration
@ComponentScan("net.dpwl")
@PropertySource("classpath:jdbc.properties")
@MapperScan("net.dpwl.mapper")
@EnableTransactionManager //<tx:annotation-driven transaction-manager="transationManager"/>
public class SpringConfig{
    @Bean
    public DataSource dataSource(
    	@Value("${jdbc.driver}") String driver,
        @Value("${jdbc.url}") String url,
        @Value("${jdbc.username}") String username,
        @Value("${jdbc.password}") String password
    ){
        DruidDataSource dataSource = new DruidDataSource();
        dataSource.setDriverClassName(driver);
        dataSource.setUrl(url);
        dataSource.setUserName(username);
        dataSource.setPassword(password);
        return dataSource;
    }
    @Bean
    public SqlSessionFactoryBean sqlSessionFactoryBean(DataSource dataSource){
        SqlSessionFactoryBean sqlSessionFactoryBean=new SqlSessionFactoryBean();
        sqlSessionFactoryBean.setDataSource(dataSource);
        return sqlSessionFactoryBean;
    }
    
    @Bean
    public DataSourceTransactionManager transactionManager(DataSource dataSource){
        DataSourceTransactionManager dataSourceTransactionManager=new DataSourceTransactionManager();
        dataSourceTransactionManager.setDataSource(dataSource);
        return dataSourceTransactionManager;
    }
}
```

### Spring整合web环境

**Javaweb三大组件及环境特点**

在Java语言范畴内，web层框架都是基于Javaweb基础组件完成的，所以有必要复习一下Javaweb组件的特点

| 组件     | 作用                                           | 特点                                                         |
| -------- | ---------------------------------------------- | ------------------------------------------------------------ |
| Servlet  | 服务端小程序，负责接收客户端请求并作出响应的   | 单例对象，默认第一次访问创建，可以通过配置指定服务器启动就创建，Servlet创建完毕会执行初始化init方法。每个Servlet有一个service方法，每次访问都会执行service方法，但是缺点是一个业务功能就需要配置一个Servlet |
| Filter   | 过滤器，负责对客户端请求进行过滤操作的         | 单例对象，服务器启动时就创建，对象创建完毕执行init方法，对客户端的请求进行过滤，符合要求的放行，不符合要求的直接响应客户端，执行过滤的核心方法doFilter |
| Listener | 监听器，负责对域对象的创建和属性变化进行监听的 | 根据类型和作用不同，又可分为监听域对象创建销毁和域对象属性内容变化的，根据监听的域不同，又可以分为监听Request域的，监听Session域的，监听ServletContext域的 |

**Spring整合web环境的思路及实现**

在进行Java开发时要遵循三层架构+MVC，Spring操作最核心的就是Spring容器，web层需要注入Service，service层需要注入Dao(Mapper)，web层使用Servlet技术充当的话，需要在Servlet中获得Spring容器

```java
AnnotationConfigApplicationContext applicationContext =
new AnnotationConfigApplicationContext(ApplicationContextConfig.class);
AccountService accountService =(AccountService) applicationContext.getBean("accountservice");
accountService.transferMoney("tom","lucy",100);
```

web层代码如果都去编写创建AnnotationConfigApplicationContext的代码，那么配置类重复被加载了，Spring容器也重复被创建了，不能每次想从容器中获得一个Bean都得先创建一次容器，这样肯定是不允许。
所以，我们现在的诉求很简单，如下：

- ApplicationContext创建一次，配置类加载一次；
- 最好web服务器启动时，就执行第1步操作，后续直接从容器中获取Bean使用即可；
- ApplicationContext的引用需要在web层任何位置都可以获取到。

针对以上诉求我们给出解决思路，如下：

- 在ServletContextListener的contextInitialized方法中执行ApplicationContext的创建。或在Servlet的init方法中执行ApplicationContext的创建，并给Servlet的load-on-startup属性一个数字值，确保服务器启动Servlet就创建；
- 将创建好的ApplicationContext存储到ServletContext域中，这样整个web层任何位置就都可以获取到了

**Spring的web开发组件spring-web**

到此，就将一开始的诉求都解决了，当然我们能想到的Spring框架自然也会想到，Spring其实已经为我们定义好了一个ContextLoaderListener，使用方式跟我们上面自己定义的大体一样，但是功能要比我们强百倍，所以，遵循Spring"拿来主义”的精神，我们直接使用Spring提供的就可以了，开发如下：
先导入Spring-web的坐标:

```xml
<dependency>
    <groupid>org.springframework</groupid>
    <artifactId>spring-web</artifactId>
    <version>5.3.7</version>
</dependency>
```

```xml
<!--spring web 配置文件-->
<!--定义全局参数-->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <!--spring配置文件位置-->
    <param-value>classpath:applicationContext.xml</param-value>
</context-param>
<!--配置Listener-->
<listener>
    <listener-class>
        org.springframework.web.context.ContextLoaderListener
    </listener-class>
</listener>
```

```java
// spring-web入口方法
@WebServlet(urlPatterns="/accountServlet")
public class AccountServlet extends HttpServlet{
    proptected void doGet(HttpServletRequest requst,HttpServletResponse response) throws EXception{
        // web层调用service层，获得AccountService，accountService存在applicationContext中
        // 从servletContext域中去获得applicationContext
        ServletContext servletContext = request.getServletContext();
        ApplicationContext app = WebApplicationContextUtils.getWebApplicationContext(servletContext);
        AccountService accountService = app.getBean(AccountService.class);
        //AccountService类的转账方法
        accountService.transferMoney("tom","lucy",500);
    }
}
```

### web层MVC架构思想与设计思路

MVC框架思想及其设计思路
Java程序员在开发一般都是MVC+三层架构，MVC是web开发模式，传统的Javaweb技术栈实现的MVC如下

![QQ20260121-142117](.\img\QQ20260121-142117.png)

原始Javaweb开发中，Servlet充当Controller的角色，Jsp充当View角色，JavaBean充当模型角色，后期Ajax异步流行后，在加上现在前后端分离开发模式成熟后，View就被原始Html+Vue替代。原始Javaweb开发中，Service充当Controller有很多弊端，显而易见的有如下几个：

| Servlet作为Controller的问题                                  | 解决思路和方案                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 个业务功能请求都对应一个Servlet                              | 根据业务模块去划分Controller                                 |
| 每个Servlet的业务操作太繁琐                                  | 将通用的行为，功能进行抽取封装                               |
| Servlet获得Spring容器的组件只能通过客户端代码去获取，不能优雅的整合 | 通过Spring的扩展点，去封装一个框架，从原有的Servlet完全接手过来web层的业务 |

负责共有行为的Servlet称之为前端控制器，负责业务行为的JavaBean称之为控制器Controller

分析前端控制器基本功能如下：
1、具备可以映射到业务Bean的能力
2、具备可以解析请求参数、封装实体等共有功能
3、具备响应视图及响应其他数据的功能

## Spring MVC

**SpringMVC概述**
SpringMVC是一个基于Spring开发的MVC轻量级框架，Spring3.0后发布的组件，SpringMVC和Spring可以无缝整合，使用DispatcherServlet作为前端控制器，且内部提供了处理器映射器、处理器适配器、视图解析器等组件，可以简化JavaBean封装，Json转化、文件上传等操作。
![QQ20260121-143810](.\img\QQ20260121-143810.png)

```xml
<!--WEB-INF/web.xml 配置Spring mvc-->
<!--配盟contextLoaderListener加载扫描Service包的配置-->
<context-param>
    <!--初始化参数，指定spring扫描器配置-->
	<param-name>contextConfigLocation</param-name>
    <param-value>classpath:applicationContext.xml</param-value>
</context-param>
<listener>
	<listener-class>
    org.springframework.web.context.ContextLoaderListener
    <listener-class>
</listener>
        
<!--配置DispatcherServlet-->
<servlet>
	<servlet-name>DispatcherServlet</servlet-name>
	<servlet-class>
        org.springframework.web.servlet.DispatcherServlet
    </servlet-class>
    <!--配置Controller扫描器的配置-->
    <init-param>
    	<param-name>contextConfigLocation</param-name>
    	<param-value>classpath:spring-mvc.xml</param-value>
    </init-param>
</servlet>
<servlet-mapping>
	<servlet-name>DispatcherServlet</servlet-name>
    <!--url转发规则，所有的都转发-->
	<url-pattern>/</url-pattern>
</servlet-mapping>
    
<!--spring—mvc.xml 配置Controller组件扫描-->
<context:component-scan base-package="com.itheima.controller" />
<!--applicationContext.xml 配置Service组件扫描-->
<context:component-scan base-package="com.itheima.service"/>
```

```java
@Controller
public class QuickController{
    //直接注入ServIce进行使用
    @Autowired
    private QuickService quickService;
    
    @RequestMapping ("/show")
    public String show(){
        System.out.println("show running...."+quickService):
   		return "/index.jsp";
    }
    
}
```

上面已经完成的快速入门的操作，也在不知不觉中完成的Spring和SpringMVC的整合，我们只需要按照规则去定义Controller和业务方法就可以。但是在这个过程中，肯定是很多核心功能类参与到其中，这些核心功能类，一般称为组件。当请求到达服务器时，是哪个组件接收的请求，是哪个组件帮我们找到的Controller，是哪个组件帮我们调用的方法，又是哪个组件最终解析的视图？

| 组件                         | 描述                                                         | 常用组件                     |
| ---------------------------- | ------------------------------------------------------------ | ---------------------------- |
| 处理器映射器：HandlerMapping | 匹配映射路径对应的Handler，返回可执行的处理器链对象HandlerExecutionChain对象 | RequestMappingHandlerMapping |
| 处理器适配器：HandlerAdapter | 匹配HandlerExecutionChain对应的适配器进行处理器调用，返回视图模型对象 | RequestMappingHandlerAdapter |
| 视图解析器：ViewResolver     | 对视图模型对象进行解析                                       | InternalResourceViewResolver |

### 请求映射路径的配置

配置映射路径，映射器处理器才能找到Controller的方法资源，目前主流映射路径配置方式就是@RequestMapping

| 相关注解        | 作用                                           | 使用位置   |
| --------------- | ---------------------------------------------- | ---------- |
| @RequestMapping | 设置控制器方法的访问资源路径，可以接收任何请求 | 方法和类上 |
| @GetMapping     | 设置控制器方法的访问资源路径，可以接收GET请求  | 方法和类上 |
| @PostMapping    | 设置控制器方法的访问资源路径，可以接收POST请求 | 方法和类上 |

### 请求参数的获取

`http://localhost/param4?hobby=zq&hobby=pq&hobby=tq`

```java
@GetMapping ("/param4")
// 如果使用集合来封装请求参数必须使用@RequestParam注解
public String param4 (@RequestParam List<String> hobby){
	for (String s : hobby) {
    	System.out.println(s);
    }
    return "/index.jsp";
}
// 使用数组来封装请求参数不用使用注解
public String param3 (String[] hobby){
	for (String s : hobby) {
    	System.out.println(s);
    }
    return "/index.jsp";
}

//http://localhost/param2?username=zhangsan&age=18
@GetMapping ("/param2")
// 如果url中的参数和方法中的参数名不一致，需要使用@RequestParam(url参数名)注解,require 是否必须，如果为true，url中不传就会报错.defaultValue 默认值
// require 默认是false，当参数不传时看数据类型，比如age是int类型不能接收null，所以会报错，通常方法中的参数都是用包装类（Integer)可以解决空值的问题。
public String param2(@RequestParam(value="name",require=true，defaultValue="111")                     String name, int age){
    System.out.println (name+"==="+age);
    return "/index.jsp";
}

@PostMapping("/param7")
//@RequestBody 请求体封装注解，把请求体整个封装给body变量
public String param7(@RequestBody String body){
    System.out.println(body);
    // 使用jackson进行转换，将json格式的字符串转换成User对象
    ObjectMapper objectMapper = new ObjectMapper();
    // 把转换工具配置到spring-mvc的handlerAdapter中可以实现自动转换json
    User user = objectMapper.readValue(body,User.class);
    System.out.println(user);
    return "/index.jsp";
}

@PostMapping("/param8")
//@RequestBody 配置handleAdapter自动转换json到对象
public String param8(@RequestBody User user){
    System.out.println(user);
    return "/index.jsp";
}

// 配置handleAdapter
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
    <property name="messageConverters">
    	<list>
    		<bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter" />
    	</list>
    </property>
</bean>
```

**接收Restful风格数据**
什么是Rest风格?
Rest(Representational StateTransfer)表象化状态转变(表述性状态转变),在20oo年被提出,基于HTTP、URI、xmI、JSON等标准和协议，支持轻量级、跨平台、跨语言的架构设计。是Web服务的一种新网络应用程序的设计风格和开发方式。

Restful风格的请求，常见的规则有如下三点：

1. 用URI表示某个模块资源，资源名称为名词；

   | 模块             | URI资源                  |
   | ---------------- | ------------------------ |
   | 用户模块user     | http://ocalhost/user     |
   | 商品模块 product | http://localhost/product |
   | 账户模块account  | http://localhost/account |
   | 日志模块 log     | http://localhost/log     |

2. 用请求方式表示模块具体业务动作，例如：GET表示查询、POST表示插入、PUT表示更新、DELETE表示删除

   | URI资源                    | 请求方式 | 参数                                                        | 解释                  |
   | -------------------------- | -------- | ----------------------------------------------------------- | --------------------- |
   | http://localhost/user/100  | GET      | 存在URL地址中：100                                          | 查询id=100的User数据  |
   | http://ocalhost/user       | POST     | 存在请求体中Json:("username":"haohao","age":18)             | 插入User数据          |
   | http://localhost/user      | PUT      | 存在请求体中Json：("id":100,"username":"haohao","age":18}   | 修改id=100的User数据  |
   | http://localhost/user/100  | DELETE   | 存在URL地址中：100                                          | 删除id=100的User数据  |
   | http://localhost/product/5 | GET      | 存在URL地址中：5                                            | 查询id=5的Product数据 |
   | http://localhost/product   | POST     | 存在请求体中Json：("proName":"小米手机","price":1299)       | 插入Product数据       |
   | http://localhost/product   | PUT      | 存在请求体中Json:["id":5,"proName":"小米手机","price":1299} | 修改id=5的Product数据 |
   | http://localhost/product/5 | DELETE   | 存在URL地址中：5                                            | 删除id=5的Product数据 |

3. 用HTTP响应状态码表示结果，国内常用的响应包括三部分：状态码、状态信息、响应数据

   ```json
   {
       "code":200,
   	"message":"成功",
   	"data":{
   	"username":"haohao",
   	"age":18
   	}
   }
   {
       "code":300,
   	"message"："执行错误",
   	"data":""
   }
   
   ```

```java
// 获取Restful风格的参数
@GetMapping("/user/{id}/{xxx}")
//Restful风格的参数在url后直接连接，不是键值对的方式就需要使用注解@PathVariable
public String findUserById(
    @PathVariable("id") int id,
    @PathVariable("xxx") String yyy
                          ){
    System.out.println("id==>"+id);
}
```

接收文件上传的数据，文件上传的表单需要一定的要求，如下：

- 表单的提交方式必须是POST
- 表单的enctype属性必须是multipart/form-data
- 文件上传项需要有name属性

```html
<form action="" enctype="multipart/form-data" method="post" >
	<input type="file" name="myFile">
</form>
```

```java
// 获取上传文件数据
@PostMapping("/param10")
// post请求参数在请求体中，所以要使用@RequestBody注解
// 如果上传多个文件使用MultipartFile[] 数组
public String param10(@RequestBody MultipartFile myFile){
    // spring mvc 规定上传文件接收时使用MultipartFile，所以传参时表单的enctype属性必须是multipart/form-data，变量名称和文件上传的name属性一致。spring mvc默认没有开启文件上传的接收，需要手动开启
    // 将上传的文件进行保存
    // 1.获得当前上传的文件的输入流
    InputStream inputStream = myFile.getInputStream();
    // 2.获得上传文件位置的输出流
    OutputStream outputStream = new OutputStream("D:\\upload\\file\\"+myFile.getOriginalFilename());
    // 3.执行文件拷贝
    IOUtils.copy(inputStream,outputStream);
    // 4.关闭流资源
    inputStream.close();
    outputStream.close();
}
```

服务器端，由于映射器适配器需要文件上传解析器，而该解析器默认未被注册，所以手动注册

```xml
<!--配置文件上传解析器，注意：id的名字是固定写法-->
<bean id="multipartResolver"
class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
<property name="defaultEncoding" value="UTF-8"/><!--文件的编码格式默认是ISO8859-1-->
<property name="maxUploadsizePerFile" value="1048576"/> <!--上传的每个文件限制的大小单位字节-->
<property name="maxUploadsize" value="3145728"/><!--上传文件的总大小-->
<property name="maxInMemorySize" value="1048576"/> <!--上传文件的缓存大小-->
</bean>
```

而CommonsMultipartResolver底层使用的Apache的是Common-fileuplad等工具API进行的文件上传

```xml
<dependency>
<groupid>commons-fileupload</groupId>
<artifactId>commons-fileupload</artifactId>
<version>1.4</version>
</dependency>
```

接收Http请求头数据，接收指定名称的请求头

```java
@GetMapping("/headers")
public String headers (@RequestHeader("Accept-Encoding") String acceptEncoding){
	System.out.println("Accept-Encoding:"+acceptEncoding);
    return "/index.jsp";
}
// 接收所有的请求头信息
@GetMapping("/headersMap")
public String headers (@RequestHeader Map<String,String> map){
    map.forEach((k,v)->{
        System.out.println(k+":"+v);
    });	
    return "/index.jsp";
}
```

获得客户端携带的Cookie数据

```java
@GetMapping("/cookies")
public String cookies(@CookieValue(value="JSESSIONID",defaultValue="") String jsessionid){
    System.out.println(jsessionid);
    return "index.jsp";
}
```

获得转发Request域中数据，在进行资源之间转发时，有时需要将一些参数存储到request域中携带给下一个资源

```java
// 模拟转发资源
@GetMapping ("/request1")
// 通过HttpServletRequest和HttpServletRsponse可以获取到底层的Request和Response
public String requestl (HttpServletRequest request,HttpServletResponse response){
    //向request域中存储数据
    request.setAttribute(name:"name",o:"haohao");
    return "/request2";
}
// 获取request域中的数据
@GetMapping ("/request2")
// 使用@RequestAttribute 注解获取域中数据
public String request2 (@RequestAttribute("name") String name){
	System.out.println(name);
}    
```

### 静态资源访问问题

spring-mvc 项目默认情况下在浏览器地址栏输入静态资源的地址会出现找不到资源的问题，因为普通的java web项目由tomcat的defaultServlet来负责解析，它能解析静态资源。而spring-mvc项目配置的DispatcherServlet会覆盖掉tomcat的defaultServlet，但是它没有解析静态资源的能力所以导致静态资源找不到。

解决办法一：在WEB-INF/web.xml配置更精确的匹配配置

```xml
<!--再次激活DefaultServlet url-pattern配置更加精确一点-->
<servlet-mapping>
	<servlet-name>default</servlet-name>
	<url-pattern>*.html</url-pattern><!--根据文件类型匹配，优先级高于通过路径匹配-->
</servlet-mapping>
<servlet-mapping>
	<servlet-name>default</servlet-name>
    <url-pattern>/img/*</url-pattern><!--目录匹配，把匹配路径配置的更精确-->
</servlet-mapping>
```

第二种方式，在spring-mvc.xml中去配置静态资源映射，匹配映射路径的请求到指定的位置去匹配资源

```xml
<!--mappings是映射资源路径，location是对应资源所在的位置-->
<mvc:resources mapping="/img/*" location="/img/" />
<mvc:resources mapping="/css/*" location="/css/" />
<mvc:resources mapping="/css/*" location="/js/" />
<mvc:resources mapping="/html/*" location="/html/" />
```

第三种方式，在spring-mvc.xml中去配置`<mvc:default-servlet-handler>`，该方式是注册了一个DefaultServletHttpRequestHandler处理器，静态资源的访问都由该处理器去处理，这也是开发中使用最多的

```xml
<mvc:default-servlet-handler />
```

注解驱动`<mvc:annotation-driven>`标签

这么复杂繁琐的配置，是不是看上去有点头大？Spring是个”暖男”，将上述配置浓缩成了一个简单的配置标签，那就是mvc的注解驱动,该标签内部会帮我们注册RequestMappingHandlerMapping、注册
RequestMappingHandlerAdapter并注入Json消息转换器等，上述配置就可以简化成如下：

```xml
<!--配置handlerMapping-->
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"></bean>
<!--配置handleAdapter-->
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
    <property name="messageConverters">
    	<list>
    		<bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter" />
    	</list>
    </property>
</bean>
<!--配置mvc的注解驱动，上面的就不用配置了，会自动配置-->
<mvc:annotation-driven />
```

PS:`<mvcannotation-driven>`标签在不同的版本中，帮我们注册的组件不同，Spring3.0.X版本注册是DefaultAnnotationHandlerMapping 和AnnotationMethodHandlerAdapter,由于框架的发展,从Spring 3.1.X开始注册组件变为 RequestMappingHandlerMapping和RequestMappingHandlerAdapter

### Spring MVC的响应处理

**传统同步业务数据响应**
Spring的接收请求的部分我们讲完了，下面在看一下Spring怎么给客户端响应数据，响应数据主要分为两大部分：

- 传统同步方式：准备好模型数据，在跳转到执行页面进行展示，此方式使用越来越少了，基于历史原因，一些旧项目还在使用；
- 前后端分离异步方式：前端使用Ajax技术+Restful风格与服务端进行Json格式为主的数据交互，目前市场上几乎都是此种方式了。

传统同步业务在数据响应时，SpringMVC又涉及如下四种形式：

- 请求资源转发；使用forward: 关键字，可以省略不写

- 请求资源重定向；使用redirect: 关键字

- 响应模型数据；

  ```java
  @RequestMapping("/res3")
  public ModelAndView res3(ModelAndView modelAndView){
      // ModelAndView封装模型数据和视图名
      // 设置模型数据
      User user = new User();
      user.setUsername("lj");
      user.setAge(18);
      modelAndView.addObject("user",user);    
      // 设置视图名称，在页面中展示模型数据
      modelAndView.setViewName("/user.jsp");
  }
  
  // user.jsp
  <%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
  <head>
  <title>Title</title>
  </head>
  <body>
  <h1>Hello SpringMVC!</h1>
  <h1>转发显示的模型数据是：${user.username}--${user.age}</h1>
  </body>
  </html>
  ```

- 直接回写数据给客户端；

  ```java
  // 直接返回字符串
  @RequestMapping("/res4")
  @ResponseBody //加上此注解，告诉springmvc返回的字符串不是视图名，是以响应体方式响应的数据
  public String res4(){
     return "hello spring mvc"; // 默认，会报错，这不到这个名称的视图
  }
  ```

  

![QQ20260122-155329](.\img\QQ20260122-155329.png)

**前后端分离异步业务数据响应**
其实此处的回写数据，跟上面回写数据给客户端的语法方式一样，只不过有如下一些区别：

- 同步方式回写数据，是将数据响应给浏览器进行页面展示的，而异步方式回写数据一般是回写给Ajax引擎的，即谁访问服务器端，服务器端就将数据响应给谁
- 同步方式回写的数据，一般就是一些无特定格式的字符串，而异步方式回写的数据大多是Json格式字符串

```java
@GetMapping("/ajax/req3")
@ResponseBody
public User res3(){
    User user = new User();
    user.setUsername("haohao");
	user.setAge(20);
    return user; // 返回会自动把User实体转成json
}
// 如果方法很多的情况下，都是使用json返回可以把@ResponseBody提到类上
// 如果是Restful风格前后端分离开发，可以把@Controller和@ResponseBody两个注解合并成@RestController
```

### Spring mvc的拦截器

拦截器Interceptor简介
SpringMVC的拦截器Interceptor规范，主要是对Controller资源访问时进行拦截操作的技术，当然拦截后可以进行权限控制，功能增强等都是可以的。拦截器有点类似Javaweb开发中的Filter，拦截器与Filter的区别如下图：

![QQ20260122-163257](.\img\QQ20260122-163257.png)

由上图,对Filter和Interceptor 做个对比:

|               | Fiter技术                                              | Interceptor技术                                             |
| ------------- | ------------------------------------------------------ | ----------------------------------------------------------- |
| 技术范畴      | Javaweb原生技术                                        | SpringMVC框架技术                                           |
| 拦截/过滤资源 | 可以对所有请求都过滤，包括任何servlet、Jsp、其他资源等 | 只对进入了SpringMVc管辖范围的才拦截，主要拦截Controller请求 |
| 执行时机      | 早于任何Servlet执行                                    | 晚于DispatcherServlet执行                                   |

HandlerInterceptor接口方法的作用及其参数、返回值详解如下：

|                 | 作用                                                         | 参数                                                         | 返回值                                                       |
| --------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| preHandle       | 对拦截到的请求进行预处理，返回true放行执行处理器方法，false不放行 | Handler是拦截到的Controller方法处理器                        | 一旦返回false，代表终止向后执行，所有后置方法都不执行，最终方法只执行对应preHandle返回了true的 |
| postHandle      | 在处理器的方法执行后，对拦截到的请求进行后处理，可以在方法中对模型数据和视图进行修改 | Handler是拦截到的Controller方法处理器;modelAndView是返回的模型视图对象 | 无                                                           |
| afterCompletion | 视图渲染完成后（整个流程结束之后），进行最后的处理，如果请求流程中有异常，可以处理异常对象 | Handler是拦截到的Controller方法处理器；ex是异常对象          | 无                                                           |

```java
// 拦截器测试接口实现
public class MyInterceptor1 implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("MyInterceptor1.....preHandle");
        return true; //是否放行，true放行
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("MyInterceptor1....postHandle");;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("MyInterceptor1..afterCompletion");
    }
}
```

```xml
<!--配置拦截器-->
<mvc:interceptors>
    <mvc:interceptor>
    <!--对哪些请求路径进行拦截-->
    <mvc:mapping path="/**"/> <!--/*只拦截一级的，/**拦截所有请求-->
    	<bean class="net.dpwl.webapi.interceptors.MyInterceptor1"></bean>
    </mvc:interceptor>
</mvc:interceptors>
```

**拦截器执行顺序**
拦截器三个方法的执行顺序
当每个拦截器都是放行状态时，三个方法的执行顺序如下：

![QQ20260122-171336](.\img\QQ20260122-171336.png)

当Interceptor1和Interceptor2处于放行，Interceptor3处于不放行时，三个方法的执行顺序如下：

![QQ20260122-171806](.\img\QQ20260122-171806.png)

### Spring MVC的全注解开发

**Spring-MVC.xml中组件转化为注解形式**
`<mvc:annotation-driven>`、`<mvc:default-servlet-handler />`和`<mvc:interceptor >`怎么办呢?SpringMVC 提供了一个注解@EnableWebMvc,我们看一下源码,内部通过@Import导入了DelegatingWebMvcConfiguration类

```java
package net.dpwl.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.multipart.commons.CommonsMultipartResolver;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2026/1/26 11:21
 */
@Configuration  // 1.配置类
@ComponentScan("net.dpwl.controller") // 2.扫描controller包
@EnableWebMvc //4.开启WebMvc配置,配置mvc相关的bean
public class SpringMVCConfig {
    // 3.配置非自定义的bena，配置文件上传解析器
    @Bean
    public CommonsMultipartResolver multipartResolver() {
        CommonsMultipartResolver multipartResolver = new CommonsMultipartResolver();
        multipartResolver.setDefaultEncoding("UTF-8");
        multipartResolver.setMaxUploadSize(1024 * 1024 * 10);
        return multipartResolver;
    }
}

```

```java
package net.dpwl.controller;

import net.dpwl.interceptors.MyInterceptor;
import org.springframework.stereotype.Component;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2026/1/26 11:40
 */
@Component  //@ComponentScan("net.dpwl.controller")会自动扫描本包所以会自动执行本类，达到自动加载重新静态资源处理和拦截器的方法。
public class WebMVCConfigurer  implements WebMvcConfigurer {
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        // 开启默认的servlet处理,将静态资源的请求转发给默认的servlet处理
        configurer.enable();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 注册自定义的拦截器,并指定拦截的路径
        registry.addInterceptor(new MyInterceptor()).addPathPatterns("/**");
    }
}

```



**DispatcherServlet加载核心配置类**

现在是使用SpringMVCConfig核心配置类提替代的spring-mvc.xml,怎么加载呢？参照Spring的
ContextLoaderListener加载核心配置类的做法，定义了一个AnnotationConfigWebApplicationContext,通过代码注册核心配置类

```java
package net.dpwl.config;

import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2026/1/26 11:51
 */
public class MyAnnotationConfigWebApplicationContext extends AnnotationConfigWebApplicationContext {
    public MyAnnotationConfigWebApplicationContext() {
        // 注册SpringMVCConfig配置类，从而加载spring组件扫描
        super.register(SpringMVCConfig.class);
    }
}

```

```xml
<!--web.xml 文件修改spring mvc核心配置文件为加载核心配置类-->
<!-- 配置DispatcherServlet -->
    <servlet>
        <servlet-name>DispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <!--初始化参数，加载Springmvc的配置文件，从而加载spring组件扫描-->
<!--            <param-name>contextConfigLocation</param-name>-->
<!--            <param-value>classpath:springmvc.xml</param-value>-->
<!--加载spring mvc的核心配置类 -->
            <param-name>contextClass</param-name>
            <param-value>net.dpwl.config.MyAnnotationConfigWebApplicationContext</param-value>
        </init-param>
    </servlet>
```

**消除web.xml**

Servlet3.0环境中,web容器提供了javax.servlet.ServletContainerlnitializer接口,实现了该接口后,在对应的类加载路径的META-INF/services目录创建一个名为javax.servlet.ServletContainerlnitializer的文件，文件内容指定具体的ServletContainerlnitializer实现类，那么，当web容器启动时就会运行这个初始化器做
一些组件内的初始化工作；
基于这个特性,Spring就定义了一个SpringServletContainerInitializer实现了ServletContainerInitializer接口;
而SpringServletContainerlnitializer会查找实现了WebApplicationInitializer的类，Spring又提供了一个WebApplicationInitializer的基础实现类AbstractAnnotationConfigDispatcherServletInitializer,当我们编写类继承AbstractAnnotationConfigDispatcherServletInitializer时,容器就会自动发现我们自己的类，
在该类中我们就可以配置Spring和SpringMVC的入口了。

```java
package net.dpwl.init;

import net.dpwl.config.SpringConfig;
import net.dpwl.config.SpringMVCConfig;
import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2026/1/26 14:25
 */
public class MyAbstractAnnotationConfigDispatcherServletInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
//    提供spring容器的核心配置类
    protected Class<?>[] getRootConfigClasses() {
        return new Class[]{SpringConfig.class};
    }

    @Override
//    提供springmvc容器的核心配置类
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{SpringMVCConfig.class};
    }

    @Override
//    提供springmvc容器的映射路径
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
// META-INF/services目录下创建文件javax.servlet.ServletContainerInitializer
// 放入初始化类的名称：MyAbstractAnnotationConfigDispatcherServletInitializer
```

### 前端控制器初始化

前端控制器DispatcherServlet是SpringMVC的入口，也是SpringMVC的大脑，主流程的工作都是在此完成的，梳理一下DispatcherServlet 代码。DispatcherServlet 本质是个Servlet,当配置了load-on-startup时,会在服务器启动时就执行创建和执行初始化init方法，每次请求都会执行service方法DispatcherServlet的初始化主要做了两件事：

- 获得了一个SpringMVC 的ApplicationContext容器；
- 注册了SpringMVC的九大组件。

### 前端控制器执行主流程

![QQ20260126-154011](.\img\QQ20260126-154011.png)

### Spring mvc的异常处理机制

SpringMVC异常的处理流程
异常分为编译时异常和运行时异常，编译时异常我们try-cache进行捕获，捕获后自行处理，而运行时异常是不可预期的，就需要规范编码来避免。在SpringMVC中，不管是编译异常还是运行时异常，都可以最终由SpringMVC提供的异常处理器进行统一处理，这样就避免了随时随地捕获处理的繁琐性。
当然除了繁琐之外，我们在进行前后端分离异步开发时，往往返回统一格式的结果给客户端，例如：
{"code":200,"message":"","data":{"username":"haohao","age":null},即使报异常了,也不能把状态码500直接扔给客户端丢给用户，需要将异常转换成符合上面格式的数据响应给客户端更友好。

SpringMVC处理异常的思路是，一路向上抛，都抛给前端控制器DispatcherServlet，DispatcherServlet在调用异常处理器ExceptionResolver进行处理，如下图：

![QQ20260126-170213](.\img\QQ20260126-170213.png)

SpringMVC提供了以下三种处理异常的方式：

- 简单异常处理器：使用SpringMVC内置的异常处理器处理SimpleMappingExceptionResolver;

  ```java
  // 配置简单的异常处理类
      @Bean
      public SimpleMappingExceptionResolver simpleMappingExceptionResolver() {
          SimpleMappingExceptionResolver resolver = new SimpleMappingExceptionResolver();
          // 不管是什么异常，统一的响应一个友好页面
          resolver.setDefaultErrorView("/error.html");
          Properties mappings = new Properties(); // 配置异常类型和视图的映射关系
          mappings.setProperty("java.lang.RuntimeException", "/error.html"); //key 异常类型，value 视图名称
  //        区分异常类型，根据不同的异常类型，可以跳转不同的视图
          resolver.setExceptionMappings(mappings);
          return resolver;
      }
  ```

- 自定义异常处理器：实现HandlerExceptionResolver接口，自定义异常进行处理；

  ```java
  package net.dpwl.config;
  
  import org.springframework.web.servlet.HandlerExceptionResolver;
  import org.springframework.web.servlet.ModelAndView;
  
  import javax.servlet.http.HttpServletRequest;
  import javax.servlet.http.HttpServletResponse;
  import java.io.IOException;
  
  /**
   * @author 混江龙
   * @version 1.0
   * @time 2026/1/26 17:29
   */
  public class MyHandlerExceptionResolver implements HandlerExceptionResolver {
      @Override
      public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) {
          ModelAndView view = new ModelAndView();
          view.setViewName("/error.html");
  //  前后端分离开发，响应json格式的字符串{“code”:0,"msg":"error"}
          String resultJson="{“code”:0,\"msg\":\"error\"}";
          try {
              httpServletResponse.getWriter().write(resultJson);
          } catch (IOException ex) {
              throw new RuntimeException(ex);
          }
          return null;
      }
  }
  
  ```

- 注解方式:使用@ControllerAdvice +@ExceptionHandler来处理。

```java
package net.dpwl.config;

import com.sun.net.httpserver.Authenticator;
import net.dpwl.pojo.Result;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import java.io.IOException;

/**
 * @author 混江龙
 * @version 1.0
 * @time 2026/1/28 15:20
 */
public class GlobalExceptionHandler {

    @ExceptionHandler(value=RuntimeException.class)
    public ModelAndView runtimeExceptionResolverMethod(RuntimeException e) {
        System.out.println(e.getMessage());
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("/error.html");
        return modelAndView;
    }


    @ExceptionHandler(value=IOException.class)
    @ResponseBody
    public Result ioExceptionResolverMethod(IOException e) {
        System.out.println(e.getMessage());
        Result result = new Result();
        result.setCode(500);
        result.setMsg("io异常");
        return result;
    }

}
```

### SpringMVC常用的异常解析器

| 接口或类                          | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| HandlerExceptionResolver          | 异常处理器类的顶级接口，实现了该接口的类都会作为异常处理器类 |
| MyHandlerExceptionResolver        | 自定义的处理器类，实现了HandlerExceptionResolver接口         |
| HandlerExceptionResolverComposite | 异常解析器混合器，内部存在集合存储多种异常解析器             |
| SimpleMappingExceptionResolver    | 简单映射异常处理器，可以配置异常与对应的错误视图             |
| ExceptionHandlerExceptionResolver | 异常处理器异常解析器，默认会被注册到Spring容器中，@ExceptionHandler方式异常处理就是该解析器解析的 |
| DefaultHandlerExceptionResolver   | 默认处理器异常解析器，所有异常处理器都不匹配时，最后执行的异常处理器 |
| ResponseStatusExceptionResolver   | 响应状态异常解析器，结合使用@ResponseStatus标注的异常使用    |

## Spring Boot

spring boot项目发布，通过maven打包`package`，然后把打好的jar包上传到服务器，通过运行命令`java -jar 网站包.jar`就可以运行起来web项目。

配置文件优先级：

当同目录下有多个配置文件，就以.Properties为主

外部约定配置文件加载顺序：
springboot启动还会扫描以下位置的application.properties或者application.ym文件作为Spring boot的默认配置文件（从低到高）：

1. classpath（即resources文件夹下）根目录下的
2. classpath根config/
3. 项目根目录
4. 项目根目录/config
5. 直接子目录/config（直接子目录：命令行上运行`java -jar XXX.jar --spring.config.location=D:\config/ `命令指定的目录）

2-5
