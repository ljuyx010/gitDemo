# JAVA学习笔记

##   java介绍

1990年 sun公司启动绿色计划

1992年 创建oak（橡树）语言-->java

1994 gosling 参加硅谷大会演示java功能，震惊世界

1995 sun正式发布java第一个版本。

2009年，甲骨文公司宣布收购sun，2011，发布java7

java其他版本：https://www.oracle.com/cn/java/technologies/downloads/

java技术体系平台

**java SE（java Standard Edition）标准版**

支持面向桌面级应用，提供完整的java核心api，此版本之前称为J2SE

**Java EE(java Enterprise Edition)企业版**

是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如：servlet，jsp等，主要针对web应用程序开发，版本以前称为J2EE

**java ME（java Micro Edition）小型版**

支持java程序运行在移动终端（手机，pad）上的平台，对java api有所精简，并加入针对移动终端的支持，此版本以前称为J2ME

java 重要特点

1. java语言是面向对象的（oop）
2. java语言是健壮的，java的强类型机制，异常处理，垃圾的自动收集等是java程序健壮性的重要保证
3. java语言是跨平台型的
4. java语言是解释型的
   解释型语言：JavaScript，PHP，java 编译型语言：c /c++
   区别是：解释型语言，编译后的代码，不能直接被机器执行，需要解释器来执行，编译型语言，编译后的代码，可以直接被机器执行。

JVM java虚拟机是java跨平台的关键。

`javac`命令编译java文件为class文件   `java`命令运行编译后的class文件

JDK java开发工具包 JDK = JRE+java开发工具

JRE java运行环境  JRE = JVM + java的核心类库

java11 中午api文档：https://www.apiref.com/java11-zh/index.html

## java快速入门

`public static void main(String[] args)`表示一个主方法，即程序的入口。

`;`表示一段语句的结束

`javac Hello.java`文件名和类名一致，类名首字母应该大写

`java Hello` 运行java文件实际是运行hello这个类，所以不能写`java Hello.class`这样写系统会去找Hello.class这个类，肯定是找不到的，所以会报错。

一个文件中只能有一个public 类，其他类的个数不限。每一个类编译后都对应生成一个class文件

## 转义字符

`\t`一个制表位，实现对齐的功能

`\n` 换行符

`\\` 一个\

`\"`一个"

`\'`一个‘

`\r` 一个回车，回车和换行的区别：回车后光标移到第一的位置并不换行，如果有输出则会覆盖原来的内容，换行则在下一行输出。回车+换行 的效果 = 换行

## 注释

单行注释  //注释文字

多行注释  /*  注释文字  */

文档注释 /**  

  		*/

文档注释可以生成一套文档网页文件，

生成命令：`javadoc -d 文件夹名 -author -version Demo.java`

-author -version 为注释的作者，版本或参数等注释信息

## 变量

变量的使用步骤：

1. 声明变量 int a
2. 赋值变量 a = 60
3. 使用变量  System.out.println(a)

也可以简化直接一步到位：int a = 60

## +号的使用

程序中+号的使用

1. 当左右两边都是数值型时，则做加法运算
2. 当左右两侧有一方为字符串，则做拼接运算

## 数据类型

### 基本数据类型

数值型

| 整数类型 | 数据空间（字节） | 数据范围                                                     |
| -------- | ---------------- | ------------------------------------------------------------ |
| byte     | 1                | -128 到 127                                                  |
| short    | 2                | -2¹⁵ 到 (2¹⁵ - 1)<br />-32,768 到 32,767                     |
| int      | 4                | -2³¹ 到 (2³¹ - 1)<br />-2,147,483,648 到 2,147,483,647大约 ±21亿 |
| long     | 8                | -2⁶³ 到 (2⁶³ - 1)<br />long bigNumber = 9223372036854775807L; // 必须加L |

| 浮点类型 | 数据空间（字节） | 数据范围                                                     |
| -------- | ---------------- | ------------------------------------------------------------ |
| float    | 4                | ±3.40282347E+38F (6-7 位有效小数位)<br/>小数默认是双精度如果声明单精数，具体值结尾必须带f（float a = 1.2f） |
| double   | 8                | ±1.79769313486231570E+308 (15 位有效小数位)                  |

浮点数 = 符号位+指数位+尾数位（尾数部分可能丢失，造成精度损失，小数都是近似值）

**浮点数使用陷阱：8.1/3 = 2.69999997 当我们对运算结果是小数的结果进行相等判断时，要小心。**通常用两个数的差值小于某个精度就认为相等，如果两个数是没有结果计算的小数是可以直接判断是否相等的。

| 字符型 | 数据空间（字节） | 数据范围        |
| ------ | ---------------- | --------------- |
| char   | 2                | 单个字符例：'a' |

'a'是char类型，"a"则是String类型

字符型 + 数字 = 字符对应的unicode码 + 数字

ascII是0--127 共128个字符

| 布尔型  | 数据空间（字节） | 数据范围   |
| ------- | ---------------- | ---------- |
| boolean | 1                | true/false |

不可以用0或非0的整数替代false和true。

### 基本数据类型的转换

#### 自动类型转换

当java程序在进行赋值或运算时，精度小的类型自动转换为精度大的数据类型，这个就是自动类型转换。

数据类型按精度大小（容量）排序如下：

char--》int---》long--》float---》double

byte--》short---》int---》long---》float---》double

```java
int a = 'a'; // 字符赋值给int是可以的
double b = 80; // 整型赋值给双精度也是可以的
```

自动类型转换的细节：

1. 有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。
2. 当我们把精度大的数据类型赋值给精度小的数据类型时，就会报错，反之就会自动类型转换。
3. byte，short 和char之间不会相互自动转换，三者可以混合计算，在计算时首先转换成int类型。
4. boolean不参与自动类型转换
5. 自动提升原则：表达式结果的类型自动提升为操作数中最大的类型

#### 强制类型转换

自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型，使用时要加上强制转换符`()`，但可能造成精度降低或者溢出，格外要注意。

注意细节：

强转符号只对最近的操作数有效，往往会使用小括号提升优先级

```java
int x = (int)10*3.5+6*1.5 // 错误，只转换了10，并不是转换整个结果
int x = (int)(10*3.5+6*1.5) //正确，这样才转换整个的结果
```

char类型可以保存int的常量值，但不能保存int的变量值，需要强转

```java
char c1 = 100; // ok,保存100对应的unicode码
int m = 100;
char c2 = m;  // 不行，会报类型不一致的错误
char c3 = (char)m; //ok
```

byte，short和char类型在进行运算时，当做int类型处理。

- 基本数据类型转string类型，`+ ""`即可。
- string类型转基本数据类型，通过基本类型的包装类调用`parseXX`方法记录。`Interger.parseInt("123")`
- 把字符串转成字符char：`a = "123"; b = a.charAt(0)`，只能取字符串中的某一个字符。

string类型转基本数据类型的注意事项：

1. 将string转基本数据类型时，要确保string类型能够转成有效的数据，比如我们可以把“123”，转成一个整数，但是不能把“hello”转成整数。
2. 如果格式不正确，就会抛出异常，程序就会终止，这个问题在异常处理章节中，会处理

### 引用数据类型

类 class

接口 interface

数组 [ ]

## 运算符

### 算术运算符

| 运算符 | 运算                                             | 范例                      | 结果                |
| ------ | ------------------------------------------------ | ------------------------- | ------------------- |
| +      | 正号                                             | +7                        | 7                   |
| -      | 负号                                             | b=11;-b                   | -11                 |
| +      | 加                                               | 9+9                       | 18                  |
| -      | 减                                               | 10-8                      | 2                   |
| *      | 乘                                               | 7*8                       | 56                  |
| /      | 除                                               | 9/3                       | 3                   |
| %      | 取模（取余）                                     | 11%9                      | 2                   |
| ++     | 自增(前):先运算后取值<br />自增(后):先取值后运算 | a=2;b=++a;<br/>a=2;c=a++; | a=3;b=3<br/>a=3;c=2 |
| --     | 自减(前):先运算后取值<br />自减(后):先取值后运算 | a=2;b=--a;<br/>a=2;c=a--; | a=1;b=1<br/>a=1;c=2 |
| +      | 字符串相加                                       | "java"+"kc"               | "javakc"            |

```java
-10.5%3 = -1.5
// float 求余的公式：a%b = a - (int)a/b*b
//-10.5 -(-10)/3*3 =》-10.5-（-3*3）=》-10.5+9=》-1.5

System.out.println(10/4); //从数学来看是2.5 java结果为2 因为两个int运算结果为int
System.out.println(10.0/4) //结果为2.5 double除int结果为double
```

取模的公式：`a % b = a-(int)a/b*b`

自增自减如果独立使用，i++ 和 ++i是一样的，如果作为表达式使用则不同。

```java
int i =1;
i=i++;
System.out.println(i);
//结果是多少? i = i++赋值时会使用临时变量
//使用临时变量规则1.temp = i 2.i++ 3.i=temp
// 所以应该输出 1

int i =1;
i=++i;  //先计算再赋值，1.i=i+1 2.temp=i 3.i= temp
System.out.println(i); //结果就是2
```

print()和println()的区别，带ln的会自动换行

### 关系运算符

关系运算符的结果都是boolen型，关系表达式经常用在if结构的条件中或循环结构的条件中。

| 运算符     | 运算               | 范例                    | 结果  |
| ---------- | ------------------ | ----------------------- | ----- |
| ==         | 相等于             | 8==7                    | false |
| !=         | 不等于             | 8!=7                    | true  |
| <          | 小于               | 8<7                     | false |
| >          | 大于               | 8>7                     | true  |
| <=         | 小于等于           | 8<=7                    | false |
| >=         | 大于等于           | 8>=7                    | true  |
| instanceof | 检查是否是类的对象 | "abc" instanceof String | true  |

### 逻辑运算符

用于连接多个条件（多个关系表达式），最终的结果也是一个boolen值。

1. 短路与 ：&&(当a和b同时为true，则为true，否则为false)
   短路或：||(当a和b有一个为true，则为true，否则为false)
   取反：!
2. 逻辑与：&(当a和b同时为true，则为true，否则为false)
   逻辑或：|(当a和b有一个为true，则为true，否则为false)
   逻辑异或：^（当a和b不同时，为true，否则为false）

| a     | b     | a&b   | a&&b  | a\|b  | a\|\|b | !a    | a^b   |
| ----- | ----- | ----- | ----- | ----- | ------ | ----- | ----- |
| true  | true  | true  | true  | true  | true   | false | false |
| true  | false | false | false | true  | true   | false | true  |
| false | true  | false | false | true  | true   | true  | true  |
| false | false | false | false | false | false  | true  | false |

&& 和&使用区别

1. &&短路与：如果第一个条件为false，则第二个条件不会判断，最终结果为false，效率高
2. &逻辑与：不管第一个条件是否为false，第二个条件都要判断，效率低
3. 开发中，我们使用的基本都是短路与&&，效率高

||和|使用区别

1. ||短路或：如果第一个条件为ture，则第二个添加不会判断，最终结果为true，效率高
2. 逻辑或：不管第一个条件是否为true，第二个条件都要判断，效率低
3. 开发中，我们基本使用||

### 赋值运算符

赋值运算符就是将某个运算后的值，赋给指定的变量。

复合赋值运算符：+= 、-+、*=、 /= 、%=

a += b  ==> a = a + b

赋值运算符特点

1. 运算顺序从右往左 `int num = a+b+c;`先计算a+b+c再赋值。
2. 赋值运算符的左边只能是变量，右边可以是变量，表达式，常量
3. 复合赋值运算符等价于下面的效果
   比如：a -= 3; 等价于 a = a -3;
4. 复合赋值预算法会进行类型转换
   byte b = 2; b +=3; b++;  此时b += 3 ==》b = (byte)(b+3)会进行类型转换把b+3的结果转换成byte。
   byte b = 2; b = b + 3; 则会直接报错，因为b的类型为byte,b+3的结果是int，会报类型不兼容类型的错误。

### 三元运算符

条件表达式 ？表达式1 ：表达式2;

如果条件表达式为true，运算后的结果是表达式1；

如果条件表达式为false，运算后的结果是表达式2；

注意细节：

表达式1和表达式2要为可以赋给接收变量的类型（或可以自动转换或者强制转换）

### 运算符的优先级

|         | .  ()  {}  ;  ,                        |
| ------- | -------------------------------------- |
| R --> L | ++  --  ~   !(data type)               |
| L-->R   | *  /  %                                |
| L-->R   | + -                                    |
| L-->R   | <<(左位移)   >>(右位移)  >>>(逻辑右移) |
| L-->R   | <  >  <=  >=  instanceof               |
| L-->R   | ==  !=                                 |
| L-->R   | &                                      |
| L-->R   | ^                                      |
| L-->R   | \|                                     |
| L-->R   | &&                                     |
| L-->R   | \|\|                                   |
| L-->R   | ?   :                                  |
| R-->L   | = *=  /=  %=                           |
| R-->L   | +=   -=   <<=   >>=                    |
| R-->L   | >>>=  &=   ^=  \|=                     |

运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如上表，上一行运算符总优先于下一行。

只有单目运算符，赋值运算符是从右向左运算的。
运算符优先级顺序分类：

1. （）{} ，等
2. 单目运算 ++   --
3. 算术运算符
4. 位移运算符
5. 比较运算符
6. 逻辑运算符
7. 三元运算符
8. 赋值运算符

### 标识符规则

java对各种变量，方法和类等命名时使用的字符序列称为标识符

凡是自己可以起名字的地方都叫标识符

标识符的命名规则（必须遵守）

1. 由26个英文字母大小写，0-9，_或$组成
2. 数字不可以开头
3. 不可以使用关键字和保留字，但能包含关键字和保留字
4. java中严格区分大小写，长度无限制
5. 标识符不能包含空格

标识符命名规范【更加专业】

1. 包名：多单词组成时所有字母都小写
2. 类名\接口名：多单词组成时，所有单词的首字母大写【大驼峰】
3. 变量名\方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写【小驼峰，简称驼峰法】
4. 常量名：所有字母都大写。多单词时每个单词用下划线连接
5. 后面我们学习到类，包，接口等时，我们的命名规范要这样遵守，更加详细的看文档。

### 键盘输入

接收用户输入的数据，就可以使用键盘输入语句获取，键盘输入需要一个扫描器（对象），就是Scanner。

步骤：
1.导入该类的所在包，java.util.*

2.创建该类的对象

3.调用里面的功能

```java
import java.until.Scanner;//Scanner类 表示简单文本扫描器
public class Input{
    public staic void main(String[] args){
        //创建一个Scanner对象
        Scanner myScanner = new Scanner(System.in);
        System.out.println("请输入名字");
        String name = mySacnner.next(); //接收用户输入字符串
        System.out.println("请输入年龄");
        int name = mySacnner.nextInt(); //接收用户输入int
        System.out.println("请输入薪水");
        double salary = mySacnner.nextDouble(); //接收用户输入double
    }
}

```

### 进制

对于整数，有四种表示方式：

1.二进制：0,1 满2进1，以0b或0B开头。

2.十进制：0-9，满10进1.

3.八进制：0-7，满8进1，以数字0开头表示。

4.十六进制：0-9及A(10)-F(15)，满16进1.以0x或0X开头表示。此处的A-F不区分大小写。

二、八、十六进制转十进制：位数上的值X进制的(位数-1)次方然后相加的和

十进制转二、八、十六进制：十进制数不断除以要转的进制，得到每次的余数，直到商为0为止，然后将每步的余数倒过来就是对应的进制数。

二进制转八进制：从低位开始，将二进制数每三位一组，转成对应的八进制即可。

二进制转十六进制：从低位开始，将二进制数每四位一组，转成对应的十六进制即可。

八进制转二进制：将八进制数每1位转成对应的一个3位的二进制数即可。

十六进制转二进制：将十六进制数每1位转成对应的一个4位的二进制数即可。

### 原码、反码、补码

1. 二进制的最高位是符号位：0表示正数，1表示负数
2. 正数的原码，反码、补码都一样(三码合一)
3. 负数的反码 = 它的原码符号位不变，其他位取反
4. 负数的补码 = 它的反码+1，负数的反码 = 负数的补码 -1
5. 0的反码，补码都是0
6. java没有无符号数，换言之，java中的数都是有符号的
7. 在计算机运算的时候，都是以**补码的方式来运算**的
8. 当我们看运算结果的时候，要看他的原码

### 位运算符

java中有7个位运算（&、|、^、~、>>、<<、>>>）

&按位与运算规则：两位全为1，结果为1，否则为0

|按位或运算规则：两位有一个为1，结果为1，否则为0

^按位异或运算规则：两位一个为0一个为1，结果为1，否则为0

~按位取反运算规则：0变1，1变0

\>>算术右移：低位溢出，符号位不变，并用符号位补溢出的高位（本质就是>>1就是除以2只取整数部分）

<<算术左移：符号位不变，低位补0（本质就是<<1就是乘以2）

\>\>>逻辑右移也叫无符号右移，运算规则是：低位溢出，高位补0

特别说明：没有<<<符号

## 控制结构

### 分支控制

#### 单分支

if(条件表达式){

​	执行代码块

}

#### 双分支

if(条件表达式){

​	执行代码块1

}else{

​	执行代码块2

}

#### 多分支

if(条件表达式1){

​	执行代码块1

}else if(条件表达式2){

​	执行代码块2

}...

else{

​	执行代码块n

}

多分支可以没有else

#### 嵌套分支

一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支结构称为内层分支，外面的分支结构称为外层分支。规范：不要超过3层

if(){

​	if(){

​	}else{

​	}

}

#### switch分支结构

switch(表达式){

​	case 常量1：

​		语句块1;

​		break;

​	case 常量2：

​		语句块2;

​		break;

​	....

​	case 常量n：

​		语句块n;

​		break;

​	default:
​		default语句块;

​		break;

}

switch注意事项：

1. 表达式数据类型应和case后的常量**类型一致**，或者是可以自动转成可以相互比较的类型
2. swtich(表达式)中表达式的返回值必须是：byte，short，int，char，enum(枚举)，String中的一种
3. case子句中的值必须是常量或者常量表达式，不能是变量
4. default子句是可选的，当没有匹配的case时，执行default
5. break语句用来在执行完一个case分支后使程序跳出switch语句块，如果没有写break，程序会顺序执行到switch结尾，除非遇到break。

### 循环控制

#### for循环

for(循环变量初始化;循环条件;循环变量迭代){

​	循环操作（语句）;

}

注意事项：

1. 循环添加是返回一个布尔值的表达式

2. for(;循环判断条件;)中的初始化和变量迭代可以写到其他地方，但是两边的分号不能省略。
   ```java
   for(;;){
       //表示一个死循环，可以配合break;完成特殊功能
   }
   ```

   

3. 循环初始值可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开，循环变量迭代也可以有多条变量迭代语句，中间用逗号隔开

   

#### while循环

循环变量初始化;

while(循环条件){

​	循环体（语句）;

​	循环变量迭代;

}

while循环是先判断再执行

#### do..while循环

循环变量初始化;

do{

​	循环体（语句）;

​	循环变量迭代;

}while(循环条件);

说明：do while是关键字

也有循环四要素，只是位置不一样

先执行，后判断，也就是说，一定会执行一次

最后又一个分号;

#### 多重循环控制

将一个循环放在另一个循环体内就形成了嵌套循环。其中for，while，do..while均可作为外层循环和内层循环。

实质上嵌套循环就是把内层循环当成外层循环的循环体，当只有内层循环的循环添加为false时，才会跳出内层循环，才可结束外层的当次循环，开始下一次的循环

当外层循环次数为m次，内层为n次，则内层循环实际上需要执行m*n次。

#### 跳转控制语句break

循环，但是循环的次数不知道，当某个条件满足时，可以通过break终止循环。

注意事项：

break语句出现在多层嵌套的语句块中时，可以通过标签指明要终止的是那一层语句块。

```java
lable1:
for(int j=0;j<4;j++){
    lable2:
    for(int i=0;i<10;i++){
        if(i==2){
            // 通过lable指定退出哪层循环
            break lable1;
        }
        System.out.println("i="+i);
    }
}
```

没有指定标签，break默认退出最近的循环体。

#### 跳转控制语句continue

continue语句用于结束本次循环，继续执行下一次循环。

continue语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是那一层循环，和break的标签使用规则一样。

#### 跳转控制语句return

return使用在方法中，表示跳出所在的方法。如果return写在main方法，会退出程序。

## 数组、排序、查找

#### 数组

数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。即：数组就是一组数据

```java
// 1.静态初始化
double[] array = {3,5,1,3.4,2,50} //double 类型的数组
//2.动态初始化
int a[] = new int[3] //表示定义一个int数组a，存放3个int类型是数
int = {1,2,3};
//3.动态初始化2
int a[] //先声明数组
a = new int[]{2,3,4}; //再创建数组 new 就是分配空间
//或者只创建数据空间不赋值
a = new int[2];

```

数组注意事项：

1. 数组元素是相同数据类型或可以自动数据转换
2. 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。
3. 数组创建后，如果没有赋值，会默认值int 0，short 0，byte 0，long 0，float 0.0，double 0.0，char \u0000，boolean false，String null
4. 使用数组的步骤：声明数组并开辟空间》给数组各个元素赋值》使用数组
5. 数组的下标是从0开始的
6. 数组下标必须在指定范围内使用，否则报：下标越界异常，比如int[] arr=new int[5];有效下标为0-4
7. 数组属引用类型，数字型数据是对象（object）



#### 数组赋值机制 

基本数据类型赋值，赋值方式为值拷贝，相互不影响。

数组在默认情况下是引用传递，赋的值是内存地址。

```java
int[] arr1 = {10,20,30};
int[] arr2 = arr1;
arr2[0] = 40;
System.out.println(arr1[0]);
//因为arr2是引用的arr1的地址，改变arr2后arr1[0]会变成40
```

数组的拷贝

```java
int[] arr1 = {10,20,30};
int[] arr2 = new int[arr1.length];
for(i=0;i<arr1.length;i++){
    arr2[i] = arr1[i];
}
arr2[0] = 40;
//此时为数组拷贝，改变arr2[0]的值，不影响arr1
```

数组添加

```java
int[] arr = {1,2,3};
//给数字添加元素使用其他语言的arr[3]=4这种方法是不行的
//应该使用下面的方法
int[] arrNew = new int[arr.length+1];
//遍历arr数组，依次将元素拷贝得arrNew数组
for(int i=0;i<arr.length;i++){
    arrNew[i] = arr[i];
}
//把4赋给arrNew最后一个元素 
arrNew[arrNew.length-1] = 4;
//让arr指向arrNew
arr = arrNew;
```

#### 排序

排序是将多个数据，依指定的顺序进行排列的过程。

1.内部排序
将需要处理的所有数据都加载到内存中进行排序。包括（交换式排序法、旋转式排序法和插入式排序法）

2.外部排序

数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括（合并排序法和直接合并排序法）

冒泡排序实例

```java
int[] arr ={24,69,80,57,13};
//外层循环控制循环轮数
for(int i=arr.length-1;i>0;i--){
    //内层循环每轮的次数
    for(int j=0; j<i; j++){
        if(arr[j]>arr[j+1]){
            temp=arr[j];
            arr[j]=arr[j+1];
            arr[j+1]=temp;
        }
    }
}

```

字符串的比较使用`equals()`函数

```java
String a = "金毛狮王";
if(a.equals("白眉鹰王")){
    System.out.print('字符串一样');
}else{
    System.out.print('字符串不一样');
}
```

#### 二维数组

int\[][] 来标识二维数组

```java
int[][] arr = {{0,0,0,0,0},{0,1,0,0,0},{2,0,3,0,0}};
//遍历二维数组
for(int i=0;i<arr.length;i++){
    for(int j=0;j<arr[i].length;j++){
        System.out.print(arr[i][j]+" ");
    }
    System.out.println();
}
```

二维数组动态初始化

```java
int arr[][] = new int[2][3];
arr[1][1] = 8;
int arr[][] = new int[3][];//定义一个二维数组，一维数组的元素数不一样多，这种二维数组称为列数不等的二维数组。
```

打印杨辉三角

```java
int[][] yang = new int[10][];
//生成杨辉三角
for(int i=0;i<yang.length;i++){
    yang[i] = new int[i+1];给每个一维数组开空间
    for(int j=0;j<yang[i].length;j++){
        if(j==0 || j ==yang[i].length -1){
            //每一行的第一个元素和最后一个元素都是1
            yang[i][j] = 1;
        }else{
            //中间元素是上一行同列和上一行同列的前一位的和
            yang[i][j] = yang[i-1][j]+yang[i-1][j-1];
        }
    }
}
//输出杨辉三角
for(int i=0;i<yang.length;i++){
    for(int j=0;j<yang[i].length;j++){
        System.out.print(yang[i][j]+"\t");
    }
    System.out.println();
}
```

二维数组的三种声明方式：

```java
int[][] arr;
int[] arr[];
int arr[][];
```

## 类与对象

对象在内存中的存在形式如下图：（类是引用数据类型）

![2025-09-18_222833](.\img\2025-09-18_222833.png)

类的属性也叫成员变量。属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型（对象，数组）。

注意事项：

1.属性的定义语法同变量，示例：访问修饰符 属性类型 属性名;

2.属性的定义类型可以为任意类型，包含基本类型或引用类型
默认值int 0，short 0，byte 0，long 0，float 0.0，double 0.0，char \u0000，boolean false，String null

3.属性如果不赋值，有默认值，规则和数组一致。

### 创建对象

1.先声明再创建

```java
Cat cat; //声明对象
cat = new Cat();   //创建 
```

2.直接创建

```java
Cat cat = new Cat();
```

访问属性：对象名.属性名

### 类和对象的内存分配机制

```java
Person p = new Person();
p.age = 10;
Person p1 = p;
// p1指向 p对象对应的内存地址
```

java内存的结构分析：
1.栈：一般存放基本数据类型（局部变量）

2.堆：存放对象（Cat cat，数组等）

3.方法区：常量池（常量，比如字符串），类加载信息

创建对象的流程：

1.先加载Person类信息（属性，方法，只会加载一次）

2.在堆中分配空间，进行默认初始化，吧堆的内存地址赋给p

3.进行指定初始化，如 p.age = 10 

### 成员方法

```java
class Person{
    String name;
    int age;
    //public 表示方法是公开的
    //void 表示方法没有返回值（如果有返回值就写返回值的类型）
    //speak 方法名
    //() 形参列表  括号空，表示没有传入参数
    //{ } 方法体，写要执行的代码
    // 方法写好后，不调用（使用），不会执行（输出 ）
    public void speak(){
        System.out.println("我是一个好人");
    }
}
```

![2025-09-19_215307](.\img\2025-09-19_215307.png)

方法调用小结：

1.当程序执行到方法时，就会开辟一个独立的空间（栈空间）

2.当方法执行完毕，或者执行到return语句时，就会返回

3.放回到调用方法的地方，返回后继续执行方法后面的代码

成员方法的优势：

1.提高代码的复用性

2.可以将实现的细节封装起来，然后供其他用户来调用即可。

**方法的注意事项：**

- 访问修饰符：（作用是控制方法使用的范围）可选，有四种public，protected，default(默认的，可以不写)，private。

- 返回数据类型

1.一个方法最多有一个返回值。

2.返回类型可以为任意类型，包含基本类型或引用类型

3.如果方法要求有返回数据类型，则方法体中最后的执行语句必须有return值，而且要求返回值类型和return的值类型一致或兼容

4.如果方法是void，则方法体中可以没有return语句，或者只写return

- 方法名：遵循驼峰命名法，最好见名知意。
- 形参列表

1.一个方法可以有0个参数，也可以有多个参数，中间用逗号分隔

2.参数类型可以是任意类型，包含基本类型或引用类型

3.调用到参数的方法时，一定对应着参数列表传入相同类型或兼容类型的参数

4.方法定义是的参数称为形式参数，简称形参，方法调用时的参数称为实际参数，简称实参，实参和形参的类型要一致或兼容，个数，顺序必须一致

- 方法体

里面写完成功能的具体语句，可以为输入，输出，变量，运算，分支，循环，方法调用，但是不能再定义方法，即方法不能嵌套定义。

- 方法调用

1.同一个类中的方法调用，直接调用即可

2.跨类中的方法A类调用B类方法：需要通过对象名调用

3.特别说明一下：跨类的方法调用和方法的访问修饰符相关。

### 成员方法传参机制

基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参

引用类型传递的是内存地址，可以通过形参影响实参。

如果引用类型传递给方法，方法内的变量改变(新的引用不是改变引用类型的值)则不会改变引用类型的数据（即方法内变量指向的引用类型的内存地址改变了，指向了新的地址，所以原来的引用数据不受影响）。

### 递归调用

递归规则：

1. 执行一个方法时，就创建一个新的受保护的独立空间（栈空间）
2. 方法的局部变量（基础数据类型）是独立的，不会相互影响
3. 如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据
4. 递归必须向退出递归的添加逼近，否则就是无限递归，出现StackOverflowError，死归了
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。

### 方法重载OverLoad

java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致！

重载的好处：

1.减轻起名的麻烦

2.减轻记名的麻烦

重载的注意事项：

1.方法名：必须相同

2.形参列表：必须不同（形参类型或个数或顺序，至少一个不同，实参名无要求）

3.返回类型：无要求

### 可变参数

java运行将同一个类中多个同名同功能但参数个数不同的方法，封装成一个方法。就可以通过可变参数实现

基本语法：访问修饰符 返回类型 方法名(数据类型**...** 形参名){ }

```java
class HspMethod{
    //需求可以计算2个数，3个数，4,5个数的和
    //可以通过方法重载实现
    public int sum(int n1,int n2){
        return n1+n2;
    }
    
    public int sum(int n1,int n2,int n3){
        return n1+n2+n3;
    }

    public int sum(int n1,int n2,int n3,int n4){
        return n1+n2+n3+n4;
    }
    //方法重载还是不方便，对于上面三个方法，方法名相同，功能相同，参数个数不同可以使用可变参数优化
    public int sum(int... nums){
        //int... 表示接受的是可变参数，类型是int，即可以接受多个int（0或多），使用可变参数是，可以当做数组来使用，即nums可以当做数组
        int res = 0;
        for(int i=0;i<nums.length;i++){
            res += nums[i];
        }
        return res;
    }
}
```

可变参数的注意事项：

1. 可变参数的实参可以为0个或多个。
2. 可变参数的实参可以是数组。
3. 可变参数的本质就是数组。
4. 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
5. 一个形参列表中只能出现一个可变参数

### 变量作用域

在java编程中，主要的变量就是属性（成员变量）和局部变量。

我们说的局部变量一般是指在成员方法中定义的变量

java中作用域的分类：

- 全局变量：也就是属性，作用域是整个类
- 局部变量：也就是除了属性之外的其他变量，作用域为定义它的代码块中

全局变量可以不赋值，直接使用，因为有默认值，局部变量必须赋值后，才能使用，因为没有默认值。

作用域注意事项：

1. 属性和局部变量可以重名，访问时遵循就近原则
2. 同一个作用域中，比如在同一个成员方法中，两个局部变量不能重名
3. 属性生命周期较长，伴随着对象的创建而创建，伴随着对象的销毁而销毁。局部变量，生命周期较短，伴随着它的代码块的执行而创建，伴随着代码块的结束而销毁。即在一次方法调用过程中。
4. 作用域范围不同
   全局变量：可以被本类使用，或其他类使用（通过对象调用）
   局部变量：只能在本类的方法中使用
5. 修饰符不同
   全局变量/属性可以加修饰符
   局部变量不可以加修饰符 

### 构造方法/构造器

构造方法又叫构造器（constructor），是类的一种特殊的方法，它的主要作用是完成对新对象的属性初始化。

基本语法

修饰符 方法名(形参列表){	方法体;  }

说明：

1. 构造器的修饰符可以默认，也可以是public protected private
2. 构造器没有返回值，也不能写void
3. 方法名和类名必须一样
4. 参数列表和成员方法一样的规则
5. 构造器的调用，由系统来完成

构造器的注意事项：

1. 一个类可以定义多个不同的构造器，即构造器重载
2. 构造器名和类名要相同
3. 构造器没有返回值
4. 构造器是完成对象的初始化，并不是创建对象
5. 在创建对象时，系统自动的调用该类的构造方法
6. 如果没有定义构造器，系统会自动给类生成一个默认无参构造方法（也叫默认构造器 ）
7. 一旦定义了直接的构造器，默认的构造器就覆盖了，就不嗯给你再使用默认的无参构造器，除非显示的定义一下。

完成对象初始化的步骤：

1.默认初始化2.属性的显式初始化3.构造器的初始化4.把对象在堆中的地址返回给对象的引用

### this关键字

java虚拟机会给每个对象分配this，代表当前对象。

```java
class Dog{
    String name;
    int age;
    //构造方法
    public Dog(String name,int age){
        //this 就是当前对象，this.name就是当前对象的name
        this.name = name;
        this.age = age;
    }
}
```

简单的说那个对象调用，this就代表那个对象。

this的注意事项：

1. this关键字可以用来访问本类的属性，方法，构造器
2. this用于区分当前类的属性和局部变量
3. 访问成员方法的语法：this.方法名(参数列表);
4. 访问构造器的语法：this(参数列表); 注意只能在构造器中使用（即只能在构造器中访问另外一个构造器，并且this构造器必须放在构造器的第一条语句）
5. this不能再类定义的外部使用，只能在类定义的方法中使用。

## 面向对象编程

### 包

包有三大作用：

1.区分相同名字的类

2.当类很多时，可以很好的管理类

3.控制访问范围

包基本语法： package 包名;   package 关键字，表示打包

包的本质：实际上就是创建不同的文件夹/目录来保存类文件。

包的命名规则：

只能包含数字，字母，下划线，小圆点，但不能用数字开头，不能是关键字或保留字

命名规范：一般是小写字母+小圆点。一般是com.公司名.项目名.业务模块名

java中常用的包：

java.lang.*   //lang包是基本包，默认引入，不需要再引入

java.util.* 	//util包，系统提供的工具包，工具类

java.net.*	//网络包，网络开发

java.awt.*	//是做java的界面开发，GUI

**引入包**

语法： import 包;

我们引入一个包的主要目的是要使用该包下的类

比如 import java.util.Scanner; 就只是引入一个类Scanner

import java.util.*;  表示将java.util包下所有的类都引入（推荐使用单独引入）

包的注意事项：

1.package 的作用是声明当前类所在的包，需要放在类的class的最上面，一个类中最多只有一句package

2.import指令 位置放在package的下面，在类定义前面，可以有多句且没有顺序要求。

```java
package com.dpwl.web.model;
// package 声明当前类的位置
import java.util.Arrays;
// 引用其他包下的类
public class Model {
    static void main() {
        int[] ints = new int[4];
        ints = new int[]{1, 5, 8, -1};
        Arrays.sort(ints);
    }
}
```

### 访问修饰符

java提供四种访问控制修饰符号，用于控制方法和属性的访问权限。

1.公开级别：用public修饰，对外公开

2.受保护级别：用protected修饰，对子类和同一个包中的类公开

3.默认级别：没有修饰符号，向同一个包的类公开。

4.私有级别：用private修饰，只有类本身可以访问，不对外公开。

4中访问修饰符的访问范围

| 访问级别 | 修饰符    | 本类 | 同包 | 子类 | 不同包 |
| -------- | --------- | ---- | ---- | ---- | ------ |
| 公开     | public    | √    | √    | √    | √      |
| 受保护   | protected | √    | √    | √    | ×      |
| 默认     | 无        | √    | √    | ×    | ×      |
| 私有     | private   | √    | ×    | ×    | ×      |

修饰符注意事项

1. 修饰符可以用来修饰类中的属性,成员方法以及类
2. 只有默认的和public才能修饰类,并且遵循上述范围权限的特点
3. 关于在子类中的访问权限,学习继承再讲
4. 成员方法的访问规则和属性完全一样

面向对象编程的三大特点:

封装,继承和多态

### 封装

封装(ensapsulation)就是把抽象出的数据[属性]和对数据的操作[方法]封装在一起,数据被保护在内部,程序的其他部分只有通过被授权的操作[方法],才能对数据进行操作.

封装的好处:1.隐藏实现细节 2.可以对数据进行验证,保证安全合理.

封装的实现步骤

1. 将属性进行私有化private [不能直接修改属性]
2. 提供一个公共的set方法,用于对属性判断并赋值
3. 提供一个公共的get方法,用于获取属性的值.

### 继承

继承可以解决代码服用,让我妈的边陲更加靠近人类思维,当多个类存在相同的属性和方法是,可以从这些类中抽象出父类,在父类中定义这些相同的属性和方法,所有的子类不需要重新定义这些属性和方法,只需要通过extends来声明继承父类即可.

继承的基本语法:

class 子类 extends 父类{}

1. 子类就会自动拥有父类定义的属性和方法
2. 父类又叫超类,基类
3. 子类又叫派生类

继承的好处:1.代码复用性提高了 2.代码的扩展性和维护性提高了

继承的注意事项:

1. 子类继承了所有的属性和方法,非私有的属性和方法可以在子类直接访问,但是私有属性和方法不能在子类直接访问,要通过父类提供公共的方法去访问
2. 子类必须调用父类的构造器,完成父类的初始化
3. 当创建子类对象时,不管使用子类的那个构造器,默认情况下总会去调用父类的无参构造器,如果父类没有提供无参构造器,则必须在子类的构造器中用super去指定使用父类的那个构造器完成对分类的初始化工作,否则,编译不会通过.

4. 如果希望指定去调用父类的某个构造器，则显式的调用一下：super(参数列表);
5. super在使用时，需要放在构造器第一行(super只能在构造器中使用)
6. super()和this()`this()用于指定本类的构造方法`都只能放在构造器第一行，隐藏这两个方法不能共存在一个构造器
7. java所有类都是Object类的子类，Object是所有类的子类
8. 父类构造器的调用不限于直接父类！将一直往上追溯直到Object类。
9. 子类最多只能继承一个父类（指直接继承），即java中是单继承机制，如何让A类继承B类和C类？（A继承B，B继承C）
10. 不能滥用继承，子类和父类直接必须满足is-a（是个XX的）的逻辑关系

继承在内存中的布局：

![2025-09-25_223238](.\img\2025-09-25_223238.png)

继承关系中如何访问属性？

要按照查找关系：1.首先看子类是否有该属性2.如果子类有这个属性，并且可以访问，则返回信息3.如果子类没有这个属性，就看父类有每一这个属性（如果父类有该属性并且可以访问，就返回信息，没有继续往上找直到Object）

#### super关键字

super代表父类的引用，用于访问父类的属性，方法，构造器。

基本语法：

1.访问父类的属性，但不能访问父类的private属性：`super.属性名`;

2.访问父类的方法，但不能访问父类的private方法：`super.方法名(参数列表)`;

3.访问父类的构造器：`super(参数列表);`只能放在构造器的第一句，只能出现一次。

super的细节：

1.调用父类的构造器的好处（分工明确，父类属性由父类初始化，子类的属性由子类初始化）

2.当子类中有和父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super。如果没有重名，使用super、this、直接访问是一样的效果。

3.super的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用super去访问爷爷类的成员；如果多个基类中都有同名的成员，使用super访问遵循**就近原则**。A->B->C(当然也要遵循权限的相关规则，如果访问的直接父类有对应的属性或方法，但是权限是私有的，那么程序会直接报错，不会再往上级去找。)

super和this的比较

| 区别点     | this                                                   | super                                    |
| ---------- | ------------------------------------------------------ | ---------------------------------------- |
| 访问属性   | 访问本类中的属性，如果本类没有此属性则从父类中继续查找 | 从父类开始查找属性                       |
| 调用方法   | 访问本类中的方法，如果本类没有此方法则从父类继续查找   | 从父类开始查找方法                       |
| 调用构造器 | 调用本类构造器，必须放在构造器的首行                   | 调用父类构造器，不行放在子类构造器的首行 |
| 特殊       | 表示当前对象                                           | 子类中访问父类对象                       |

#### 方法重写/覆盖（override）

方法覆盖（重写）就是子类有一个方法，和父类的某个方法的**名称，返回类型，参数**一样，那么我们就说子类的这个方法覆盖了父类的方法。（不一定是直接父类的方法） 

注意事项：

方法重写，需要满足一下的条件

1. 子类的方法的参数，方法名称要和父类方法的参数，名称完全一样。
2. 字符方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类，比如父类返回类型是Object，子类方法返回类型是String
3. 自乐方法不能缩小父类方法的访问权限

重写和重载的比较

| 名称     | 重载（overload）             | 重写（override）                                     |
| -------- | ---------------------------- | ---------------------------------------------------- |
| 发生范围 | 本类                         | 父子类                                               |
| 方法名   | 必须一样                     | 必须一样                                             |
| 参数列表 | 类型，个数或顺序至少一个不同 | 必须一样                                             |
| 返回类型 | 无要求                       | 子类重写的方法返回类型和父类返回的类型一致或是其子类 |
| 修饰符   | 无要求                       | 不能缩小父类的权限范围                               |

### 多态

方法或对象具有多种形态，是面向对象的第三大特征，多态是建立在封装和继承继承之上的。

1.方法的多态。重写和重载就体现多态

2.对象的多态

- 一个对象的编译类型和运行类型可以不一致
- 编译类型在定义对象时，就确定了，不能改变
- 运行类型的可以变化的
- 编译类型看定义时=号的左边，运行类型看=号的右边

```java
Animal animal = new Dog();
//Dog()是Animal()的子类（animal可以接受子类的对象），此时变量的编译类型是Animal运行类型是Dog，体现了一个对象的编译类型和运行类型可以不一致。
animal = new Cat();
//animal从Dog类通过重新赋值变成Cat类，体现了运行类型是可以变化的。
```

多态的注意事项：

多态的前提是：两个对象(类)存在继承关系

多态的向上转型

1. 向上转型本质：父类的引用指向了子类的对象（子类向上转型成父类）

2. 语法： 父类类型   引用名 = new 子类类型();

3. 向上转型特点：编译类型看左边（声明），运行类型看右边（创建的具体对象）。可以调用父类中的所有成员（需遵守访问权限），不能调用子类中特有成员（因为声明是父类类型，父类中没有子类特有的成员，所以编译通不过）；最终运行效果看子类的具体事项（运行时看实际的创建类型，找创建类型的方法，找不到就往父类上找）。

多态的向下转型

1. 语法：子类类型 引用名 = （子类类型）父类引用;
2. 只能强转父类的引用，不能强转父类的对象
3. 要求父类的引用必须指向的是当前目标类型的对象
4. 当向下转型后可以调用子类类型中所有的成员。

```java
Animal animal = new Cat();
// Cat类中有个独特的方法catchMouse()；因为向上转型了所有此时直接使用animal.catchMouse()；方法编译通不过
//可以先使用向下转型，就可以使用独特方法了，向下转型的前提条件是这个创建的对象和向下转型的声明是同一个类。
Cat cat = （Cat）animal; //上面animal实际创建的就是Cat类，所以可以向下转型成Cat。
cat.catchMouse();
```

属性没有重写之说，属性的值看编译类型。

```java
class Base{ int count = 10;}
class Sub extends Base{ int count = 20；}
Base base = new Sub(); //此时Sub()向上转型
System.out.print(base.count); //输出10，因为属性只看声明类型，直接去声明的类中找。base声明是Base类，Base类的count属性是10
```

instanceOf 比较操作符，用于判断**对象的运行类型**是否为XX类型或XX类型的子类型。

#### 动态绑定机制

当调用对象方法的时候，该方法会和该对象的内存地址/运行类型绑定

当调用对象属性时，没有动态绑定机制，哪里声明，哪里使用

```java
//案例分析
class A{
    public int i = 10;
    public int sum(){
        return getI()+10;
    }
    public int sum1(){
        return i+10;
    }
    public int getI(){
        return i;
    }
}
class B extends A{
    public int i = 20;
    public int sum(){
        return i+20;
    }    
    public int getI(){
        return i;
    }
    public int sum1(){
        return i+10;
    }
}
A a = new B(); //向上转型
System.out.println(a.sum()); //运行B类中的方法40
//如果注释掉B类中的sum()方法此时该输出什么？
//分析：B类中没有sum()方法，此时会向父类查找，找到sum()方法运行
//A类的sum()方法中又调用getI()方法，那此时是调用A类的getI()还是B类的getI()呢?
//根据动态绑定原则，该对象的方法会和运行类型绑定，所以应该调用的是B类的getI()方法，所以结果是30，如果B类中没有getI(),则又遵循继承机制找父类中的getI();
System.out.println(a.sum1()); //30
//如果注释掉B类中的sum1(),同理找到父类A的sum1(), sum1(){i+10;} i是属性不动态绑定，所以此时的i就是A类的属性i = 10;结果就是20
```

#### 多态的应用

1.多态数组

数组的定义类型为父类类型，里面保存的实际元素类型为子类类型

```java
//父类class Person
//两个子类class Student和class Teacher,创建一个父类数组，元素包含1个父类，各两个子类
Person[] person = new Person[5];
person[0] = new Person("jack",20);
person[1] = new Studnet("marry",20,90);
person[2] = new Student("smith",18,30.1);
person[3] = new Teacher("scott",30,18000);
person[4] = new Teacher("kong",50,25000);
//调用各自独特的方法
for(i=0;i<person.length;i++){
    if(person[i] instanceof Studnet){ //判断运行类型是否是Studnet
        ((Student)person[i]).study(); //向下转型并执行study()方法
    }else if(person[i] instanceof Teacher){
        ((Teacher)person[i]).teach();
    }
}
```

2.多态参数

方法定义的形参类型为父类类型，实参类型运行为子类类型

```java
//主人类
class Master{
    public void feed(Animal animal,Food food){
        System.out.println("主人正在喂"+animal.getName()+food.getName());
    }
}
//Cat继承Animal，bone继承Food
feed(Cat cat, Bone bone);
```

### Object类详解

#### equals()方法

判断两个对象是否相等，equals 和 ==（比较运算符）的区别

1. ==：既可以判断基本类型，又可以判断引用类型
2. ==：如果判断基本类型，判断的是值是否相等。
3. ==：如果判断引用类型，判断的是地址是否相等，即判断是不是同一个对象。
4. equals：是Object类中的方法，只能判断引用类型。
5. 默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。

```java
integer a = new integer(100);
integer b = new integer(100);
System.out.println(a == b);  // false a和b不是同一个对象
System.out.println(a.equals(b)); //True a和b两个对象的值相等
```

#### hashCode()方法

返回对象的哈希码值，支持此方法是为了提高哈希表的性能。

1. 提供具有哈希结构的容器的效率
2. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的。
3. 两个引用，如果指向的是不同的对象，则哈希值是不一样的
4. 哈希值主要根据地址号来的！，不能完全将哈希值等价于地址。
5. 后面在集合中，hashCode如果需要的话，也会重写

#### toString()方法

默认返回：类的  全类名（包名+类名）+@+哈希值的十六进制

子类往往重写toString方法，用于返回对象的属性信息

重写toString方法，打印对象或拼接对象时，都会自动调用该对象的toString形式

```java
@Override //重写toString方法，idea 快捷键ctrl+insert， 选toString
public String toString() {
    return "Monster{" +
        "name='" + name + '\'' +
        ", job='" + job + '\'' +
        ", salary=" + salary +
        '}';
}
```

当直接输出一个对象时，toString方法会被默认的调用

#### finalize()方法

当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。

1. 当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作
2. 什么时候被回收：当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来销毁该对象，在销毁该对象前，会先调用finalize方法。
3. 垃圾回收机制的调用，是由系统来决定，也可以通过System.gc()主动触发垃圾回收机制

### 断点调试（debug）

断点调试是指在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。进行分析从而找到这个bug

断点调试的快捷键

F7(跳入)：跳入方法内

F8(跳过)：逐行执行代码

shift+F8(跳出)：跳出方法

F9(resume)：执行到下一个断点



### 类变量/静态变量

类变量也叫静态变量/静态属性，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的都是相同的值，统一任何一个该类的对象去修改它时，修改的也是同一个变量。

定义语法

访问修饰符 static 数据类型 变量名; [推荐]

static 访问修饰符 数据类型 变量名;

访问类变量

类名.类变量名  或者  对象名.类变量名;

注意事项：

1. 什么时候需要用类变量

   当我们需要让某个类的所有对象都共享一个变量时，就可以考虑使用类变量（静态变量）

2. 类变量与实例变量（普通属性）区别
   类变量是该类的所有对象共享的，而实例变量是每个对象独享的。

3. 加上static称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量

4. 类变量可以通过类名.l类变量名  或者对象名.类变量名来访问，java设计者推荐我们使用 类名.类变量名方式访问。【前提是满足修饰符的访问权限】

5. 实例变量不能通过 类名.类变量名 方式访问

6. 类变量是在类加载是就初始化了，也就是说，即使你没有创建对象，只要类加载了，就可以使用类变量了

7. 类变量的生命周期是随类的加载开始，随着类消亡而消毁。

### 类方法/静态方法

访问修饰符 static 数据返回类型 方法名(){ }   [推荐]

static 访问修饰符 数据返回类型 方法名(){ } 

类方法的调用：类名.类方法名  或者  对象名.类方法名

类方法的使用场景：

当方法中不设计到任何和对象相关的成员，则可以将方法设计成静态方法，提高开发效率。（如果我们希望不创建实例，也可以使用某个方法，即当做工具来使用，这时，把方法做成静态方法非常合适）

类方法注意事项：

1. 类方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区：类方法中无this的参数，普通方法中隐含着this的参数
2. 类方法可以通过类名调用，也可以通过对象名调用
3. 普通方法和对象有关，需要通过对象名调用，比如对象名.方法名(参数)，不能通过类名调用。
4. 类方法中不允许使用和对象有关的关键字，比如this和super，普通方法（成员方法）可以
5. 类方法（静态方法）中只能访问静态变量或静态方法
6. 普通成员方法，既可以访问普通变量(方法)，也可以访问静态变量（方法）。

小结：静态方法，只能访问静态的成员，非静态的方法，可以访问静态成员和非静态成员，但必须遵守修饰符访问权限范围。

### 理解main方法

```java
//语法
public static void main(String[] args){}
```

1.main方法是java虚拟机调用的。

2.java虚拟机需要调用类的main()方法，所以改方法的访问权限必须是public

3.java虚拟机在执行main()方法时不必创建对象，所以该方法必须是static

4.该方法接收String类型的数组参数，该数组中保存执行java命令时传递给所允许的类的参数

5.当java虚拟机执行程序时，用户可以在命令行传入(参数1 参数2 参数3) 参数。

注意细节：

1.再main()方法中，我们可以直接调用main方法所在类的静态方法或静态属性。

2.但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员。

### 代码块

代码化块又称为初始化块，属于类中的成员（即 是类的一部分，），类似于方法，将逻辑语句封装在方法体中，通过{ }包围起来。

但和方法不同，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用。

基本语法：

`[修饰符]{ 代码 };`

注意：

1. 修饰符可选，要写的话，也只能写static
2. 代码块分为两种，使用static修饰的叫静态代码块，没有修饰符的，叫普通代码块
3. 逻辑语句可以为任何逻辑语句（输入、输出、方法调用、循环、判断等）
4. 最后的`;`可以写上，也可以省略

代码块的好处：

1. 相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作
2. 如果多个构造器中都有重复的语句，可以抽取到初始化块中，提高代码的复用性

```java
//代码块案例
class Movie{
    private String name;
    private double price;
    private String director;
    //下面的2个构造器都有相同的语句
    //这样代码看起来比较冗余，可以放入到一个代码块中
    //这样当我们不管调用哪个构造函数，都会调用代码块的内容
    //代码块的执行顺序优先于构造器
    {
        System.out.println("荧幕打开...");
        System.out.println("广告开始...");
        System.out.println("电影准备播放...");
    };
    public Movie(String name){
        this.name = name;
        //System.out.println("荧幕打开...");
        //System.out.println("广告开始...");
        //System.out.println("电影准备播放...");
    }
    public Movie(String name,double price){
        this.name = name;
        this.price = price;
        //System.out.println("荧幕打开...");
        //System.out.println("广告开始...");
        //System.out.println("电影准备播放...");
    }
}
```

代码块注意事项：

1. static代码块也叫静态代码块，作用就是对类进行初始化，而且它**随着类的加载而执行**，并且只会执行一次。如果是普通代码块，每创建一个对象，就执行一次。
2. static代码块（类）什么时候会被加载
   - 创建对象实例时（new）
   - 创建子类对象实例，父类也会被加载（父类先被加载，子类后被加载）
   - 使用类的静态成员时（静态属性，静态方法）
3. 普通的代码块，在创建对象实例时，会被隐式的调用。被创建一次，就会调用一次（和类加载没有关系，可以理解成普通代码块是构造器的补充，构造器被调用，代码块就被调用）。如果只是使用类的静态成员，普通代码块并不会执行。
4. 创建一个对象时，在一个类调用顺序是：
   - 调用静态代码块和静态属性初始化（注意：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定向的顺序调用）
   - 调用普通代码块和普通属性的初始化（注意：普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）
   - 调用构造方法
5. 构造器的最前面其实隐含了super()和调用普通代码块，静态相关的代码块，属性初始化，在类加载时就执行完毕了，因此是优先于构造器和普通代码块执行的。
6. 我们看一下创建一个子类对象时（继承关系），他们的静态代码块，静态属性初始化，普通代码块，普通属性初始化，构造方法的调用顺序如下：
   - 父类的静态代码块和静态属性（优先级一样，按定义顺序执行）
   - 子类的静态代码块和静态属性（优先级一样，按定义顺序执行）
   - 父类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
   - 父类的构造方法
   - 子类的普通代码块和普通属性初始化（优先级一样，按定义顺序执行）
   - 子类的构造方法
7. 静态代码块只能直接调用静态成员（静态属性和静态方法），普通代码块可以调用任意成员。

### 单例设计模式

所谓类的单例(单个实例)设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。

单例模式有两种方式：1.饿汉式 2.懒汉式

饿汉式步骤如下

1. 构造器私有化  ==》防止直接new
2. 累牍内部创建对象
3. 向外暴露一个静态的公共方法

```java
//有一个类，目标需求是GirlFriend类 只能创建一个女朋友
class SingleTon{
    pulic static void main(String[] args){
        //通过方法获取对象,即可完成目标
        GirlFriend instance = GirlFriend.getInstance();
    }
}
//饿汉式单例案例（类的实例还没有确定要使用就已经创建好了，饿汉式可能造成实例创建了没有使用，造成资源的浪费）
class GirlFriend{
    private String name;
    //如果保证我们只能创建一个GirlFriend对象？
    //1.将构造器私有化,外部别人就不能实例化类
    private GirlFriend(String name){
        this.name = name;
    }
    //2.在类的内部直接创建一个静态对象，实现唯一性
    private static GirlFriend gf = new GirlFriend("小红");
    //3.提供一个公共的static方法，返回内部创建的对象
    public static GirlFriend getInstance(){
        return gf;
    }
} 
//懒汉式单例模式（只有当用户使用时，才返回对象，后面再次调用时，返回的还是上次创建的对象）
class GirlFriend{
    private String name;
    
    //步骤：
    //1.将构造器私有化,外部别人就不能实例化类
    private GirlFriend(String name){
        this.name = name;
    }
    //2.定义一个空的静态变量
    private static GirlFriend gf = null;
    //3.定义一个static静态方法，判断对象是否创建，并返回对象
    public static GirlFriend getInstance(String name){
        if(gf == null){
            gf = new GirlFriend(name);
        }
        return gf;
    }
}
```

饿汉式 Vs 懒汉式

1. 二者最主要的区别在于创建对象的时机不同：饿汉式实在类加载就创建了对象实例，而懒汉式是在使用时才创建。
2. 饿汉式不存在线程安全问题，懒汉式存在线程安全问题。（后面学习线程后，会完善）
3. 饿汉式存在浪费资源的可能，因为如果程序运行时一个对象实例都没有使用，那么饿汉式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。

### final关键字

final 最后的，最终的

final 可以修饰类、属性、方法和局部变量。

在某些情况下， 程序员可能有以下需求，就会使用到final：

1. 当不希望类被继承时，可以用final修饰
2. 当不希望父类的某个方法被子类覆盖/重写（override）时，可以用final关键字修饰。
3. 当不希望类的某个属性的值被修改，可以用final修饰。
4. 当不希望某个局部变量被修改，可以使用final修饰。

final注意事项：

1. final修饰的属性又叫常量，一般用xx_xx_xx来命名
2. final修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一：
   - 定义时：如 public final double TAX_RATE = 0.08;
   - 在构造器中
   - 在代码块中
3. 如果final修饰的属性是静态的，则初始化的位置只能是1.定义时，2.在静态代码块 不能再构造器中赋值。
4. final类不能继承，但是可以实例化对象
5. 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以继承。一般来说，如果一个类以及是final类了，就没有必要再将方法修饰成final方法。
6. final不能修饰构造方法（构造器）
7. final和static往往搭配使用，效率更高，底层编译器做了优化处理
8. 包装类（Integer，Double，Float,Boolean等都final），String也是final类。

### 抽象类

抽象方法就是没有实现的方法（也就是没有方法体的方法），当一个类中存在抽象方法时，需要将该类用abstract来修饰，这个类就是抽象类。

一般来说抽象类会被继承，抽象方法会被子类实现。

```java
//抽象类语法
abstract class AAA{ //抽象类
    public abstract void hi(); //抽象方法
}
```



抽象类常被框架和设计使用到

抽象类的注意事项：

1. 抽象类不能被实例化
2. 抽象类不一定要包含abstract方法，也就是说抽象类可以没有abstract方法，也可以包含已经实现的方法。
3. 一旦类包含了abstract方法，则这个类必须声明为abstract
4. abstract只能修饰类和方法，不能修饰属性和其他
5. 抽象类可以有任意成员【抽象类本质还是类】，比如：非抽象方法、构造器、静态属性等等
6. 抽象方法不能有主体，即不能实现
7. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，除非它自己也声明为abstract类。
8. 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背的。、

### 模板设计模式

```java
//创建模板类
abstract class Template{
    public abstract void job(); //抽象方法
    public void caleTimes(){
        //统计耗时
        long start = System.currentTimeMillis();//获取当前毫秒
        job();
        long end = System.currentTimeMillis();
        System.out.println("耗时："+(end - start));
    }
}
class A extends Template{ //继承模板类
    public void job(){ //具体方法实现
        int num - 0;
        for(i=1;i<=100000;i++){
            num += i;
        }
    }
}

class B extends Template{ //继承模板类
    public void job(){ //具体方法实现
        int num - 0;
        for(i=1;i<=100000;i++){
            num *= i;
        }
    } 
}
//使用模板设计可以抽象出具体的业务逻辑，吧大部分工具的代码写到模板类，增加代码的复用性
```

### 接口

接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体情况把这些方法写出来。

语法：

interface 接口名{

​	//属性

​	//方法

}

class 类名 implements 接口{

​	自己属性；

​	自己方法；

​	必须实现接口的所有抽象方法

}

在jdk7前，接口里的所有方法都每一方法体

jdk8后接口类可以有静态方法，默认方法，也就是说接口中可以有方法的具体实现

接口注意事项：

1.接口不能被实例化

2.接口中所有的方法是public方法，接口中抽象方法，可以不用abstract修饰。

3.一个普通类实现接口，就必须将该接口的所有方法都实现（idea内alt+enter可以快速实现接口方法实现）

4.抽象类实现接口，可以不用实现接口的方法。

5.一个类可以同时实现多个接口

6.接口中的属性，只能是finmal的，而且是public static final修饰符。

7.接口中属性的访问形式：接口名.属性名

8.接口不能继承其他的类，但是可以继承多个别的接口

9.就看的修饰符只能是public和默认，这点和类的修饰符是一样的。

#### **实现接口 VS 继承类**

可以理解为实现是对单继承机制的补充。

当子类继承了父类，就自动的拥有了父类的功能，如果子类需要扩展功能，可以通过实现接口的方式扩展。

1. 接口和继承解决的问题不同
   检测的价值主要在于：解决代码的复用性和可维护性
   接口的价值主要在于：设计，设计好各种规范（方法），让其他类去实现这些方法。
2. 接口比继承更加灵活
   接口比继承更加灵活，继承是满足 is - a的关系，而接口只需要满足 like - a的关系。
3. 接口在一定程度上实现代码解耦【接口规范性+动态绑定】 

#### 接口的多态特性

1. 多态参数
   在前面的usb接口案例，UsbInterface usb，既可以接收手机对象，又可以接收相机对象，就体现了接口多态（接口引用可以指向实现了接口的类的对象，即接口变量可以指向不同的接口实现类实例）

2. 多态数组
   给usb数组中，存放phone和相机对象，phone类还有一个特有的方法call()，请遍历usb数组，如果是phone对象，除了调用usb接口定义的方法外，还需要调用phone特有方法call。

3. 接口存在多态传递现象。

   ```java
   public class InterfacePolyPass{
       public static void main(String[] args){
           //接口类型的变量可以指向，实现了该接口的类的对象实例
           IG ig = new teacher();
           //如果IG继承了IH接口，而Teacher类实现了IG接口，那么实际上就相当于Teacher类也实现了IH接口，这就是接口多态传递现象。
           IH ih = new teacher();
       }
   }
   
   interface IH{}
   interface IG extends IH{}
   class Teacher implements Ig{
       
   }
   ```

### 内部类

一个类的内部又完整的嵌套了另一个类结构。被嵌套的类称为内部类(inner class)，嵌套其他类的类称为外部类(outer class)。是我们类的第五大成员。内部类最大的特点就是可以直接访问私有属性，并且可以提现类与类之间的包含关系。

基本语法：

class Outer{ //外部类

​	class Inner{ // 内部类

​	}

}

class Other{ //外部其他类

}

类的小结：

类的五大成员：1.属性 2.方法 3.构造器 4.代码块 5.内部类

#### 内部类的分类

定义在外部类局部位置上（比如方法内）：

1. 局部内部类（有类名）

   - 局部内部类是定义在外部类的局部位置，通常在方法内，
   - 局部内部类（本质仍然是一个类）可以直接访问外部类的所有成员，包括私有的。
   - 不能添加访问修饰符，但是可以使用final修饰（不能再被其他类继承）
   - 作用域：仅仅在定义它的方法或代码块中。
   - 局部内部类可以直接访问外部类的成员。
   - 外部类不能访问局部内部类，那如何使用局部内部类：在方法中，可以创建包含内部类的方法对象，然后用对象调用该方法即可。
   - 如果外部类和局部内部类的成员重名时，默认遵循就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问

2. 匿名内部类（没有类名，**重点！！！**）
   匿名内部类的特点：1.本质是类 2.是内部类 3.该类没有定义名字（系统分配）4. 同时还是一个对象

   ```java
   //基本语法
   new 类或接口(参数列表){
       类体
   }
   ```

   匿名内部类的语法比较奇特，请注意，因为匿名内部类即是一个类的定义，同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征，因此可以调用匿名内部类的方法如下。

   ```java
   new A(){
       @Override
       public void cry(){
           System.out.println("Hello");
       }
   }.cry(); //定义类，并直接调用方法
   
   A a = new A(){
       @Override
       public void cry(){
           System.out.println("Hello");
       }
   } //定义类，并创建对象赋值
   a.cry(); //使用对象调用方法
   ```

   匿名内部类的最佳实践

   ```java
   //当做实参时间传递，简介高效
   interface AA{
       public void cry();
   }
   //main 方法中：
   public static void show(AA a){
       a.cry();
   }
   show(new AA{
       @Override
       public void cry(){
           System.out.print('这是一个匿名内部类');
       }
   });
   ```

   

定义在外部类的成员位置上：

1. 成员内部类（没用static修饰）

   ```java
   class Outer{
       //外部类
       private int n1 = 10;
       public String name = "张三";
       class Inner{
           //成员内部类
           public void say(){
               //可以直接访问外部类的所有成员，包含私有的
               System.out.println("n1="+n1+"name="+name);
           }
       }
       //方法可以直接使用成员内部类
       public void t1(){
           Inner inner = new Inner();
           inner.say();          
       }
   }
   ```

   - 成员内部类定义在外部类的成员位置上（即不在方法或代码块内），可以直接访问外部类的所有成员，包含私有的

   - 可以添加任意访问修饰符（public，protected，默认，private），因为它的地位就是一个成员。

   - 作用域和外部类的其他成员一样，为整个类体。在外部类的成员方法中创建成员内部类对象，再调用方法。

   - 成员内部类访问外部类成员：直接访问

   - 外部类访问成员内部类：创建对象，再访问

   - 外部其他类访问成员内部类三种方法：

     ```java
     //方法一 外部类.new 内部类
     Outer.Inner inner = Outer.new Inner();
     //方法二 在外部类中写一个方法，返回实例化成员内部类
     public void getInner(){
         return new Inner();     
     }
     Outer.Inner inner = Outer.getInner();
     //方法三 和方法一类似
     Outer.Inner inner = new Outer.new Inner();
     ```

   - 如果成员内部类的成员和外部类的成员重名，会遵守就近原则，如果要访问外部类的成员，使用 外部类.this.成员

2. 静态内部类（使用static修饰）
   静态内部类是定义在外部类的成员位置，并且有static修饰。

   - 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员。

   - 可以添加任意访问修饰符（public，protected，默认，private），因为它的地位就是一个成员。

   - 作用域：同其他成员，整个类体。

   - 静态内部类访问外部类：直接访问所有静态成员

   - 外部类访问静态内部类：创建对象，再访问

   - 外部其他类访问静态内部类

     ```java
     //方式一
     Outer.Inner inner = new Outer.Inner();
     //方式二， 写一个方法，返回内部类的实例
     public void getInner(){
         return new Inner();      
     }
     Outer.Inner inner = Outer.getInner();
     ```

   - 如果成员内部类的成员和外部类的成员重名，会遵守就近原则，如果要访问外部类的成员，使用 外部类.this.成员

## 枚举和注解

枚举英文enumeration，简写enum

枚举是一组常量的集合

可以这样理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。

### 自定义枚举

自定义枚举的步骤：

1. 将构造器私有化，目的是防止直接new
2. 去掉setXXX方法
3. 在类的内部创建固定的对象。对枚举对象/属性使用 final +static 共同修饰，实现底层优化。枚举对象名通常使用全部大写，常量的命名规范。
4. 枚举对象根据需要，也可以有多个属性。

```java
//自定义枚举类
class Season{
    private String name;
    private String desc;
    Season(String name,String desc) {
        this.name = name;
        this.desc = desc;
    }
    
    public final static Season SPRING = new Season("春天","春暖花开");
    public final static Season SUMMER = new Season("夏天","夏日炎炎");
    public final static Season AUTUMN = new Season("秋天","秋高气爽");
    public final static Season WINTER = new Season("冬天","冬雪皑皑");
    

    public String getName() {
        return name;
    }

    public String getDesc() {
        return desc;
    }

    @Override
    public String toString() {
        return "Season{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                '}';
    }
}
```



### enum关键字实现枚举

1. 使用enum关键字替代class
2. 常量名(实参列表);
3. 如果有多个常量（对象），使用`,`间隔即可
4. 使用enum关键字定义枚举，要求将常量对象，写在最前面。

```java
//enum关键字枚举
enum Season{
    SPRING("春天","春暖花开"),
    SUMMER("夏天","夏日炎炎"),
    AUTUMN("秋天","秋高气爽"),
    WINTER("冬天","冬雪皑皑");
    private String name;
    private String desc;
    Season(String name,String desc) {
        this.name = name;
        this.desc = desc;
    }

    public String getName() {
        return name;
    }

    public String getDesc() {
        return desc;
    }

    @Override
    public String toString() {
        return "Season{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                '}';
    }
}
```

注意事项：

1. 当我们使用enum关键字开发一个枚举类时，默认会继承Enum类，而且是一个final类。
2. 传统的`public static final Season SPRING = new Season("春天","春暖花开");`简化成`SPRING("春天","春暖花开");`这里必须知道，它调用的是那个构造器。
3. 如果使用无参构造器，创建枚举对象，则实参列表和小括号都可以省略
4. 当有多个枚举对象时，使用`,`间隔，最后一个用分号结尾。
5. 枚举对象必须放在枚举类的行首。

### Enum类各种方法的使用

1.  toString() 返回的是当前对象名，子类可以重写该方法，用于返回对象的属性信息
2. name() 输出枚举对象的名称
3. ordinal() 输出的是该枚举对象的次序/编号，从0开始。
4. values() 返回含有定义的所有枚举对象的数组
5. valueOf() 将字符串转换成枚举对象，要求字符串必须为已有的常量名，否则报异常
6. compareTo() 比较两个枚举常量，比较的就是位置号（枚举对象.compareTo(枚举对象2);结果就是枚举对象编号减枚举对象2的编号）

### enum实现接口

1.使用enum关键字后，就不能再继承其他类了，因为enum会隐式继承Enum，而java是单继承机制。

2.枚举类和普通类一样，可以实现接口，如下形式。

`enum 类名 implements 接口1,接口2{ }`

## 注解

1.注解（Annotation）也被称为元数据（Metadata）,用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息。

2.和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息。

3.在javaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在javaEE中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替java EE旧版中所遗留的繁冗代码和XML配置等。

使用Annotation时要在其前面增加@符号，并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素

三个基本的Annotation：

1. @Override：限定某个方法，是重写父类方法，该注解只能用于方法

   - @Override表示指定重写父类的方法（从编译层面验证），如果父类没有fly方法，则会报错
   - 如果不写@Override注解，而父类仍有public void fly(){}，仍然构成重写
   - @Override 只能修饰方法，不能修饰其他类，包，属性等
   - 查看@Override注解源码为@Target(ElementType.METHOD),说明只能修饰方法
   - @Target是修饰注解的注解，成为元注解。

2. @Deprecated：用于表示某个程序元素（类，方法等）已过时

   - 修饰某个元素，表示该元素已经过时
   - 即不在推荐使用，但是仍然可以使用
   - 可以修饰方法，类，字段，包，参数等
   - 可以做版本升级过渡使用

3. @SuppressWarnings：抑制编译器警告

   - 当我们不希望看到这些警告的时候可以使用@SupperWarnings({"All"}):忽略所有警告。

   - all:   抑制所有的警告

     boxing:        抑制与装箱/拆箱操作相关的警告

     cast:         抑制与强制转换操作相关的警告

     dep-ann:       抑制与已弃用注释相关的警告

     deprecation:     抑制与弃用相关的警告

     fallthrough:     在开关语句中抑制与丢失中断相关的警告

     finally:        抑制与最终块相关的不返回的警告

     hiding:        为了抑制相对于本地隐藏变量的警告。

     incomplete-switch:  在switch语句(enum案例)中，为了抑制相对于丢失条目的警告

     nls:          抑制相对于非nls字符串常量的警告

     null:         抑制与空分析相关的警告

     rawtypes:       在类params上使用泛型时，要抑制相对于非特定类型的警告。

     restriction:      抑制与使用不鼓励或禁止引用有关的警告

     serial:         禁止对可序列化类缺少serialVersionUID字段的警告

     static-access:     抑制与不正确的静态访问相关的警告

     synthetic-access:   抑制与内部类的未优化访问相关的警告

     unchecked:      抑制与未检查操作相关的警告

     unqualified-field-access: 抑制与字段访问不限定相关的警告

     unused:        抑制与未使用代码相关的警告

   - @SuppressWarnings作用范围是和放置的位置相关。通常可以放到属性，方法，或者类的前面。

**元注解（了解）**

元注解的种类：

1. Retention  指定注解的作用范围，三种，RetentionPolicy.SOURCE(作用于源码，编译器使用后，直接丢弃这种策略的注解)
   RetentionPolicy.CLASS(编译器把注解记录在class文件中，当运行java程序时，jvm不会保留注解，默认值)，RetentionPolicy.RUNTIME(编辑器将把注解记录在class文件中，当运行java程序时，jvm会保留注解，程序可以通过反射获取该注解)
2. Target 指定注解可以再那些地方使用
3. Documented 指定该注销是否会再javadoc体现
4. Inherited 子类会继承父类注解

## 异常处理

异常介绍：

java语言中，将程序执行中发生的不正常情况称为“异常”。（开发过程中的语法错误和逻辑错误不是异常）

执行过程中所发生的异常事件可分为两类

1. Error（错误），java虚拟机无法解决的严重问题
2. Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。Exception分为两大类：运行时异常和编译时异常（是必须要处理的异常）。

异常体系图

![QQ20251010-163307](.\img\QQ20251010-163307.png)

### 常见的运行时异常

1. NullPointerException 空指针异常
2. ArithmeticException 数学运算异常
3. ArrayIndexOutOfBoundsException 数组下标越界异常
4. ClassCastException 类型转换异常
5. NumberFormatException 数字格式不正确异常

### 编译异常

编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译。

常见的编译异常

- SQLException 操作数据库时，查询表可能发生异常
- IOException 操作文件时，发生的异常
- FileNotFoundException 当操作一个不存在的文件时，发生异常
- ClassNotFoundException 加载类，而该类不存在时，异常
- EOFException 操作文件，到文件末尾，发生异常
- IIIegalArguementException 参数异常

### 异常处理

异常处理就是当异常发生时，对异常处理的方法。

异常处理的方式：

1. try - catch - finally
   程序猿在代码中捕获发生的异常，自行处理

   ```java
   try{
       有可能发生异常的代码
   }catch(Exception e){
      // 捕获到异常
      // 1. 当异常发生时
      // 2. 系统将异常封装成Exception 对象 e,传递给catch
      // 3. 得到异常对象后，程序员自己处理
      // 4. 如果没有发生异常，catch代码块不执行
      // 5. 可以使用多个catch捕获不同的异常，子类异常写在前面，父类异常写在后台
   }finally{
       // 不管try代码块是否有异常发生，始终要执行finally，所以通常将释放资源的代码，放在finally
   }
   ```
   
2. throws

   将发生的异常抛出，交给调用者（方法）来处理，最顶级的处理者就是jvm，系统默认就是使用throws处理异常。
   

try - catch - finally 执行顺序小结：

1. 如果没有出现异常，则执行try块中所有的语句，不执行catch块中语句，如果有finally，最后还需要执行finally里面的语句
2. 如果出现异常，则try快中异常发生后，剩下的语句不再执行。将执行catch块中的语句，如果有finally，最后还需要执行finally里面的语句。

异常处理注意事项：

1. 对于编译异常，程序中必须处理，比如try-catch或者throws
2. 对于运行时异常，程序中如果没有处理，默认就是throws的方式处理
3. 子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出的异常的类型的子类
4. 在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必throws
5. 当一个方法抛出编译异常时，调用此方法的方法也要处理这个编译异常，不然编译通不过，如果抛出的是运行时异常，则不用处理，编译也可以通过

### 自定义异常

当程序中出现了某些“错误”,但该错误信息并没有在throwable子类中描述处理，这个时候可以自己设计异常类，用于描述该错误信息。

```java
//自定义年龄异常类，我们把自定义异常继承RuntimeException，做成运行时异常，好处是可以使用默认的处理机制，更加方便。
class AgeException extends RuntimeException{
    public AgeException(String message){
        super(message);
    }
}

int age =180;
if(!(age>=18 && age<=120)){
    throw new AgeException("年龄需要在18-120之间");
    System.out.println("你的年龄范围正确");
}
```

|        | 意义                     | 位置       | 后面的东西 |
| ------ | ------------------------ | ---------- | ---------- |
| throws | 异常处理的一种方式       | 方法声明处 | 异常类型   |
| throw  | 手动生成异常对象的关键字 | 方法体中   | 异常对象   |

## 常用类

### 包装类

针对八种基本数据类型相应的引用类型--包装类

有了类的特点，就可以调用类中的方法。

| 基本数据类型 | 包装类    |
| ------------ | --------- |
| boolean      | Boolean   |
| char         | Character |
| byte         | Byte      |
| short        | Short     |
| int          | Integer   |
| long         | Long      |
| float        | Float     |
| double       | Double    |

### 包装类和基本数据类型的转换

jdk5 前的手动装箱和拆箱方式，装箱：基本类型--》包装类型，反之，拆箱

jdk5 后（含jdk5）的自动装箱和拆箱方式

自动装箱底层调用的是valueOf方法，比如Integer.valueOf()

```java
//手动装箱 int ---》Integer
int n1 = 100;
Integer i = new Integer(n1);
//或者
Integer i = Integer.valueOf(n1);
//手动拆箱 Integer-----》int
int i1 = i.intValue();

//jdk5级之后自动装箱和拆箱
int n2 = 200;
Integer i2 = n2; //int 自动装箱到Integer
int n3 = i2; //Integer 自动拆箱到int
```

其他包装类类似，就不一一举例。

```java
Object obj1= true? new Integer(1) : new Double(2.0);
System.out.print(obj1);
//输出结果是1.0
//解析：三元运算符看做一个整体，冒号前是Ineteger，冒号后是Double，类型不一致，则要依范围更大的类型为主，所以结果升级为Double类型，并不是Integer。
```

### 包装类型和String类型的相互转换

**包装类型转String：**

- 方式一：
  Integer i = 100; // int 自动装箱
  String str = i + ""; // Integer i 赋值给是tr 转 String
- 方式二：
  String str2 = i.toString();
- 方式三:
  str3 = String.valueOf(i);

**String 转包装类：**

​	String str = "234";

方式一：
	//String -->int --->Integer
	Integer j = Integer.parseInt(str);

方式二：
	Integer j = new Integer(str);

方式三：
	Integer j = Integer.valueOf(str);

​	

### **Integer创建机制**

Integer包装的int数如果在-128到127之间则直接从cache中读取，如果不在这个范围内，则创建新的对象。

new 出来的两个对象一定是不同的对象。

```java
Integer i1 = new Integer(127);
Integer i2 = new Integer(127);
System.out.println(i1==i2);  // False，new出来的肯定是不同的对象

Integer i11 = 127;
int i12 = 127;
System.out.println(i11==i12); //True 只要有基本数据类型就是比较值是否相等
```

### String类

String对象用于保存字符串，也就是一组字符串序列。
![QQ20251013-100511](.\img\QQ20251013-100511.png)

字符串常量对象是用双引号括起来的字符序列，如："你好"，“12.97”，"boy"等。

字符串的字符使用unicode字符编码，一个字符（不区分字母还是汉字）占两个字节

String类较常用的构造方法：

- String s1 = new String();
- String s2 = new String(String original);
- String s3 = new String(char[] a);
- String s4 = new String(char[] a,int startIndex,int count);

String 类实现了接口Serializable【String可以串行化：可以再网络传输】

String类实现了接口Comparable【String对象可以比较大小】

String是final类，不能被其他的类继承

String 有属性 private final char value[]；用于存储字符串内容，一定注意：value是一个final类型，不可以修改（此处的不可修改不是指字符串内容不可修改，而是指value的**内存地址不可修改**，value存放的常量池地址是可以修改的。）
栈：String --》堆：value --》常量池：具体字符

**创建String对象的两种方式：**

方式一：直接赋值 String s = “dpwl”;

方式二：调用构造器 String s2 = new String("dpwl");

两种方式的区别：

1. 方式一：先从常量池查看是否有"dpwl"数据空间，如果有，直接指向；如果灭有则重新创建，然后指向。s最终指向的是常量池的空间地址
2. 方式二：现在堆中创建空间，里面维护了value属性，指向常量池的“dpwl”空间，如果常量池没有“dpwl”,重新创建，如果有，直接通过value指向。最终指向的是堆中的空间地址。

小结：String c ="a" + "b"；常量相加，看的是常量池，String c1 = a + b;变量想加，是在堆中。

**String类的常见方法**

String类是保存字符串常量的，每次更新都需要新开辟空间，效率较低，因此java设计者还提供了`StringBuilder`和`StringBuffer`来增强String的功能，并提高效率。

String类的常见方法：

- equals  区分大小写，判断内容是否相等
- equalslgnoreCase 忽略大小写判断内容是否相等
- length 获取字符的个数，字符串的长度
- indexOf 获取字符在字符串中第1次出现的索引，索引从0开始，如果找不到 -1
- lastIndexOf 获取字符在字符串中最后1次出现的索引，从0开始，找不到-1
- substring 截取指定范围的子串`substring(6)从索引6后截取全部，substring(2,5)从索引2到索引4，不含5的3个字符`
- trim 去掉前后空格
- charAt 获取某索引处的字符，**注意不能使用Str[index]这种方式**
- toUpperCase 字符串转大写
- toLowerCase 字符串转小写
- concat  拼接字符串
- compateTo 比较字符串大小，如前者大返回正数，后者大返回负数
- toCharArray 转换成字符串数组
- format 格式字符串，%s 字符串 %c 字符 %d 整型 %.2f 保留2位(四舍五入)的浮点型
- replace 替换字符串中的字符`s2 = s1.replace("a","b")；执行后s1不变，把返回的新字符串赋值给s2`
- split 分割字符串返回一个数组，需要转义字符串中的| \\等

**StringBuffer类**

代表可变的字符序列，可以对字符串内容进行增删。很多方法与String相同，但StringBuffer是可变长度的。（StringBuffer存放的不是字符常量，所以可知，它是存放在堆中的）

StringBuffer是一个容器。

StringBuffer是一个final类，不能被继承。

因为StringBuffer字符内容是存在char[] value,所以在变化（增加/删除）不用每次都更换地址（只有增加到空间不够时，才使用更大的空间，此时才更换地址）

**String Vs StringBuffer**

1. String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低。// private final char value[]；
2. StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高。

```java
// StringBuffer构造器的使用
//创建一个大小为16的char[]，用于存放字符内容。
StringBuffer str = new StringBuffer(); 
//通过构造器指定char[] 大小
StringBuffer str = new StringBuffer(100);
// 通过给一个String，创建StringBuffer，char[]大小就是str.length()+16
StringBuffer str = new StringBuffer("hello"); 
```

**string 和StringBuffer的转换**

1. String转StringBuffer

   ```java
   String str = "hello tom";
   StringBuffer string = new StringBuffer(str);
   //注意：返回的才是StringBuffer对象，原来的str不变。
   //方式二 使用append方法
   StringBuffer string2 = new StringBuffer();
   string2 = string2.append(str);
   ```

2. StringBuffer 转String

   ```java
   StringBuffer string = new StringBuffer("hello tom");
   //方式一，toString方法
   String s = string.toString();
   //方式二 使用构造器
   String string2 = new String(string);
   ```

**StringBuffer的常见方法**

- append  在后面追加
- delete(start,end) 删除>=start&&<end 处的字符
- replace(start,end,str)  把>=start&&<end 处的字符替换成str
- indexOf  查找字符在字符串中的位置索引，找不到返回-1
- insert(n,str)  在索引n处插入str，n处原来的字符后移
- length  返回字符串的长度

**StringBuilder类**

一个可变的字符序列。此类提供一个与StringBuffer兼容的API，但不保证同步（StringBuilder不是线程安全）。该类被设计用作StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。如果可能，建议有限采用该类，因为在大多数实现中，它比StringBuffer要快。

在StringBuilder上的主要操作是append和insert方法，可重载这些方法，以接受任意类型的数据。 

**String 、StringBuffer和StringBuilder的比较**

1. StringBuffer和StringBuilder非常类似，均代表可变的字符序列，而且方法也一样

2. String：不可变字符序列，效率低，但是复用率高。

3. StringBuffer：可变字符序列，效率较高（增删），线程安全

4. StringBuilder：可变字符序列，效率最高，线程不安全

5. String使用注意说明

   ```java
   String s = "a"; //创建了一个字符串
   s+="b"; //实际上原来的“a”字符串对象已经丢弃了，现在又产生了一个字符串s+“b”（也就是“ab”）。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率，如果这样的操作放到循环中，会极大影响程序的性能==》结论：如果我们对String做大量修改，不要使用String
   ```

使用的原则，结论：

如果字符串存在大量的修改操作，一般使用StringBuffer或StringBuilder

如果字符串存在大量的修改操作，并在单线程的情况，使用StringBuilder

如果字符串存在大量的修改操作，并在多线程的情况，使用StringBuffer

如果字符串很少修改，被多个对象引用，使用String，比如配置信息等

### Math类

Math类包含用于执行基本数学运算的方法，如初等指数，对数，平方根和三角函数

常用方法（都是静态方法）：

1. abs 求绝对值

2. pow 求幂 `Math.pow(2,4) //2的4次方`

3. ceil 向上取整，返回>=该参数的最小整数（转成double）

4. floor 向下取整，返回<=该参数的最大整数（转成double）

5. round 四舍五入

6. sqrt 求开方

7. random 返回[0,1)之间的随机小数

   ```java
   //如果随机生成一个大于等于a，小于等于b的数
   // 因为0<=Math.random()<1，设x = Match.random();
   // 所以 x*a + a >=a, b.x+1-a+a<=b 把前面的a带入=》 b.x-x.a+1+a<=b 可以推导出这个随机数就是 (int)x*(b-a+1)+a<=b
   ```

### Arrays类

Arrays里面包含了一系列静态方法，用于管理或操作数组（比如排序和搜索）。

1. toString返回数组的字符串形式  Arrays.toString(arr)

2. sort 排序 （自然排序和定制排序）

   ```java
   //sort 自定义排序
   Arrays.sort(arr,new Comparator(){
       //实现了Comparetor接口的匿名内部类，要求实现compare方法
       @Override
       public int compare(Object o1,Object o2){        
           Integer i1 = (Integer) o1;
           Integer i2 = (Integer) o2;
   		return i2-i1; //从大到小， i1-i2 从小到大
       }
   });
   ```

   

3. binarySearch 通过二分搜索法进行查找，要求必须排好序，找不到返-(low+1)
   
4. copyOf 数组元素的复制，`Arrays.copyOf(arr,len)`如果拷贝的len比arr.length()小，则新数组从后面删除，如果比它大，则新数组后面加null，len小于0则报异常。

5. fill 数组元素的填充`Arrays.fill(arr,9)`使用9替换掉arr数组内所有的元素

6. equals 比较两个数组元素内容是否完全一致

7. asList 将一组值，转换成list

### System类

系统类

1. exit 退出当前程序`System.exit(0)`0表示退出的状态是正常退出
2. arraycopy 复制数组元素，比较适合底层调用，一般使用Arrays.copyOf完成复制数组。`System.arraycopy(arr,0,newarr,0,3)`arr是要复制的源数组，0复制的起始位置索引，newarr 复制到的目标数组，0,3复制到数组的开始索引和元素个数
3. currentTimeMillens 返回当前时间距离1970-1-1的毫秒数
4. gc 运行垃圾回收机制 System.gc();

### BigInteger和BigDecimal 类

BigInteger 保存数据比较大的整数

BigDecimal 保存数据比较大的浮点数

常见方法：

1. add 加

2. subtract 减

3. multiply 乘

4. divide 除 可能会抛出异常，如果除不尽无限循环就异常，可以控制精度来处理

   `num1.divide(num2,BigDecimal.ROUND_CEILING)`ROUND_CEILING保留和分子一样的精度

### 日期类

日期类分为：Date，Calendar，LocalDate 三类

**Date类**在java.util包

获取的是系统当前时间，输出的格式是国外的方式通常需要格式转换

`SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 hh:mm:ss E");` E=星期

`Date(long date)`传入long类型的毫秒返回日期

String转Date：`sdf.parse(str) `注意，字符串的格式必须和上面定义的格式保持一致，否则就报异常。

**Calendar类**：第二代日期类日历

calendar类是一个抽象类，它为特定瞬间与一组诸如YEAR，MONTH，DAY_OF_MONTH，HOUR等日历字段之间的转换提供了一些方法，并为操作日历自段（例如获得下星期的日期）提供了一些方法。
calendar是抽象类，并且构造器是private，可以通过getInstance实例化

`Calendar c = Calendar.getInstance();`

获取年：`c.get(Calendar.YEAR);`

获取月：`c.get(Calendar.MONTH)+1;`月份从0开始的，所以要加1

获取日：`c.get(Calendar.DAY_OF_MONTH);`

获取时：`c.get(Calendar.HOUR);`12小时制`c.get(Calendar.HOUR_OF_DAY);`24小时制

Calendar没有提供格式化的方法，所以日期格式需要自己拼接

**第三代日期类**

前面两代日期类的不足：
JDK1.0中包含了一个java.util.Date类，但是它的大多数方法已经在JDK1.1引入Calendar类之后被弃用了，而Calendar也存在问题

1. 可变性：像日期和时间这样的类应该是不可变的
2. 偏移性：Date中的年份是从1900开始的，而月份都从0开始
3. 格式化：格式化只对Date有用，Calendar则不行
4. 此外，它们也不是线程安全的，不能处理润秒等（每隔2天，多出1s）。

Jdk8加入第三代日期类，常见方法LocalDate(日期，年月日)、LocalTime（时间，时分秒），LocalDateTime（日期时间）

```java
LocalDateTime ldt = LocalDateTime.now();
//DateTimeFormatter 格式日期类
DateTimeFormatter dtf = DateTimeFormatter.ofpattern("yyyy-MM-dd HH:mm:ss");
```

**Instant 时间戳**类似于Date提供了一系列和Date类转换的方式

Instant --》Date：Date date = Date.from(instant);

Date ---> Instant: Instant instant = date.toInstant();

第三代日期类更多方法

- LocalDateTime类
- MonthDay类：检查重复事件
- 是否有闰年
- 增加日期的某个部分
- 使用plus方法测试增加时间的某个部分
- 使用minus方法测试查看一年前和一年后的日期

## 集合

前面我们保存多个数据使用的是数组，那么数组有那些不足的地方：

1. 长度开始时必须指定，而且一旦指定，不能更改
2. 保存的必须是同一类型的元素
3. 使用数组进行增加/删除元素比较麻烦

集合的好处：

- 可以动态保存任意多个对象，使用比较方便
- 提供了一系列方便的操作对象的方法：add，remove，set，get等
- 使用集合，添加，删除新元素比较简洁

### 集合的框架体系

单列集合：存放的都是单个的对象

![QQ20251014-165627](.\img\QQ20251014-165627.png)

双列集合：存放的都是键值对

![QQ20251014-165905](.\img\QQ20251014-165905.png)

### Collection接口和常用方法

Collection接口实现类的特点：

1. collection实现子类可以存放多个元素，每个元素可以是object
2. 有些Collection的实现类，可以存放重复的元素，有些不可以
3. 有些Collection的实现类，有些是有序的（List），有些不是有序（Set）
4. Collection接口没有直接的实现子类，是通过它的子接口Set和List类实现的

Collection接口常用方法，以实现子类ArrayList来演示：

1. add ：添加单个元素
2. remove：删除指定元素
3. contains：查找元素是否存在
4. size：获取元素个数
5. isEmpty：判断是否为空
6. clear：清空
7. addAll：添加多个元素
8. containsAll：查找多个元素是否都存在
9. removeAll ：删除多个元素
10. 说明：以ArrayList实现类来演示

Collection接口遍历元素方式

1. 使用Iterator（迭代器）
   - Iterator对象称为迭代器，主要用于遍历Collection集合中的元素。
   - 所有实现了Collection接口的集合类都有一个iterator()方法，用于返回一个实现了Iterator接口的对象，即可以返回一个迭代器。
   - Iterator的结构图：通过while循环Iterator.hasNext()判断是否还有更多元素，有就可以使用iterator.next()下移一位并返回元素，直到没有元素。重新定义一下Iterator就可以重置指针位置位第一个。也可以使用增强for来遍历`for(Object o:iterator){}`
   - Iterator仅用于遍历集合，Iterator本身并不存放对象。

### List接口和常用方法

基本介绍：List接口是Collection接口的字接口

1. List集合类中元素有序（即添加顺序和取出顺序一致），且可重复
2. List集合中的每个元素都有其对应的顺序索引，即支持索引。
3. List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据序号存取容器中的元素。
4. JDK api中List接口的实现类常用的有：ArrayList，LinkedList和Vector

List接口的常用方法：

1. add：添加元素，`list.add("tom")`在集合最后添加，`list.add(1,"tom")`在第2个元素后插入。
2. addAll：在指定位置批量加入`lst.addAll(1,list)`
3. get(int index) :获取指定索引的元素
4. indexOf(Object obj)：返回obj在当前集合中首次出现的位置
5. lastIndexOf(Object obj)：返回obj在当前集合中最后一次出现的位置
6. remove(int index)：移除指定索引位置的元素，并返回该元素
7. set(int index, Object ele)：设置指定index位置的元素为ele，相当于替换
8. subList(int fromIndex,int toIndex)：返回从fromIndex到toIndex位置（不包含toIndex）的子集合

ArrayList的注意事项：

1. ArrayList可以加入null，并且多个
2. ArrayList是由数组来实现数据存储的
3. ArrayList基本等同于Vector，除了ArrayList是线程不安全（执行效率高），在多线程情况下，不建议使用ArrayList

ArrayList的底层操作机制分析

1. ArrayList中维护了一个Object类型的数组elementData，`transient Object[] elementDate`：transient关键字表示瞬间，短暂的，表示该属性不会被序列化。
2. 当创建ArrayList对象时，如果使用的是无参构造器，则初始elementDate容量为0，第一次添加，则扩容elementDate为10，如需再次扩容，则扩容elementDate为1.5倍。
3. 如果使用的是指定大小的构造器，则初始elementDate容量为指定大小，如果需要扩容，则直接扩容elementDate为1.5倍。

### Vector类分析

Vector类的定义
`public class Vector extends AbstrctList implements List,RandomAccess,Cloneable,Serializable{}`

Vector底层也是一个对象数组，`protected Object[] elementData;`

Vector是线程同步的，即线程安全，Vector类的操作方法带有`synchronizedd`

在开发中，需要线程同步安全时，考虑使用Vector

**Vector和ArrayList的比较**

|           | 底层结构 | 版本   | 线程，效率     | 扩容                                                       |
| --------- | -------- | ------ | -------------- | ---------------------------------------------------------- |
| ArrayList | 可变数组 | jdk1.2 | 不安全，效率高 | 如果有参构造1.5倍<br />如果是无参，第一次10，以后1.5倍     |
| Vector    | 可变数组 | jdk1.0 | 安全，效率不高 | 如果是无参，默认10，满后2倍<br />如果指定大小，则每次2倍扩 |

### LinkedList类分析

LinkedList底层实现了双向链表和双端队列特定

可以添加任意元素（元素可以重复），包括null

线程不安全，没有实现同步和互斥

LinkedList的底层机制：

1. LinkedList底层维护了一个双向链表
2. LinkedList中维护了两个属性first和last分别指向首节点和尾节点
3. 每个节点（Node对象），里面又维护了prev，next，item三个属性，其中通过prev指向前一个，通过next指向后一个节点，最终实现双向链表
4. 所以LinkedList的元素的添加和删除，不是通过数组完成的，相对来说效率较高

ArrayList和LinkedList的比较

|            | 底层结构 | 增删效率           | 改查效率 |
| ---------- | -------- | ------------------ | -------- |
| ArrayList  | 可变数组 | 较低，数组扩容     | 较高     |
| LinkedList | 双向链表 | 较高，通过链表追加 | 较低     |

如何选择ArrayList和LinkedList：

1. 如果我们改查的操作多，选择ArrayList
2. 如果我们增删的操作多，选择LinkedList
3. 一般来说，在程序中，80%-90%都是查询，因此大部分情况下会选择ArrayList
4. 在一个项目中，根据业务灵活选择，也可能这样，一个模块使用的是ArrayList，另外一个模块是LinkedList，也就是说，要根据业务选择

### Set接口

Set接口：1.无序（添加和取出的顺序不一致，取出的顺序是固定的），没有索引 2.不允许重复元素，所以最多包含一个null，3.jdk api中set接口的实现类常用的有HashSet和TreeSet

**Hashset**实现了Set接口

HashSet实际上是HashMap

可以存放null只，但只能有一个

HashSet不保证元素是有序的，取决于hash后，再确定索引的结果（即不保证存放元素的顺序和取出的一致）

不能有重复元素/对象（new的内容一样的对象是不同的对象）

HashSet底层机制：

HashSet的底层是hashMap，hashMap底层是（数组+链表+红黑树）

1. HashSet底层是hashMap

2. 添加一个元素时，先得到hash值，会转成-》索引值
   2.1.第一次添加时，table数组扩容到16，临界值（threshold）是16*加载因子（loadFactor）0.75 = 12（添加12个元素就会扩容了）

   2.2、如果table数组使用到了临界值12，就会扩容到16*2=32，新的临界值就是32\*0.75=24,依次类推

3. 找到存储数据表table，看这个索引位置是否已经存放的有元素

4. 如果没有，直接加入

5. 如果有，调用equals（可以根据对象的equals()重写[ides快捷键alt+insert选择equals and hashcode]来确定判断标准）比较，如果相同，就放弃添加，如果不同，则添加到最后

6. 在java8中，如果一条链表的元素个数达到TREEIFY_THRESHOLD(默认是8)，并且table的大小>=MIN_TREEIFY_THRESHOLD(默认64)，就会进行树化（红黑树），否则依然采用数组扩容机制

```java
//重写equals和hashcode案例
public static void main(String[] args) {
       Employee a = new Employee("张三",10000.0,new MyDate(1990,1,1));
        Employee b = new Employee("李四",10000.0,new MyDate(1990,1,1));
        Employee c = new Employee("张三",10000.0,new MyDate(1990,1,1));
        HashSet<Employee> hashSet = new HashSet<>();
        hashSet.add(a);
        hashSet.add(b);
        hashSet.add(c); //c 根据重新的规则，name和birthday相同则认为相同，故c不能写入，只能写入a和b
        System.out.println("hashSet = "+hashSet);
    }
class Employee{
    private String name;
    private double salary;
    private MyDate brithday;
    public Employee(String name, double salary, MyDate brithday) {
        this.name = name;
        this.salary = salary;
        this.brithday = brithday;
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return Objects.equals(name, employee.name) && Objects.equals(brithday.toString(), employee.brithday.toString());
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, brithday.toString());
    }
}
class MyDate{
    private int year;
    private int month;
    private int day;
    public MyDate(int year, int month, int day) {
        this.year = year;
        this.month = month;
        this.day = day;
    }
    public String toString() {
        return year + "年" + month + "月" + day + "日";
    }
}
```

**LinkedHashSet**是HashSet的子类

LinkedHashSet底层是一个LinkedHashMap，底层维护了一个数组+双向链表

LinkedHashSet根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，这使得元素看起来是以插入顺序保存的

LinkedHashSet不允许添加重复元素

![QQ20251023-171522](.\img\QQ20251023-171522.png)

**TreeSet实现类**

当我们使用无参构造器，创建Treeset时，仍然是无序的。

使用TreeSet提供的构造器，可以传入一个比较器（匿名内部类）可以排序

```java
TreeSet set = new TreeSet(new Comparator(){
    //匿名内部类可以自行定义排序方法
    //比较方法会传入底层的TreeMap的compare属性
    @Override
    public int compare(Object o1,Object o2){
        //比较字符串长度作为排序规则，如果长度一样，则后加入的元素就被丢弃
        return ((String) o2).length() - ((String) o1).length();
    }
});
```



### Map接口和常用方法

**Map接口的特点：**

1. Map与Collection并列存在。用于保存具有映射关系的数据：key-Value（双列元素）
2. Map中的key和value可以是任何引用类型的数据，会封装到HashMap$Node对象中
3. Map中的key不允许重复，原因和HashSet一样
4. Map中的value可以重复
5. Map的key可以为null，value也可以为null，注意key为null，只能有一个，value为null，可以多个
6. 常用String类作为Map的key
7. key和value直接存在单向一对一关系，即通过指定的key总能找到对应的value
8. Map存放数据的key--value示意图，一对k-v是放在一个Node中的，有因为Node实现了Entry接口，有些书上也说一对k-v就是一个Entry

#### HashMap实现类

**Map接口常用方法：**

1. put：添加
2. remove：根据键删除映射关系
3. get：根据键获取值
4. size：获取元素个数
5. isEmpty：判断个数是否为0
6. clear：清除
7. containsKey：查找键是否存在

**Map接口的遍历方式：**

1. containsKey：查找键是否存在

2. keySet：获取所有的键

   ```java
   public static void main(String[] args) {
       Map map = new HashMap();
       map.put("no1","张三");
       map.put("no2","李四");
       map.put("no3","王五");
       map.put("no4","王二");
       map.put("no5","麻子");
       Set keySet = map.keySet();
       // 增强for遍历
       for (Object key : keySet) {
           System.out.println(key+":"+map.get(key));
       }
       // 迭代器
       Iterator iterator = keySet.iterator();
       while (iterator.hasNext()) {
           Object key = iterator.next();
           System.out.println(key+":"+map.get(key));
       }
   }
   ```

3. entrySet：获取所有关系

   ```java
   // 通过entrySet来获取k-v
   Set entrySet = map.entrySet();
   for (Object entry : entrySet) {
       // 将entry转成Map.Entry就可以使用Map.Entry的getkey和getvalue方法
       Map.Entry m = (Map.Entry) entry;
       System.out.println(m.getKey()+":"+m.getValue());
   }
   ```

4. values：获取所有的值

   ```java
   // 把所有的values取出
   Collection values = map.values();
   for (Object value : values) {
       System.out.println(value);
   }
   ```

   

**hashMap小结**

1. Map接口的常用实现类：HashMap，HashTable和Properties。
2. HashMap是Map接口使用频率最高的实现类
3. HashMap是以key-val对的方式来存储数据（HashMap$Node类型）
4. key不能重复，但是值可以重复，允许使用null键和null值
5. 如果添加相同的key，则会覆盖原来的key-val，等同于修改（key不会替换，val会替换）
6. 与HashSet一样，不保证映射的顺序，因为底层是以hash表的方式来存储的
7. HashMap没有实现同步，因此是线程不安全的
8. HashMap的扩容机制和HashSet相同

#### Hashtable实现类

Hashtable基本介绍

1. Hashtable存放的元素是键值对：即k-v
2. Hashtable的键和值都不能为null，否则会抛出NullpointerException
3. Hashtable使用方法基本上和HashMap一样
4. Hashtable是线程安全的（synchronized），HashMap是线程不安全的
5. Hashtable的初始大小是11，扩容机制是原容量*2+1


Hashtable和HashMap对比

|           | 版本 | 线程（同步） | 效率 | 允许null键null值 |
| --------- | ---- | ------------ | ---- | ---------------- |
| HashMap   | 1.2  | 不安全       | 高   | 可以             |
| Hashtable | 1.0  | 安全         | 低   | 不可以           |

#### Properties实现类

Properties类继承自Hashtable类并且实现了Map接口，也是使用一种键值对的形式来保存数据。

他的使用特点和Hashtable类似

Properties还可以用于从XXX.Properties文件中，加载数据到Properties类对象，并进行读取和修改

工作中XXXX.Properties文件通常作为配置文件，这个知识点在IO流举例。

#### TreeMap实现类

同TreeSet一样，使用默认的构造器，TreeMap也是无序的，使用TreeMap(new Comparator{

​	//重写compare方法实现排序
​	@Override

​	public int compare(Object o1,Object o2){
​	//比较的结果是如果根据比较方法两个元素相等，则直接返回0，即后面准备放入集合的元素不会加入到集合中，就丢弃了，如果不相等，就正常加入

​	}

})实现排序。

如果添加的元素对象没有实现compareable方法，并且没有传入comparator重写的compare则，会报错，TreeSet方法同理

### 集合总结

在开发中，选择什么集合实现类，主要取决于业务操作特点，然后根据集合实现类的特性进行选择，分析如下：

1. 先判断存储的类型（一组对象[单列]或一组键值对[双列]）

2. 一组对象：Collection接口
   允许重复：List
         增删多：LinkedList（底层维护了一个双向链表）
         改查多：ArrayList（底层维护Object类型的可变数组）
   不允许重复：Set
        无序：HashSet【底层是HashMap，维护了一个哈希表，即数组+链表+红黑树】
        排序：TreeSet

   ​     插入和取出顺序一致：LinkedHashSet【维护数组+双向链表】

3. 一组键值对：Map

   ​	键无序：HashMap（底层是：哈希表，jdk7：数组+链表，jdk8：数组+链表+红黑树）

   ​	键排序：TreeMap
   ​	键插入和取出顺序一致：LinkedHashMap

   ​	读取文件：properties

### Collections工具类

Collections是一个操作Set，List和Map等集合的工具类

Collections中提供了一系列静态的方法对集合元素进行排序，查找和修改等操作

- 排序操作（均为static方法）
  1.reverse（List）：反转List中元素的顺序

  2.shuffle(List)：对List集合元素进行随机排序

  3.sort（List）：根据元素的自然顺序对指定List集合按升序排序

  4.sort(List,Comparator)：根据指定的Comparator产生的顺序对List集合元素进行排序

  5.swap（List，int i，int j）：将指定list集合中的i索引元素和j索引元素进行交换

- 查找，替换
  1.Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素

  2.Object max(Collection,Comparator)：根据Comparator指定的顺序，返回给定集合中的最大元素

  3.Object min(Collection)：根据元素的自然顺序，返回给定集合中的最小元素

  4.Object min(Collection,Comparator)：根据Comparator指定的顺序，返回给定集合中的最小元素

  5.int frequency（Collection，Object）：返回指定集合中指定元素的出现次数

  6.void copy（List dest。List src）将src中的内容复制到dest中（注意：copy前应先对dest的空间做处理不小于src的大小，不然就会报错）

  7.boolean replaceAll（List list，Object oldval，Object newval）：使用新值替换list对象的所有旧值

## 泛型

泛型的引出，传统方法的问题

1. 不能对加入到集合ArrayList中的数据类型进行约束（不安全）
2. 遍历的时候，需要进行类型转换，如果集合中的数据量较大，对效率有影响

泛型的好处：

1. 编译时，检查添加元素的类型，提高了安全性
2. 减少了类型转换的次数，提高效率
   - 不使用泛型
     Dog--加入--》Object-取出-》Dog //放入到ArrayList会先转成Object，在取出时，还需要转成Dog
   - 使用泛型
     Dog-->Dog-->Dog //放入时，和取出时，不需要类型转换，提高效率
3. 不再提示编译警告

泛型的理解：

泛型又称参数化类型，是jdk5.0出现的新特性，解决数据类型的安全性问题

在类声明或实例化时只要制定好需要的具体的类型即可

Java泛型可以保证如果程序在编译时没有发出警告，运行时就不会产生ClassCastException异常。同时，代码更加简洁，健壮

泛型的作用是：可以在类声明时通过一个标识表示类中某个属性的类型，或者是某个方法的返回值的类型，或者是参数类型。

```java
class Person<E>{
    E s; //E 表示 s的数据类型，该数据类型在定义Person对象的时候指定，即在编译期间，就确定E是什么类型
    public Person(E s){ //E 也可以是参数类型
        this.s = s;
    }
    public E f(){ //返回类型使用 E
        return s;
    }
}
```

### 泛型的语法

泛型的声明

interface 接口<T>{}

class 类<K,V>{}

说明：1.其中，T，K，V不代表值，而是表示类型 2.任意字母都可以，常用T表示，是Type的缩写。

泛型的实例化：

1. List<String> strList = new ArrayList<String>();
2. Ierator <Customer> iterator = customers.iterator();

泛型的注意事项：

1. 给泛型指定数据类型时，要求是引用类型，不能是基本数据类型
2. 在给泛型指定具体类型后，可以传入该类型或者其子类类型
3. 如果我们这样写 List list3 = new ArrayList();默认给它的泛型是【<E> E就是Object】，我们在今后的使用中可以简写成只定义变量前的泛型，后面的对象泛型会自动推断`ArrayList<String> list = new ArrayList<>();`

### 自定义泛型

基本语法

class 类名<T,R...>{ // ...表示可以有多个泛型

成员

}

注意细节

1.普通成员可以使用泛型（属性，方法）

2.使用泛型的数组，不能初始化（因为没有确定泛型的类型，所以无法在内存开空间）

3.静态方法中不能使用类的泛型

4.泛型类的类型，是在创建对象时确定的（因为创建对象时，需要指定确定类型）

5.如果在创建对象时，没有指定类型，默认是Object

- **自定义泛型接口**

基本语法

interface 接口名 <T,R,...>{ }

注意细节

1. 接口中，静态成员也不能使用泛型（这个和泛型类规定一样）
2. 泛型接口的类型，在继承接口或者实现接口时确定
3. 没有指定类型，默认为Object

- **自定义泛型方法**

基本语法

修饰符 <T,R...> 返回类型 方法名(参数列表){ }

注意细节

1. 泛型方法，可以定义在普通类中，也可以定义在泛型类中

   ```java
   class A{
       //普通类
       //泛型方法
       public <T,R> void fly(T t,R r){
           // <T,R> 就是泛型方法的标志，不带<T,R>的fly（T t，R r）只是使用了泛型的方法，并不是泛型方法
       }
   }
   class Fish<T,R>{
       //泛型类
       public void run(){
           //普通方法
       }
       public <U,M> void eat(U u,M m){
           //泛型方法
       }
   }
   ```

2. 当泛型方法被调用时，类型会确定

3. public void eat(E e){ },修饰符后没有<T,R...> eat方法不是泛型方法，而是使用了泛型

### 泛型的继承和通配符

1. 泛型不具备继承性
   `List <Object> = new ArrayList<String>();//错误的，不允许，泛型不能继承`
2. <?>：支持任意泛型类型
3. <? extends A>：支持A类以及A类的子类，规定了泛型的上限
4. <？super A>：支持A类以及A类的父类，不限于直接父类，规定了泛型的下限

Junit使用：在方法上添加@Test标注，然后Alt+enter加载Junit引用

## 坦克大战（1）

### java绘图坐标体系

坐标原点位于左上角，以像素为单位，在java坐标系中，第一个是X坐标，表示当前位置为水平方向，距离坐标原点x个像素（像素是密度单位），第二个是y坐标，表示当前位置为垂直方向，距离坐标原点y个像素

![QQ20251027-154548](.\img\QQ20251027-154548.png)

### 绘图原理

Component类提供了两个和绘图相关最重要的方法：

1. paint(Graphics g）绘制组件的外观
2. repaint() 刷新组件的外观

当组件第一次在屏幕显示的时候，程序会自动的调用paint()方法来绘制组件。

在以下情况paint()将会被调佣：

1. 窗口最小化，再最大化
2. 窗口的大小发生变化
3. repaint函数被调用

### Graphics类

graphics类可以理解为画笔，为我们提供了各种绘制图形的方法：

1. 画直线：drawLine（int x1,int y1,int x2,int y2）
2. 画矩形边框 drawRect(int x, int y,int width,int height)
3. 画椭圆边框 drawOval(int x, int y,int width,int height)
4. 填充矩形 fillRect(int x, int y,int width,int height)
5. 填充椭圆 fillOval(int x,int y, int width, int height)
6. 画图片 drawImage(Image img,int x,int y,...)
7. 画字符串 drawString(String str,int x,int y) x,y 是string的左下角坐标
8. 设置画笔的字体 setFont(Font font)
9. 设置画笔的颜色 setColor(Color c)

### java事件处理机制

```java
// 首先创建一个面板继承Jpanel类，引入键盘监听事件
class Myanel extends JPanel implements KeyListener {
    int x=100;
    int y=100;
    //myPanel对象就是一个画板
    //Graphics g  Graphics类  画笔 提供了很多绘图的方法
    public void paint(Graphics g){
        super.paint(g); //调用父类的方法完成初始化
        // 绘制一个圆形
        g.drawOval(x,y,100,100);
        //圆形的外框矩形的右上角坐标(10,10)  矩形的宽度100  高度100 就是一个圆形
    }
    //键盘输入事件
    @Override
    public void keyTyped(KeyEvent e) {

    }
	//键盘按下事件
    @Override
    public void keyPressed(KeyEvent e) {
        if(e.getKeyCode()== KeyEvent.VK_DOWN){
            //System.out.println("向下箭头键被按下");
            y++;
        }else if(e.getKeyCode()== KeyEvent.VK_UP){
            y--;
        }else if(e.getKeyCode()== KeyEvent.VK_LEFT){
            x--;
        }else if(e.getKeyCode()== KeyEvent.VK_RIGHT){
            x++;
        }
        this.repaint(); //重绘图形
    }
	//键盘按键松开事件
    @Override
    public void keyReleased(KeyEvent e) {

    }
}

//还需要在窗口中加入键盘监听事件,不然窗口中的面板获取不到监听事件
mp = new Mypanel();
this.addKeyListener(mp);
```

java事件处理是采取“委派事件模型”。当事件发生时，产生事件的对象，会把此“信息”传递给“事件的监听者”处理，这里所说的“信息”实际上就是java.awt.ent事件类库里某个类所创建的对象，把它称为“事件的对象”。

576
