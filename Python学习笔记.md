# Python学习笔记

## 一、快速入门案例

用cmd解释器，写出hell world

```python
>>> print("hello world")
hello world
```

用记事本，可发一个hello.py程序，可以输出hello world

```python
#python程序文件的后缀是.py
#print语句的作用是输出内容，输出的内容就是（）内写的内容
#在python中使用#表示注释，及对代码的说明，但是不会被执行

print("hello world")

执行方法：python/py 文件名
PS E:\学习笔记\python_code> python hello.py
hello world
PS E:\学习笔记\python_code> py hello.py
hello world
```

## 二、注意事项

1.python 文件默认以.py做文件名，但不强制，以其他文件名也可以执行

2.python程序默认情况是按顺序执行的

3.python语言区分大小写

4.python程序由一条条语句构成，每条语句后不需要以`;`结束，但是如果带上`;`也不会报错，建议不带`;`(规范)

## 三、pycharm快捷键

1. 删除当前行快捷键：`shift+delete`
2. 复制当前行：`ctrl+D`
3. 添加注释和取消注销：`ctrl+/`
4. 快速格式化代码：`ctrl+alt+L`
5. 快速运行程序，默认是`ctrl+shift+F10/shift+10` 自己定义 `alt+R`
6. 查看类的层级关系：`crtl+H`
7. 拷贝/粘贴/剪切：`ctrl+C/V/X`
8. 查找：`ctrl+F`，替换：`ctrl+R`

## 四、转义字符

- `\t `： 一个制表位，实现对齐的功能
- `\n` ：换行符
- `\\`：一个\
- `\"`：一个"
- `\'`： 一个'
- `\r`：一个回车

## 五、注释

单行注释：`#`

多行注释：`'''注释内容‘’‘`（三组单引号）或者`"""注释内容"""`（三组双引号）

文件编码声明注释：`# coding:编码` 用于指定文件的编码类型，只能放到文件的开头

**python文档：https://docs.python.org/zh-cn/3.13/**

## 六、变量

变量三要素：类型，名称，值

`type(a)` 输出变量a的类型

### 变量格式化输出

- %操作符

  ```python
  age = 20
  score = 78
  sex = "男"
  name = "张三"
  # %操作符输出
  print("姓名：%s %d %s %.1f" % (name,age,sex,score))
  
  # %s 代表输出字符串
  # %d 代表输出整数
  # %.nf 代表输出n位的浮点数
  ```

- format()函数,不用关心数据类型

  ```py
  print("姓名：{} {} {}" .format(name,sex,score))
  ```

- f-strings，自动搜索变量，不关心数据类型，推荐使用

  ```python
  print(f"姓名：{name} {sex} {score}")
  ```

**加号的使用**

如果加号两边是字符串，则是作为连接符，如果两边是数值类型则做加法运算。

### **数据类型**

python中的变量再试用期都必须赋值，变量赋值以后该变量才会被创建。

我们所说的“类型”是变量所指的内存数据的类型。

python的数据类型包括：整型，浮点型，布尔，字符串

 python 的int类型可以存放4300位的整数，python的整数有十进制，十六进制，八进制和二进制。

十六进制写法：加前缀0x，由0-9和A-F的数字和字母组合

八进制写法：加前缀0o，由0-7数字组合

二进制写法：加前缀0b，只有0和1数字组合

运行时，会自动转换成十进制输出。

```python
# 10进制
print(10)

#16进制
print(0x10)

#8进制
print(0o10)

#2进制
print(0b10)
```

python中整型占多少字节？

1.字节数随着数字增大而增大（即：python整型是变长的）

2.每次的增量是4个字节

```python
# 在python中可以通过sys.getsizeof(obj)返回obj的大小（按照字节单位返回）
p = 2**10   # 2**10 就是2的10次方
print({sys.getsizeof(p)})
# 返回结果：40
```

科学计数法浮点数

5.12e2 = 5.12X10的2次方

5.12e-2 =  5.12/10的2次方

浮点数大小限制

float_info.max = 1.7976931348623157e+308

float_info.min = 2.2250738585072014e-308

浮动类型计算后，存在精度的损失，可以使用Decimal类进行精确计算

**布尔类型注意事项：**

布尔类型可以和其他数据类型进行比较，比如数字，字符串等，在比较时，python会将ture视为1，false视为0.

在python中，非0被视为真，0值被视为假值

**字符串注意事项：**

python 不支持单字符类型，单字符在python中也是作为一个字符串使用

用三个单引号`'''内容'''`或三个双引号`"""内容"""`可以使字符串内容保持原样输出

```python
# 原样输出字符串
cont = """
def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
"""
print(cont)
```

在字符串前面加`'r'`可以使整个字符串不会被转义。

```python
str=r"jack \n tom \t jeron"
print(str)
jack \n tom \t jeron
```

### 字符串驻留机制

python仅保存一份相同且不可变字符串，不同的值被存放在字符串的驻留池中，python的驻留机制对相同的字符串只保留一份拷贝，后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的变量

```python
str1 = "hello"
str2 = "hello"
str3 = "hello"
#id()函数，可以返回对象/数据的内存地址
print("str1的地址：", id(str1))
print("str2的地址：", id(str2))
print("str3的地址：", id(str3))
str1的地址： 1965951195328
str2的地址： 1965951195328
str3的地址： 1965951195328
```

驻留机制的几种情况：

1.字符串是由26个英文字母大小写，0-9，_组成

2.字符串长度为0或者1时

3.字符串在编译时进行驻留，而非运行时

```python
a = "abc"
b = "".join(["a","bc"])
print(a)
abc
print(b)
adc  
id(a)
1409056
id(b)
194784
# a 和 b的结果虽然一样，但是a是编译时就是abc，b是运行时才是abc，所以不会驻留
```

4.[-5至256]的整数数字

5.sys中的intern方法可以强制两个字符串指向同一个对象

```python
import sys
s1 = "abc#"
s2 = sys.intern(s1) 
```

6.pycharm对字符串进行了优化处理，相同字符串依然会驻留

```python
str1 = "abc#"
str2 = "abc#"
print(id(str1) == id(str2))
True
```

字符串驻留机制的好处：

当需要值相同的字符串时，可以直接从字符串池里拿来使用，避免频繁的创建和销毁，提升效率和节约内存

### 数据类型转换

- 隐式类型转换
  python变量的类型不是固定的，会根据变量当前值在运行时决定，可以通过内置函数type(变量)来查看其类型，这种方式就是隐式转换，也称为自动转换

```python
var1 = 10
print(type(var1)) #int
var1 = 1.1
print(type(var1)) #float
var1 = "XXX"
print(type(var1)) #str
```

- 显式类型转换

​	如果需要对变量数据类型进行转换，只需要将数据类型作为函数名即可，这种方式就是显式转换/强制转换。

| **函数**             | **作用**                                                     |
| -------------------- | ------------------------------------------------------------ |
| `int(x, base=10) `   | 将X转换为一个整型变量，base参数为可选项，用来决定转化后的进制 ，默认为十进制 |
| ` long(x, base=10) ` | 将X转换为一个长整型变量（比int的范围更大），base参数为可选项，用来决定转化后的进制，默认为十进制 |
| ` float(x)`          | 将X转换为一个浮点数                                          |
| `str(object)`        | 将对象object转换为字符串                                     |
| `repr(object) `      | 将对象object转换为表达式字符串                               |
| `eval(str) `         | 用来计算在字符串str中的有效python表达式，并返回一个对象      |
| `tuple(seq) `        | 将序列seq转换为一个元组                                      |
| `list(seq)`          | 将序列seq转换为一个列表                                      |
| ` chr(x)`            | 将一个整数转换为一个字符                                     |
| `unichr(x)`          | 将一个整数转换为一个Unicode字符                              |
| ` ord(x)`            | 将一个字符转换为它的整数值                                   |
| ` hex(x)`            | 将一个整数转换为一个十六进制字符串                           |
| `oct(x)`             | 将一个整数转换为一个八进制字符串                             |

显式类型转换注意事项：

1.不管什么值的int，float都可以转成str，str(x)将对象x转换成字符串

2.int转成float时，会增加小数部分，比如12-->12.0,float转成int时，会去掉小数部分，比如123.65-->123

3.str转int，float使用int(x),float(x)将对象x转换成int/float,在将str类型转成基本数据类型时，要确保str值能够转成有效的数据，比如我们可以将"123".转成一个整数，但是不能把"hello"转成一个整数，"12.3"也不能转成一个整数，如果格式不正确，程序会报valueError。

4.对一个变量进行强制转换，会返回一个数据/值，注意，强制转换后，并不会影响原变量的数据类型（即不会影响原变量指向的数据/值的数据类型）。

```python
i = 10
j = float(i) #j 会开辟一个新的内存空间，存储float(i)的结果，并不会改变原来i的值
```

## 七、运算符

### 算术运算符

| 运算符 | 运算                                 | 范例            |
| ------ | ------------------------------------ | --------------- |
| +      | 加                                   | 5+5=10          |
| -      | 减                                   | 6-4=2           |
| *      | 乘                                   | 3*4=12          |
| /      | 除                                   | 5/5=1           |
| %      | 取模（取余）                         | 7%5=2           |
| //     | 取整除（返回商的整数部分，向下取整） | 9//2=4,-9//2=-5 |
| **     | 幂                                   | 2**3=8          |

```python
# 当对一个数取模时，对应的运算公式是：a%b = a-a//b*b
print(-10%3) 
# 计算过程：-10 -（-10）//3*3 => -10 - (-4)*3 =>-10 -(-12) => 2
print(10%-3) 
# 计算过程：10 -10//(-3)*(-3) => 10 - (-4)*(-3) => 10-12 => -2
print(-10%-3) => -1
print(10%3) => 1
```

练习题：

1.假如还有97天放假，问：合多少个星期零多少天？

2.华氏温度转摄氏温度的公式：5/9*（华氏温度-100），求234.5华氏温度是多少摄氏度？

### 赋值运算符

| 运算符 | 描述                 | 实例               |
| ------ | -------------------- | ------------------ |
| =      | 简单的赋值运算符     | c=a+b              |
| +=     | 复合加法赋值运算符   | c+=a等效于c=c+a    |
| -=     | 复合减法赋值运算符   | c-=a等效于c=c-a    |
| *=     | 复合乘法赋值运算符   | c\*=a等效于c=c*a   |
| /=     | 复合除法赋值运算符   | c/=a等效于c=c/a    |
| %=     | 复合取模赋值运算符   | c%=a等效于c=c%a    |
| **=    | 复合幂赋值运算符     | c\**=a等效于c=c**a |
| //=    | 复合取整除赋值运算符 | c//=a等效于c=c//a  |

python 中支持一个简单的方式实现变量交换 x,y = y,x

python是一种极简主义的边陲语言，它没有引入？：这个运算符，而是使用if else关键字来实现相同的功能

语法是` max = a if a>b else b`

```python
# 用三元运算求两个数的较大值
a = 10
b = 80
max = a if a > b else b
print("较大值是", max)
```



### 比较运算符

| 运算符 | 运算                             | 范例 | 结果  |
| ------ | -------------------------------- | ---- | ----- |
| ==     | 等于                             | 4==3 | false |
| !=     | 不等于                           | 4!=3 | true  |
| <      | 小于                             | 4<3  | false |
| >      | 大于                             | 4>3  | true  |
| <=     | 小于等于                         | 4<=3 | false |
| >=     | 大于等于                         | 4>=3 | true  |
| is     | 判断两个变量引用对象是否为同一个 |      |       |
| is not | 判断两个变量引用对象是否不同     |      |       |

注意：比较运算符的结果要么是true，要么是false

比较运算符组成的表达式，我们称为比较表达式，比如：a>b

比较运算符==不能误写成=

### 逻辑运算符

| 运算符 | 逻辑表达式 | 描述                                                         | 实例              |
| ------ | ---------- | ------------------------------------------------------------ | ----------------- |
| and    | x and y    | 布尔“与”，如果x为false，x and y 返回x的值，否则返回y的计算值 | 10 and 20 返回 20 |
| or     | x or y     | 布尔“或”，如果x为true，x or y 返回x的值，否则返回y的计算值   | 10 or 20 返回10   |
| not    | not x      | 布尔“非”，如果x为false，返回true，如果x为true，返回false     |                   |

注意：

and 是种“短路运算符”，只有当第一个为true时才去验证第二个

or 是种“短路运算符”，只有当第一个为false时才去验证第二个

### 位运算符

详见第八章的位运算。

### 运算符的优先级

|      | 运算符从高到低                      | 描述                                 |
| ---- | ----------------------------------- | ------------------------------------ |
| 0    | （expressions）                     | 加括号的表达式                       |
| 1    | **                                  | 乘方                                 |
| 1    | *,@,/,//,%                          | 乘，矩阵乘，除，整除，取余           |
| 1    | +,-                                 | 加法，减法                           |
| 2    | >>,<<                               | 右移，左移（移位）                   |
| 2    | &                                   | 按位与                               |
| 2    | ^                                   | 按位异或                             |
| 2    | \|                                  | 按位或                               |
| 3    | in,not in,is,is not,<,<=,>,>=,!=,== | 比较运算符，包括成员检测和标识号检测 |
| 4    | not x                               | 布尔逻辑非                           |
| 4    | and                                 | 布尔逻辑与                           |
| 4    | or                                  | 布尔逻辑或                           |
| 5    | =,%=,/=,//=,-=,+=,*=,**=            | 辅助运算符                           |

1类是算术运算，2类位运算，3类比较运算，4类逻辑运算，5类赋值运算

### 标识符命名规则和规范

python对各种变量，函数和类等命名时使用的字符序列称为标识符

凡是自己可以起名字的地方都叫标识符

命名规则：

1. 由26个英文字母大小写，0-9，_ 组成

2. 数字不可以开头

3. 不可以使用关键字，但能包含关键字
   python内置关键字

   ```python
   False               class               finally             is              return
   None                continue            for                 lambda          try
   True                def                 from                nonlocal        while
   and                 del                 global              not             with
   as                  elif                if                  or              yield
   assert              else                import              pass            async
   await               except              in                  raise
   ```

4. python区分大小写

5. 标识符不能包含空格

标识符命名规范

- 变量名：变量要小写，若有多个单词，使用下划线分开，常量全部大写
- 函数名：函数名一律小写，如果有多个单词，用下划线隔开。另外，私有函数以双下划线开头
- 类名：使用大驼峰命名

大驼峰：多个单词的首字母都用大写开头。例如：MyName

小驼峰：第一个单词的首字母用小写，后面的单词首字母都用大写。例如：myName

`input(prompt)`函数接收到的一切数据都保存为str类型，如果要对接收到的数据做算术运算就要先类型转换。也可以使用如下方法指定获取的数据类型：

```python
age = int(input("请输入年龄："))
```

## 八、进制

| 10进制 | 16进制                             | 8进制                            | 2进制                                                    |
| ------ | ---------------------------------- | -------------------------------- | -------------------------------------------------------- |
| 0      | 0                                  | 0                                | 0                                                        |
| 1      | 1                                  | 1                                | 1                                                        |
| 2      | 2                                  | 2                                | 10<br />（满2进一位，十位表示2）                         |
| 3      | 3                                  | 3                                | 11                                                       |
| 4      | 4                                  | 4                                | 100                                                      |
| 5      | 5                                  | 5                                | 101                                                      |
| 6      | 6                                  | 6                                | 110                                                      |
| 7      | 7                                  | 7                                | 111                                                      |
| 8      | 8                                  | 10<br />（满8进一位，十位表示8） | 1000                                                     |
| 9      | 9                                  | 11                               | 1001                                                     |
| 10     | A                                  | 12                               | 1010                                                     |
| 11     | B                                  | 13                               | 1011                                                     |
| 12     | C                                  | 14                               | 1100                                                     |
| 13     | D                                  | 15                               | 1101                                                     |
| 14     | E                                  | 16                               | 1110                                                     |
| 15     | F                                  | 17                               | 1111                                                     |
| 16     | 10<br />（满16进一位，十位表示16） | 20                               | 10000<br/>(每一位表示2的(n-1)次方，结果是再想加)         |
| 17     | 11                                 | 21                               | 10001                                                    |
| 18     | 12                                 | 22                               | 10010<br/>=>1X2\*\*4+0X2\*\*3+0X2\*\*2+1X2\*\*1+0X2\*\*0 |

### 其他转十进制

二进制转十进制规则：从最低位(右边)开始，将每个位上的数乘以2的(位数-1)次方，然后求和。

八进制转十进制规则：从最低位(右边)开始，将每个位上的数乘以8的(位数-1)次方，然后求和。

十六进制转十进制规则：从最低位(右边)开始，将每个位上的数乘以16的(位数-1)次方，然后求和。

### 十进制转其他

十进制转二进制规则，将该数不断除以2，只到商为0为止，然后将每步得到的余数倒过来就是对应的二进制。

```python
print(bin(123))
# 计算过程
# 123/2=61  ...1
# 61/2=30 ...1
#30/2=15 ...0
# 15/2=7 ...1
# 7/2=3 ...1
# 3/2=1 ...1
# 1
#结果是0B1111011
```

十进制转八进制规则，将该数不断除以8，只到商为0为止，然后将每步得到的余数倒过来就是对应的八进制。

```python
print(oct(678))
# 计算过程如下
# 678/8=84 ...6
# 84/8=10 ...4
# 10/8=1 ...2
# 1
# 结果 0o1246
```

十进制转十六进制规则，将该数不断除以16，只到商为0为止，然后将每步得到的余数倒过来就是对应的十六进制。

```python
print(hex(8912))
# 计算过程如下
# 8912/16=557 ...0
# 557/16=34 ...13=>d
# 34/16=2 ...2
# 2
# 结果 0X22d0
```

### 二进制转八进制，十六进制

二进制转八进制规则：从低位开始，将二进制数每三位一组，转成对应的八进制数即可。

```python
#ob11010101 转八进制
# 11 010 101 =》3  2  5
#结果0o325
```

二进制转十六进制规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。

```python
#ob11010101 转十六进制
# 1101 0101 =》13(d) 5
#结果0xd5
```

### 八进制，十六进制转二进制

八进制转二进制规则：将八进制数的每1位，转成对应的一个3位的二进制数即可。

```python
#0o237转二进制
# 7 ==》111
# 3 ==》011
# 2 ==》010
#结果0b10011111
```

十六进制转二进制规则：将十六进制数的每1位，转成对应的一个4位的二进制数即可。

```python
#0X23B转二进制
# B ==》1011
# 3 ==》0011
# 2 ==》0010
#结果0b1000111011
```

### 原码，反码，补码

1. 二进制的最高位是符号位：0表示整数，1表示负数

```python
#  python中一个数由28个字节组成，便于演示现假定一个数就是1个字节（8位)
#  3 ==》0000 0011
#  -3==》1000 0011
```

2. 正数的原码，反码，补码都一样（三码合一）
3. 负数的反码=它的原码符号位不变，其他位取反

```python
# -3 =》 原码：1000 0011
#	 =》 反码：1111 1100
```

4. 负数的补码=它的反码+1，负数的反码 = 负数的补码-1

```python
# -3 =》 原码：1000 0011
#	 =》 反码：1111 1100
#    =》 补码：1111 1101
```

5. 0的反码，补码都是0
6. 在计算机运算的时候，都是以**补码**的方式来运算的

```python
#  1+3
# 1的补码：0000 0001
# 3的补码：0000 0011
# 1+3 =》 0000 0100 （运算结果还是补码）
# 1-3 == 1+(-3)
# 1的补码：0000 0001
# -3的原码：1000 0011 =》反码：1111 1100 =》补码：1111 1101
# 0000 0001 + 1111 1101 =》 1111 1110（得出结果的补码）
# 结果的反码：1111 1110（补码）-1 =》 1111 1101
# 结果的原码: 1000 0010 => -2
```

7. 当我们看运算结果的时候，要看它的原码

### 位运算

| 位运算符 | 名称     | 规则释义                                                     |
| -------- | -------- | ------------------------------------------------------------ |
| ~        | 按位取反 | 对数据的每个二进制位取反，即把1变0,把0变1                    |
| &        | 按位与   | 参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0 |
| ^        | 按位异或 | 当两个对应的二进位相异时，结果为1                            |
| \|       | 按位或   | 只要对应的二个二进位有一个为1时，结果就为1                   |
| <<       | 左移     | 运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，符合位不变，高位丢弃，低位补0 |
| >>       | 右移     | 把“>>”左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数，低位溢出，符号位不变，并用符号位补溢出的高位 |

~ 按位取反案例

```python
# 我们假定使用一个字节来表示一个数字
# ~-2=?
# -2的补码:? 推导步骤：
# -2的原码1000 0010 
#  =>-2的反码 1111 1101
#  =》-2补码 1111 1110
#  =》按位取反：0000 0001(结果是补码)=》00000001(正数的补码就是原码)
#  =>结果就是：1


# ~2=?
# 2 的补码:0000 0010
# 按位取反：1111 1101(结果是补码)
# 补码推导原码（反码：补码-1）=>1111 1100(反码)=>1000 0011(原码)
# 结果=》-3
```

& 按位与

```python
# 分析 2&3 的结果
# 2的补码：0000 0010
# 3的补码：0000 0011
# 按位与： 0000 0010 正数 原码=补码
# 结 果 ：2
```

^ 按位异或

```python
# 分析 2^-3的结果
# 2的补码：0000 0010
# -3的原码：1000 0011
# -3的反码：1111 1100
# -3的补码：1111 1101
#  2^-3:0000 0010
#		1111 1101
#(补码)结果 1111 1111
#结果反码： 1111 1110
#结果原码： 1000 0001
# 结果==》 -1
```

| 按位或

```python
# 分析 2|3的结果
# 2的补码：0000 0010
# 3的补码：0000 0011
# 2|3的补码：0000 0011
# 结果 == 3
```

<< 右移

```python
# 分析 5<<1
# 5的补码：0000 0101
# 5<<1:  0000 1010 (补码)
# 结果：10

# 分析 -5<<1
# -5的原码：1000 0101
# -5的反码：1111 1010
# -5的补码：1111 1011
# -5 <<1: 1111 0110 (补码)
#  结果的反码：1111 0101
#  结果原码： 1000 1010 => -10
# m左移n位相当于 m*2**n
```

\>\> 右移

```python
# 分析 5>>1
# 5的补码：0000 0101
# 5>>1:  0000  0010 (补码)
# 结果：2

# 分析 -5>>1
# -5的原码：1000 0101
# -5的反码：1111 1010
# -5的补码：1111 1011
# -5 >>1:  1111 1101 (补码)
#  结果的反码：1111 1100
#  结果的原码：1000 0011
#  结果： -3
#  m右移n位相当于 m//2**n
```

## 九、程序流程控制

### 顺序控制

程序从上到下逐行地执行，中间没有任何判断和跳转

### 分支控制

让程序有选择的执行，分支控制有三种：

1. 单分支
   **if** 条件表达式 **：**
   	代码块（可以有多条语句)

if基本语法说明

- 当条件表达式为true时，就会执行代码块，如果为false，就不执行

- python缩进非常重要，是用于界定代码块的，相当于其他编程语言里的大括号{ }
- 最短的缩进对较长的有包含关系，缩进前后没有要求，但是每个代码块应具有相同的缩进长度（tab或相同个数的空格）

2. 双分支
   **if** 条件表达式**：**
       执行代码块1
   **else：**
       执行代码块2

3. 多分支
   **if** 条件表达式1**:**
      执行代码块1
   **elif** 条件表达式2**:**
       执行代码块2
   ....
   **else:**
   
   ​    执行代码块n+1
   
4. 嵌套分支

   - 嵌套分支：在一个分支结构中又嵌套了另一个分支结构
   - 里面的分支结构称为内存分支，外面的分支结构称为外层分支
   - 规范：不要超过3层（可读性不好）

### 循环控制

**for循环**

```python
# 基本语法
for <变量> in <范围/序列>:
​	<循环操作语句>
```

可以通过`range()`函数快速生成序列。range(start=0, stop, step=1) range默认的start是0，step步长是1。range()生成的数列的前闭后开的，列： range(1,5) 包含1，不包含5。

for 可以和else配合使用，如果正常循环完循环体就会执行else代码块，如果循环体被中断（break），则不会执行else代码块。

**while循环**

```python
# 基本语法
while 判断条件:
    循环操作语句
    
#实例
i=1
while i<=10:
    print('hello',i)
    i+=1
# while 可以和else 配合使用
#语法
i=0
while i<3:
    print('i小于3')
    i+=1
else：
	print('i大于等于3')
```

**多重循环控制**

打印空心金字塔【化繁为简，先死后活】

```python
#分析过程详见，star.py文件
#先死后活，把层数改成不固定,最终结果：
total_level = 10
for i in range(1,total_level + 1):
    for k in range(total_level - i):  # 每行输出的空格数为总层减当前层
        print(" ",end="")  # 输出第一个星前面的空格
    for j in range(2 * i - 1): #每层输出的星总个数
        if j == 0 or j == 2*(i-1) or i == total_level: # 如果是最后一行或者是每行的第一个和每行的最后一个星就输出
            print("*",end="")
        else:
            print(" ", end="") #否则就输出空格
    print("")
```

```python
#课后练习打印出九九乘法表

for i in range(1, 10):
    for j in range(1, i+1):
        print(f"{i} X {j} = {i*j} ", end=" ")
    print("")
```

### break语句

break语句是用在for或while循环所嵌套的代码

它会终结最近的外层循环，如果循环有可选的else子句，也会跳过该子句。 

如果一个for循环被break锁终结，该循环的控制变量会保持其当前值。

```python
# 实例，随机生成1-100的整数，如果等于97则统计随机生成了多少次
import random
k=0
while True:  #无限循环生成随机数
    num = random.randint(1, 100)
    print(num)
    k += 1       #统计生成次数
    if num == 97:
        break    #退出循环
print(f"循环了{k}次")
```

### continue语句

continue语句用于for或while循环所嵌套的代码中

continue语句用于结束本次循环，继续执行循环的下一个轮次，（继续执行的是：该continue最近的外层循环的下一个轮次）。

### return语句

return使用在函数，表示跳出所在的函数

```python
#return 实例
def f1():
    for i in range(1,5):
        if i == 3:
            return
        	#break
            #continue
        print("i =", i)
    print("结束了for...")
    
#调用f1函数--》执行f1函数
f1()
```

## 十、函数

1.为完成某一功能的程序指令（语句）的集合，称为函数。

2.在python中，函数分为：系统函数，自定义函数。

函数格式：

```python
def 函数名(形参):
    函数体代码
    return 返回值
# 形参可以没有，也可以有多个，多个中间用,隔开
# 如果么诶有return语句，默认返回None，None是内置常量，通常用来表示空值的对象
```

  3.函数中的变量是局部的，函数外不生效

  4.如果同一个文件，出现两个函数名相同的函数，则以就近原则进行调用。

5. 调用函数时，根据函数定义的参数位置来传统参数，这种传参方式就是位置参数，传递的实参和定义的形参顺序和个数必须一致，同时定义的形参，不用指定数据类型，会根据传入的实参决定。

6. 函数可以有多个返回值，返回数据类型不受限制。
7. 函数支持关键字参数
   函数调用时，可以通过“**形参名=实参值**”形式传递参数
   这样可以不受参数传递顺序的限制
8. 函数支持默认参数（缺省参数）
   定义函数时，可以给参数提供默认值，调用函数时，指定了实参，则以指定为准，没有指定，则以默认值为准
   默认参数，需要放在参数列表后
9. 函数支持可变参数（不定长参数）
   应用场景：当调用函数时，不确定传入多少个实参的情况
   传入的多个实参，会被组成一个元祖（tuple），元祖可以存储多个数据项。

```python
def sum(*args): # *表示0个或多个
    print(f"args->{args} 类型是->{type(args)}")
    total=0
    # 对args进行遍历，即对元组便利
    for ele in args:
        total += ele
    return total
```

10. 函数的可变参数还支持多个关键字参数，也就是多个"形参名=实参值"

    应用场景：当调用函数时，不确定传入多少个关键字参数的情况

    传入的多个关键字参数，会被组成一个字典（dict），字典可以存储多个  键=值  的数据项

```py
def person_info(**args):
    print(f"args->{args} 类型->{type(args)}")
    for arg_name in args:
        print(f"参数名->{arg_name} 参数值->{args[arg_name]}")
```

### 函数的传参机制

字符串和数值类型是不可变数据类型，当对应的变量的值发生了变化时，它对应的内存地址会发生改变。

```python
def f1(a):
    print(f"f1() a的值：{a} 地址是：{id(a)}")
    a+=1
    print(f"f1() a的值：{a} 地址是：{id(a)}")
    
a = 10  #假设 10对应的内容地址是：0X123

print(f"调用f1()前 a的值：{a} 地址是：{id(a)}") #此时 a=10，id是0X123
f1(a)  #调用f1()时，因为python的驻留机制，函数内变量a指向函数外的a（并不会开辟新的内存空间）,所以第一条输出 a =10，id是0X123
#当执行a+=1时，函数内变量a对应的值改变，所以此时a的内存地址指向新值的内存地址，原来的10的内存地址不变。第二条输出 a=11，id假设是0X1245
print(f"调用f1()后 a的值：{a} 地址是：{id(a)}") #调用函数不影响函数外的变量，a依然=10，id也还是0X123
```

### 函数递归调用

递归调用示例图：

![image-20250821113619300](.\img\image-20250821113619300.png)

递归重要规则：

1. 执行一个函数时，就创建一个新的栈空间
2. 函数的变量是独立的
3. 递归必须向退出递归的条件逼近，否则就是无限递归，就会出现RecursionError：maximum recursion depth exceeded【死归了】
4. 当一个函数执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁

### 函数作为参数传递

```python
# 定义一个函数，返回两个数的最大值
def get_max_val(num1,num2):
    max_val= num1 if num1>num2 else num2
    return max_val

def fq(fun,num1,num2):
    """
    fun:表示接手一个函数
    """
    return num1+num2,fun(num1,num2)

#调用函数
fq(get_max_val,10,30) #传入一个函数的名称，和两个值
```

函数作为参数传递，传递的不是数据，而是业务处理逻辑

一个函数，可以接收多个函数作为参数传入

### 匿名函数

用于临时创建一个函数，只使用一次的场景

匿名函数基本语法：

lambda 形参列表: 函数体（一行代码）

lambda 关键字，表示定义匿名函数

函数体完成的功能，只能写一行，不能写多行代码

```python
# 你们函数的使用
f1(lambda a,b:a if a>b else b, 10,30)   #lambda 后面的函数就是个匿名函数
```

###  变量作用范围

**全景变量：**在整个程序范围内都可以访问，定义在函数外，拥有全局作用域的变量。

**局部变量：**只能在其被声明的函数范围内访问，定义在函数内部，拥有举报作用域的变量

1. 未在函数内部重新定义n1，那么默认使用全局变量n1
2. 在函数内部重新定义了n1，那么根据就近原则，使用的就是函数内部重新定义的n1
3. 在函数内部使用global 关键字，可以标明指定使用全局变量（不可变类型变量）

## 十一、数据容器（collections）

 数据容器是一种数据类型，有些地方简称为容器

数据容器可以存放多个数据，每一个数据也被称为一个元素

存放的数据/元素可以是任意类型

简单的说，数据容器就是一种可以存放多个数据/元素的数据类型

数据容器可以分为以下五种：

### 列表（list）

列表可以存放多个不同类型数据，即：列表就是一列数据（多个数据）

列表也是一种数据类型

创建一个列表，只需要用逗号分隔的不同的数据项使用方括号括起来即可

```python
# 定义一个列表
list_color=["red","green","white","yellow","black"]
# 取出列表中的元素
list_color[0] #就是 red
```

1. 如果需要一个空列表，可以使用[ ]或者list()
2. 列表的元素可以有多个，而且数据类型没有限制，允许有重复元素，并且是有序的
3. 列表是索引/下标是从0开始的
4. 列表索引必须在指定范围内使用，如list1=[1,2,3]的有效索引为0-2
5. 索引也可以从尾部开始，最后一个元素的索引为-1，往前一位为-2，以此类推
6. 通过 `列表[索引]=新值` 对数据进行更新，使用 `列表.append(值)` 方法来添加元素，使用`del 列表[索引] `语句来删除元素，注意不能超出有效索引范围。
7. 列表是可变序列（列表的元素是可以修改的，修改后，列表变量指向的地址不变，只是数据内容变化）

![2025-08-21_223347](.\img\2025-08-21_223347.jpg)

![2025-08-21_223347](.\img\2025-08-21_224138.jpg)

| 序号 | 列表常用操作方法                                             |
| ---- | ------------------------------------------------------------ |
| 1    | list.append(obj)：在列表末尾添加新的对象                     |
| 2    | list.count(obj)：统计某个元素在列表中出现的次数              |
| 3    | list.extend(seq)：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） |
| 4    | list.index(ojb)：从列表中找出某个值第一个匹配项的索引位置    |
| 5    | list.insert(index,ojb)：将对象插入列表指定位置               |
| 6    | list.pop([index=-1])：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 |
| 7    | list.remove(obj)：移除列表中某个值的第一个匹配项             |
| 8    | list.reverse()：反向列表中元素（翻转列表）                   |
| 9    | list.sort(key=None,reverse=False)：对原列表进行排序          |
| 10   | list.clear()：清空列表                                       |
| 11   | list.copy()：复制列表                                        |

列表生成式：就是“生成列表的公式”

基本语法：`[列表元素的表达式 for 自定义变量 in 可迭代对象]`

```python
# 示例
list1 = [ele*2 for ele in range(1,5)] #得到列表 list1=> [2,4,6,8]

#用列表生成式生成内容为[1,4,9,16,25,36,49,64,81,100]
lst = [ele**2 for ele in range(1,11)]
print("lst = ", lst)
```

### 元组（tuple）

 元组（tuple）可以存放多个不同类型数据，元组是不可变序列。（tuple不可变是指当你创建了tuple时候，它就不能改变了，也就是说它也没有append（），insert()这样的方法，但它也有获取某个索引值的方法，但是不能重新赋值）

元组也是一种数据类型

创建一个元组，只要把逗号分隔的不同的数据项，使用圆括号括起来即可。

tuple_a = (100,200,300)

- 创建空元组可以用 `()`或`tuple()`

- 元组的元素可以有多个，而且数据类型没有限制（甚至可以嵌套元组），允许有重复元素，并且是有序的
- 元组的索引/下标是从0开始的
- 元组索引必须在指定范围内使用
- 元组是不可变序列。
- 如果元组内有一个list元素，这该list元素的内容是可以修改的（包括增加，修改，删除等）
- 索引也可以从尾部开始，最后一个元素的索引为-1，往前一位为-2，以此类推
- 定义只有一个元素的元组，需要带上逗号，否则就不是元组类型

```python
tuple_one = (100,)
print(type(tuple_one)) #类型就是元组<class 'tuple'>
tuple_a1=(100)
print(type(tuple_a1)) #类型就是int <class 'int'>
```

- 为什么要引入元组：元组在创建时间和占用的空间上优于列表，元组能够对不需要修改的数据写保护。

| 序号 | 元组常用操作                                               |
| ---- | ---------------------------------------------------------- |
| 1    | len(tuple)：元组元素个数                                   |
| 2    | max(tuple)：返回元组元素最大值                             |
| 3    | min(tuple)：返回元组元素最小值                             |
| 4    | tuple.count(obj)：统计某个元素在元组中出现的次数           |
| 5    | tuple.index(obj)：从元组中找出某个值第一次匹配项的索引位置 |

### 字符串（str）

1. 在python中处理文本数据是使用str对象，也称为 字符串，字符串是由Unicode码位构成的不可变序列。
2. 字符串字面量有三种写法：单引号，双引号，三重引号
3. 字符串是字符的容器，一个字符串可以存放多个字符。

| 序号 | 字符串常用操作                                               |
| ---- | ------------------------------------------------------------ |
| 1    | len(str)：字符串的长度，也就是包含多少个字符                 |
| 2    | str.replace(old,new[,count])：返回字符串的副本，其中出现的所有子字符串old都被被替换为new，如果给出了可选参数count，则只替换前count次出现 |
| 3    | str.split(sep=None,maxsplit=-1)：返回一个由字符串内单词组成的列表，使用sep作为字符串分隔符。如果给出了maxsplit，则最多进行maxsplit次拆分（因此，列表最多会有maxsplit+1个元素）。如果maxsplit未指定为-1，则不限制拆分次数（进行所有可能的拆分） |
| 4    | str.count(sub)：统计指定字符串在字符串中出现的次数           |
| 5    | str.index(sub)：从字符串中找出指定字符串第一个匹配项的索引位置 |
| 6    | str.strip([chars])：返回原字符串的副本，移除其中的前导和末尾字符。chars为指定要移除字符的字符串 |
| 7    | str.lower()：返回原字符串小写的副本                          |
| 8    | str.upper()：返回原字符串大写的副本                          |

**字符串比较：**

- 运算符：> , >= , < , <= , == , !=
- 比较规则：首先比较两个字符串中的第一个字符，如果相等则继续比较下一个字符，依次比较下去，直到两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符将不再被比较。
- 比较原理：两个字符串进行比较时，比较的是其ordinal value（原始码/码值），调用内置函数ord()可以得到指定字符的ordinal value，与内置函数ord对应的的是内置函数chr，调用内置函数chr时指定ordinal value可以得到其对应的字符串。

### 切片操作

什么是切片：从一个序列中，取出一个子序列。

什么是序列：序列是指，内容连续、有序，可使用索引的一类数据容器，列表（list），元组（tuple），字符串都是序列。

```python
# 基本语法
序列[起始索引:结束索引:步长]  
#表示从序列中，从指定的起始索引开始，按照指定的步长，依次取出元素，到指定结束索引为止，截取到一个新的序列
#切片操作是前闭后开，也就是[起始索引:结束索引),即截取的子序列，包括起始索引，但是不包括结束索引的部分
#步长表示，依次取出元素的间隔
# -步长为1：一个一个的取出元素
# -步长为2：每次跳过一个元素取出
# -步长为N:每次跳过N-1个元素取

#案例对字符串进行切片
str = "hello,world"
#需求，截取“hello”
str_slice = str[0:5:1]   #起始索引0，结束索引5，步长1
```

**注意：**

1.切片的起始索引不写默认0，结束索引不行默认取到结尾，步长默认1

2.步长为负数，表示反向取，同时注意起始索引和结束索引也要反向标记。

3.切片操作并不会影响原序列，而是返回了一个新序列

### 集合（set）

集合是由**不重复元素**组成的**无序**容器。

集合对象支持合集、交集、差集等数学运算

创建一个集合，只要用逗号分隔的不同的数据项，并使用{ }括起来即可。

集合不支持索引，集合进行遍历不支持while，只支持for

创建空集合只能用set{}，不能用{}，{}创建的是空字典。

| 序号 | 集合常用操作                                                 |
| ---- | ------------------------------------------------------------ |
| 1    | len(set)：集合元素个数                                       |
| 2    | x in s：检测x是否为s中的成员                                 |
| 3    | set.add(elem)：将元素elem添加到集合中                        |
| 4    | set.remove(elem)：从集合中删除元素elem，如果elem不存在于集合，则会报错keyError |
| 5    | set.pop()：从集合中移除并返回任意一个元素（会影响原集合），如果集合为空会报错keyError |
| 6    | set.clear()：从集合中移除所有元素                            |
| 7    | set.union(others) ：返回一个新集合，其中包含来自原集合以及others指定的所有集合中的元素（求合集 set \| others） |
| 8    | set.intersection( others) ：返回一个新集合，其中包含原集合以及others指定的所有元素中共有的元素（求并集 set & others） |
| 9    | set.difference(others) ：返回一个新集合，其中包含原集合中在others指定的其他集合中不存在的元素（求差集 set - others） |

集合生成式基本语法：

{集合元素的表达式 for 自定义变量 in 可迭代对象}

```python
set1={ ele*2 for ele in range(1,5)}

# 生成的集合是 {2,4,6,8}
```

### 字典（dict）

字典（dict）也是一种常用的数据类型，在其他语言中可能吧字典称为联合内存或联合数组。

字典是一种映射关系，非常适合处理通过xx查询yy的需求，这里的xx我们称为key（键/关键字）,这里的yy我们称为Value（值），即key -- value的映射关系。

创建一个字段，只要把逗号分隔的不同的元素，用{}括起来即可，存储的元素是一个个的**键值对**，实例：

```python
dict_a={"key":"value","key1":"value1",...}
#通过key取出对应的value
dict_a[key]
```

注意事项：

1. 字典的key（关键字）通常是字符串或数字，value可以是任意数据类型。
2. 字典不支持索引，会报keyError
3. 既然字典不支持索引，所以对字典的遍历不支持while，只支持for，注意直接对字典进行遍历，遍历得到的是key

```python
dict_a={"one":1,"two":2,"three":3}
# 三种遍历方式
# 第一种通过key遍历
for k in dict_a:
    print("key:", k,"value:", dict_a[k])
    
# 第二种直接遍历value
for v in dict_a.values():
    print("value:", v)

# 第三种 通过k-v遍历
for k,v in dict_a.items():
    print("key:", k,"value:",v)
```

4. 创建空字典可以通过{}，或者dict()
5. 字典的key必须是唯一的，如果你指定了多个相同的key，后面的键值会覆盖前面的。

| 序号 | 字典常用操作                                                 |
| ---- | ------------------------------------------------------------ |
| 1    | len(d)：返回字典d中的项数                                    |
| 2    | d[key]：返回d中以key为键的项，如果key不存在报keyError错      |
| 3    | d[key]=value：将d[key]设为value，如果key已经存在，则是修改value，如果key没有存在，则是增加key-value |
| 4    | del d[key]：将d[key]从d中移除，如果映射中不存在key则会引发keyError |
| 5    | d.pop(key,[default])：如果key存在于字典中则将其移除并返回其值，否则返回default（会改变d）。如果default未给出且key不存在于字典中，则会引发keyError， |
| 6    | d.keys()：返回字典所有的key                                  |
| 7    | key in d：如果d中存在键key则返回True，否则返回False          |
| 8    | d. clear()：移除字典中的所有元素。                           |

字典生成式：

内置函数zip()：可以将可迭代的对象作为参数，将对象中对应的元素打包成一个元组，返回由这些元组组成的列表。

字典生成式语法：

````python
{ 字典key的表达式:字典value的表达式 for 表示key的变量，表示value的变量 in zip(可迭代对象，可迭代对象) }

#实例
books=["红楼梦","三国演义","西游记","水浒传"]
authors=["曹雪芹","罗贯中","吴承恩","施耐庵"]
{book:author for book,author in zip(books,authors)}
````

### 数据容器特定比较

| 比较项           | 列表(list)               | 元组(tuple)                | 字符串(str) | 集合(set)          | 字典(dict)                          |
| ---------------- | ------------------------ | -------------------------- | ----------- | ------------------ | ----------------------------------- |
| 是否支持多个元素 | Y                        | Y                          | Y           | Y                  | Y                                   |
| 元素类型         | 任意                     | 任意                       | 只支持字符  | 任意               | key：只支持字符串或数字，value:任意 |
| 是否支持元素重复 | Y                        | Y                          | Y           | N                  | key：不能重复，value：可以重复      |
| 是否有序         | Y                        | Y                          | Y           | N                  | 3.6前无序，3.6后开始支持有序        |
| 是否支持索引     | Y                        | Y                          | Y           | N                  | N                                   |
| 可修改性/可变性  | Y                        | N                          | N           | Y                  | Y                                   |
| 使用场景         | 可修改，可重复的多个数据 | 不可修改，可重复的多个数据 | 字符串      | 不可重复的多个数据 | 通过关键字查询对应数据的需求        |
| 定义符号         | []                       | ()                         | ""/''       | {}                 | {key:value}                         |

### **list，tuple，set，dict在函数中的传参机制**

![17561039847039](.\img\17561039847039.jpg)

结论：

1. python数据类型主要有整数int/浮点数float/字符串str/布尔值bool/列表list/元组tuple/字典dict/集合set,数据类型分为两大类，一种是可变数据类型，一种是不可变数据类型
2. 可变数据类型：当该数据类型的变量的值发生了变化，如果他的内存地址不变，那个这个数据类型就是可变数据类型。
   不可变数据类型：当该数据类型的变量的值发生了变化，如果它的内存地址改变了，那么这个数据类型就是不可变数据类型。
3. 不可变的数据类型：数值类型（int，float）、布尔（bool）、字符串（str），元组（tuple）
   可变数据类型：list（列表）、set（集合）、dict（字典）
4. 在Python中，全局变量是list（可变对象）时，在函数内修改其内容（如添加元素）不需要使用`global`关键字，但若要重新赋值（如改变引用），则必须声明`global`。而全局变量是int（不可变对象）时，任何修改（如赋值）都必须声明`global`。

## 十二、排序和查找

冒泡排序：重复的走访需要排序的元素列表，依次比较两个相邻的元素，如果顺序（从小到大或从大到小）错误就交换它们的位置。重复地进行直到没有相邻的元素需要交换，则元素列表排序完成。

```python
# 通过冒泡排序把列表元素从小到大排序
num_list = [19,24,50,13,80]
#定义函数，完成排序操作
def bubble_sort(my_list):
    #i控制循环轮数，循环轮数为元素个数-1
    for i in range(len(my_list)-1):
        #j控制循环次数，循环次数为循环轮数-j
        for j in range(len(my_list)-1-i):
            #如果前面的元素比后面的元素大，则交换位置
            if my_ist[j] > my_list[j+1]:
                my_ist[j], my_list[j+1] = my_ist[j+1], my_list[j]
# 调用函数
bubble_sort(num_list)
```

**顺序查找**

```python
#顺序查找示例
name_list = ["白眉鹰王","金毛狮王","紫衫龙王","青翼蝠王"]
find_name = "金毛狮王"

def seq_search(my_list,find_val):
    #如果找到就返回元素索引，否则返回-1
    find_index = -1
    for i in range(len(my_list)):
        if my_list[i] == find_val:
            find_index = i
            break
    else:
        print("没有找到")
    return find_index

#调用函数
seq_search(name_list,find_name)

#查找所有的，并把所有的元素索引返回
def seq_search2(my_list,find_val):
    #如果找到就添加到空列表中，直到所有元素查找完
    find_index = []
    for i in range(len(my_list)):
        if my_list[i] == find_val:
            find_index.append(i)
    return find_index
```

**二分查找**

二分查找思路：

1. 将列表排序(例如：从小到大)
2. 找到列表的中间数mid_val和find_val比较
3. 如果mid_val >find_val,则到mid_val的左边查找；如果mid_val <find_val,则到mid_val的右边查找；如果mid_val == find_val,则找到了，直接返回对应的下标即可。
4. 不断重复步骤3，这里就是不断的折半，使用while
5. 如果while结束，都没有找到，说明find_val没有在列表中

 ```python
 #二分查找代码
 num_list = [1,8,10,89,1000,1234]
 def binary_search(my_list,find_val)：
 	find_index = -1
 	left_index,right_index=0,len(my_list)-1
     #如果left_index小于等于right_index则可以继续查找
     while left_index <= right_index :
         mid_index = (eft_index+right_index)//2
         if my_list[mid_index] > find_val:
             right_index = mid_index - 1 #如果要找的值小于中间值，则，最右边的索引移动到中间值前一位
         elif my_list[mid_index]<find_val:
             left_index= mid_index + 1 #如果要找的值大于中间值，则最左边的索引移动到中间值后一位
         else: # 相等
             find_index = mid_index
             break
         return find_index
 ```

## 十三、模块和包

模块(module)是什么

模块是一个py文件，后缀名.py

模块可以定义函数，类和变量，模块里也可能包含可执行的代码

模块的作用有那些？

1. 当函数，类和变量很多时，可以很好的进行管理
2. 开发中，程序员可以根据业务需要，把同一类型的功能代码，写到一个模块文件中，既方便管理，又方便调用。 
3. 一个模块就是一个工具包，供程序员开发使用，提高开发效率
4. python自带标准模块库，每个模块可以帮助程序员快速实现相关功能

模块简介：https://docs.python.org/zh-cn/3.13/tutorial/index.html

模块索引：https://docs.python.org/zh-cn/3.13/py-modindex.html

### 导入模块

基本语法 `[from 模块名] import （函数 | 类 | 变量 | *） [as 别名]`

[]是可选项，可以根据需求，选择合适的形式进行导入

1. 导入一个或多个模块

   ```python
   import 模块
   import 模块1,模块2,...
   # 导入一个或多个模块，建议导入多个模块时，还是一行导入一个模块
   # 使用：模块.XX 方式来使用相关功能，.表示层级关系，即 模块中的XX
   # import 语句通常写在文件开头
   ```

   

2. 导入模块的指定功能

   ```python
   from 模块 import 函数、类、变量。。。
   # 使用：因为导入了具体函数，类，变量，直接使用即可，不需要再带模块名
   ```

3. 导入模块的全部功能

   ```python
   from 模块 import *
   # 使用：直接使用，不需要带模块名
   ```

4. 给导入的模块或者功能取别名

   ```python
   import 模块 as 别名
   from 模块 import 函数、类、变量.. as 别名
   # import 模块 as 别名：给导入的模块取别名，使用：别名.XX
   # from 模块 import 函数、类、变量.. as 别名:给导入的某个功能取别名，使用时，直接用别名即可
   ```

   

### 自定义模块

使用\__name__ 可以避免模块中测试代码的执行。

```python
if __name__ == "__main__": #使用__name__变量来判断模块是自行执行还是通过import导入执行
    测试程序()
```

在自定义模块中，没有 \__all__时，会导入所有的功能

使用了 \__all__ =['ok'] 在其它文件使用from 模块 import * 时只会导入ok

注意：import 模块方式，不受 \__all__ 的限制

###  包

基本介绍:1.从结构上看，包就是一个文件夹，在该文件夹下包含了一个\__init__.py文件，该文件夹可以用于包含多个模块文件，从逻辑上看，包可以视为模块集合

2.包的结构形式示意图

3.\__init__.py:控制包的导入操作

4.导入包&使用的基本语法

```python
#导入包
import 包名.模块
from 包名 import 模块
#使用
包名.模块.功能
模块.功能
```

5.在创建包的时候，选择python package 会自动生成\__init__.py文件

导入包的模块的指定函数、类、变量

```python
from 包名.模块 import 函数、类、变量
#此方法导入包的模块指定的函数、类、变量
#在使用时，直接调用 功能
# from 包名.模块 import *：表示导入包的模块的所有功能
```

6.\__init\_\_.py通过 \_\_all__ 控制允许导入的模块

在 \__init\_\_.py 中增加 \_\_all__ = [允许导入的模块列表]

针对from 包 import * 方式生效，对 import XX 方式不生效。

7.包可以有多个层级

包下还可以再创建包，在使用时，通过 . 来确定层级关系

8.快捷键 alt+enter / shift+alt+enter 可以快捷的导入包、模块

### 第三方库

1. 使用pip安装第三方库

   需要进入到命令行控制台

   语法：pip install 库名/包名

   pip 常用源地址

   ```python
   ‌清华大学‌：https://pypi.tuna.tsinghua.edu.cn/simple
   
   ‌阿里云‌：https://mirrors.aliyun.com/pypi/simple
   
   ‌中国科学技术大学‌：https://pypi.mirrors.ustc.edu.cn/simple
   
   ‌豆瓣‌：http://pypi.douban.com/simple
   ```

   指定源，安装第三方库

   pip install -i 指定源 库名/包名

2. 使用pycharm安装第三方库

​	IDE右下角python版本号--->右键---->解析器设置---->软件包

## 十四、面向对象编程（oop）

### 类和实例

类提供了把数据和功能绑定在一起的方式。创建新类时，就是创建了一个新的数据类型，创建改类的实例，就是创建了一个该新的数据类型，实例保有类的属性和功能，同时还能修改自身属性和功能。

### 类和对象的区别和联系

1. 类是抽象的，概念的，代表一类事物，比如人类，猫类...，即它是数据类型
2. 对象是具体的，实际的，代表一个具体事物，即 是实例
3. 类是对象的模板，对象是类的一个个体，对应一个实例

### 属性/成员变量

1. 类中定义的属性(变量),我们也称为：成员变量
2. 属性的类的一个组成部分，一般是字符串，数值，也可是其他类型（list，dict等），比如定义的cat类的name、age就是属性
3. 注意事项
   属性的定义语法同变量，实例：属性名 = 值，如果没有值，可以赋值None
   如果给属性指定的有值，那么创建的对象，属性就是值

### 对象的布尔值

python一切皆为对象，所有对象都有一个布尔值，通过内置函数bool()可以获取对象的布尔值

下面对象的布尔值为False

```python
1.False
2.数值0
3.None
4.空字符串
5.空列表
6.空字典
7.空元组
8.空集合
```

### 成员方法

类中定义的行为(函数),我们称为：成员方法

在类中定义成员方法和前面学习过的定义函数，基本上是一样的（原理和运行机制是一样），但是还有点不同（形式上有不同）。

基本语法

```python 
def 方法名(self,形参列表):
​	方法体
```

动态的给对象添加方法

```python
#定义类
class person:
    name=None
    age=None
#定义方法    
def hi():
    print("hi,python")
#创建实例对象p    
p=person()
#仅对对象p，动态添加方法act和hi函数关联
p.act = hi
#调用动态方法
p.act()
```

### self

- 在定义成员方法的参数列表中，有一个self，需要写上的，如果不写，则需要使用@staticmethod标注，否则会报错，（@staticmethod会将方法转成静态方法）

- self表示当前对象本身，简单的说，那个对象调用，self就代表那个对象

- 当我们通过对象调用方法时，self会隐式的传入
- 在成员方法内，访问对象的属性/成员变量，使用self

```python
class Dog:
    name="波斯猫"
    age = 2
    def info(self,name):
        print(f"name信息:{name}") #加菲猫
        print(f"成员变量name:{self.name}") #波斯猫
        
dog = Dog()
dog.info("加菲猫")
```

**对象传参机制**

![wechat_2025-08-27_144719_251](.\img\wechat_2025-08-27_144719_251.png)

结论:对象作为参数传递时（传递的是对象的内存地址），是可变的，方法内修改对象的属性，方法外改对象的属性也会跟着变化。

**作用域**

对象内的全局变量（成员属性/变量）和局部变量（成员方法内定义的变量）

成员属性/变量在对象内是全局的，成员方法都可以使用，成员方法内定义的变量是局部的，只能在该方法内使用。

全局变量和局部变量是可以重名的，带上`self.`的是全部变量，不带的就是局部变量

### 构造方法

```python
# 构造方法基本语法：
def __init__(self,参数列表):
    代码...
```

构造方法解读：

1. 在初始化对象时，会自动执行`__init__`方法
2. 在初始化对象时，将传入的参数，自动传递给`__init__`方法
3. 完成对象的初始化任务

注意事项：

1. 一个类只有一个`__init__`方法，即使你写了多个，也只有最后一个生效
2. python 可以动态的生成对象属性
3. 构造方法不能有返回值

### oop的三大特征

面向对象编程有三大特征：封装、继承和多态

1. **封装（encapsulation）**

封装（encapsulation）就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，程序只有通过被授权的操作，才能对数据进行访问

封装的好处：

- 隐藏实现细节：方法<--调用（传入参数）
- 可以对数据进行验证（比如age：1-120，password长度要求等），保证安全合理
- 可以保护数据隐私，要求授权才可以访问

属性/方法 进行私有化

- 类中的变量或方法以双下划线`__`开头命名，则该变量或方法为私有的，私有的变量或方法，只能在本类内部使用，类的外部无法使用
- 如何访问私有的属性/方法：提供公共的方法，用于对私有成员的操作

注意实现：

python语言的动态特征，会出现伪私有属性的情况

```python
class Clerk:
    name =  None
    __job = None #定义私有属性__job
    __salary = None

    def __init__(self,name, job, salary):
        self.name = name
        self.__job = job
        self.__salary = salary

    def set_job(self, job):
        self.__job = job

    def get_job(self):
        return self.__job

clerk = Clerk("tiger", "Python工程师", 20000)
# 动态的创建__job属性，但是它和类中的私有属性__job并不是同一个变量
clerk.__job = "Go工程师"
print(f"job={clerk.__job}") #所以结果可以正常输出
```

2. **继承（inheritance）**
   继承可以解决代码复用，让我们的编程更加靠近人类思维
   当多个类存在相同的属性(成员变量)和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法
   继承示意图
   ![QQ20250828-165425](.\img\QQ20250828-165425.jpg)
   继承的基本语法：

   ```python
   class DerivedClassName(BaseClassName):
       <statement-1>
   	...
   ```

   继承的注意事项：

   - 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问，但是私有属性和方法不能在子类中直接访问，要通过分类提供公共的方法区访问

   - python编程语言中，“object”是所有其它类的基类（通过ctrl+H查看继承关系）

   - python支持多重继承

     ```python
     # 一个子类可以继承多个父类，多个父类用逗号分隔
     class DerivedClassName(Base1,Base2,Base3): 
         <statement-1>
     	...
     ```

   - 在多重继承中，如果有同名的成员，遵守从左到右的继承优先级（即：写在左边的父类优先级高，写在右边的父类优先级低）
     **调用父类成员**
   
     如果子类和父类出现同名的成员，可以通过父类名、super()访问父类的成员。
     基本语法：
     访问父类成员方式1
   
     ```python
     # 访问成员变量：父类名.成员变量
     # 访问成员方法：父类名.成员方法(self)
     ```
   
     访问父类成员方式2
   
     ```python
     # 访问成员变量：super().成员变量
     # 访问成员方法：super().成员方法()
     ```
   
     访问不限于直接父类，而是建立从子类向上级父类的查找关系A->B->C
   
     建议使用方式2，万一父类的名称变化，方式1都要跟着修改，方式2则不受影响 
   
     **重写**
   
     重写又称覆盖（override）即子类继承父类的属性和方法后，根据业务需求，再重新定义同名的属性或方法。
   
     **类型注解**
   
     随着项目越来越大，代码也就会越来越多，在这种情况下，如果没有类型注解，很容易不记得某一个方法的参数类型是什么，一旦传入错误类型的参数，python是解释性语言，只有运行时候才能发现问题，这对大型项目来说是一个巨大的灾难。
     ```python
     def fun1(a:str): #这里的a:str就是给形参a进行类型注解，标注a的类型是str
         for ele in a:
             print(ele)
     ```
   
     - 变量类型注解
       格式`变量:类型`
     
     -  实例对象类型注解
       格式`对象名称:类名`
     
     - 容器类型注解
       格式`容器名:容器类型`
     
     - 容器详细类型注解
       格式`容器名:容器类型[元素类型]`
     
       ```python
       # 容器详细类型注解示例
       my_list2:list[int] = [100,200,300]
       my_tuple2:tuple[str,str,str,float] = ("run","sing","dance",2.5)
       my_set:set[str] = {"jack","tim","john"}
       my_dict:dict[str,int] = {"no1":100,"no2":200}
       ```
     
     - 在注释中使用注解
       格式`# type:类型`
     
     - 函数（方法）的类型注解
     
       基本语法
     
       ```python
       def 函数/方法名(形参名:类型,形参名:类型...)->返回值类型:
           函数/方法体
       ```
     
       类型注解是提示性的，并不是强制性的，如果你给的类型和指定/标注的类型不一致，pycharm检测到会给出黄色警告，但是仍然可以运行
     
     - union类型注解
       union类型可以定义联合类型注解
       在变量、函数（方法）都可以使用union联合类型注解
       使用时，需要先导入Union：`from typing import Union`
       基本语法：`Union[类型,类型...]`
     
       ```python
       from typing import Union
       a:Union[int,float] = 100
       # Union[int,float] 等价于 int|float，意味着int或float都可以
       my_list:list[Union[int,str,float]] = [100,200,'jack','tom',9.6]
       ```
     
       
   
3. **多态**
   多态顾名思义即多种状态，不同的对象调用相同的方法，表现出不同的状态，成为多态
   多态通常作用在继承关系上
   解读：一个父类，具有多个子类，不同的子类对象调用相同的方法，执行的时候产生不同的状态，就是多态
   多态特点：
   python中函数/方法的参数是没有类型现在的，所以多态在python中的体现并不是很严谨
   python并不要求严格的继承体系，关注的不是对象的类型本身，而是它是否具有要调用的方法（行为）

```python
class Aa:
    def hi():
        print("Aa say hello")
     
class Bb:
    def hi():
        print("Bb say hello")
        
def fun(obj):
    obj.hi()
    
a = Aa()
b = Bb()

fun(a)  #此时程序是可以执行成功的，只要a对象的类有hi方法即可
fun(b)

```

**isinstance函数**

isinstance()用于判断对象是否为某个类或其子类的对象
基本语法：`isinstance(object,classinfo)`object:对象，classinfo：可以是类名，基本类型或者由它们组成的元组

```python
num = 9
# 表示num是否是int类或int子类的对象
print(f"num 是不是int：{insinstance(num, int)}") #True 
print(f"num 是不是int：{insinstance(num, str)}") #False
print(f"num 是不是int/str/list：{insinstance(num, (int,str,list))}") #True
```

当调用对象成员的时候，会和对象本身动态关联

```python
class A:
    i = 10
    def sum(self):
        return self.i += 10
    def sum1(self):
        return self.getI() += 10
    def getI(self):
        return self.i
class B(A):
    i = 20
    def getI(self):
        return self.i
num = B()
num.sum() #num是B类的对象，运行sum方法，B类中没有就到父类A中去找，此时sum(self)中的self动态绑定的就是B类，并不是A类，所以结果是30
num.sum1() #同理，sum1(self)中的self也是B类，所以下面的getI(self)是调用B类的方法，结果也是30
```

**魔术方法**

在python中，所有以`__`包起来的方法，统称为Magic Method（魔术方法）,它是一种特殊的方法，普通方法需要调用，而魔术方法不需要调用就可以自动执行。

魔术方法在类或对象的某些事件发生时会自动执行，让类具有神奇的“魔力”，如果希望根据自己的程序定制特殊功能的类，那么就需要对这些方法进行重写。

python中常用的运算符，for循环，以及类操作等都是运行在魔术方法之上的

| 常用魔术方法         | 操作                                           |
| -------------------- | ---------------------------------------------- |
| `__init__`           | 初始化对象的成员                               |
| `__str__(self)`      | 定义对象转字符串行为：print(对象)或者str(对象) |
| `__eq__(self,other)` | 定义等于号的行为:x==y                          |
| `__lt__(self,other)` | 定义小于号的行为:x<y                           |
| `__le__(self,other)` | 定义校友等于号的行为:x<=y                      |
| `__ne__(self,other)` | 定义不等号的行为:x!=y                          |
| `__gt__(self,other)` | 定义大于号的行为:x>y                           |
| `__ge__(self,other)` | 定义大于等于号的行为:x>=y                      |

```python
#重写 __eq__魔术方法示例：
class Person:
    def __init__(self,name,age,gender):
        self.name = name
        self.age = age
        self.gender = gender
     #3.重写__eq__魔术方法
    def __eq__(self,other):
        #首先判断other和self是否是同一个类
        if isinstance(other,Person):
            #再比较内容是否相同，这样更为合理
       		 return (self.name == other.name and 
                self.age == other.age and 
                self.gender == other.gender)
         return False
    
p1=Person('smith',20,'man')
p2=Person('smith',20,'man')
print(f"p1 == p2:{p1==p2}") # 1.两个对象比较其实是比较两个对象的内存地址是否是相等
#2.目前的需求是想知道两个对象的属性是否是一样的，那就需要重写__eq__魔术方法
#4.重写魔术方法后再比较就是True了
```

### class对象和静态方法

类本身也是对象，即class对象。

通过类名调用非静态成员方法

```python
类名.非静态方法(类对象)
```

一个普通方法使用@staticmethod将转换成静态方法，静态方法不会接收隐式的第一个参数，要声明一个静态方法，语法：
```python
class C:
    @staticmethod
    def f(arg1,arg2,argN):
        ....
```

静态方法既可以由类调用（如C.f()）,也可以由实例中调用（如C().f()）。

### 抽象类

默认情况下，python不提供抽象类，python附带一个模块，该模块为定义抽象类提供了基础，该模块名为abc

当我们需要抽象基类时，让类继承ABC(abc模块的ABC类)，使用@abstractmethod声明抽象方法（@abstractmethod用于声明抽象方法的装饰器，在abc模块中），那么这个类就是抽象类

抽象类的价值更多作用是在于设计，是设计者设计好后，让子类继承并实现抽象类的抽象方法 

```python
form abc import ABC,abstractmethod
class Aminal(ABC): #抽象类需要继承ABC类
    @abstractmethod
    def cry(self): #抽象方法需要@abstractmethod装饰器
        pass
    
class Tiger(Aminal): # 继承抽象类的类来实现具体的功能
    def cry(self):
        print("老虎 嗷嗷叫...")
        
tiger = Tiger() #实例化Tiger类
tiger.cry() #调用cry方法
```



注意：

1. 抽象类（含有抽象方法），不能实例化
2. 抽象类需要继承ABC，并且需要至少一个抽象方法
3. 抽象类中可以有普通方法
4. 如果一个类继承了抽象类，则它必须实现抽象类的所有抽象方法，否则它仍然是一个抽象类

### 模块开发和oop开发总结

1. 基于模块开发：将系统分为不同的模块，不同模块完成不同的任务/功能，用函数的方式进行管理和组织项目
2. OOP分层模式：将系统分为 界面层，业务层，数据层，不同的层完成不同的任务/功能，并以OOP的方式进行管理和组织项目
3. 两种方式从形式上看有区别，但编程思想是一样的，都是采用分而治之的方式，将一个系统/项目划分不同的部分，方便实现、扩展、可读、和管理（即：不能把所有的代码/功能都放在一起，那样就乱了）
4. 两种方式没有严格的界限，比如基于模块开发时，也可以按照层来划分，同样OOP分层模式，也可以调用模块中的函数
5. 如何选择的建议：根据业务需求和项目大小来定（比如完成一个很小的功能或小项目，可以考虑模块开发，大型项目，考虑分层模式）

## 十五、错误与异常

错误是指语法错误又称句法错误

异常：程序使用了正确的语法，执行时仍可能触发错误，执行时检测到的错误称为异常。

错误和异常的区别：句法错误/语法错误 在执行前，编译器就可以检测到，而异常是执行时检测到的

捕获异常语法

```python
try:
    可能出现异常的代码
except [Exception as 别名]:
    #捕获异常，如果上面的代码出现异常就会进入此代码块，程序开发者可以根据自己的需求处理异常
    #处理完后，代码继续往下执行，不至于使程序中断
[else:]
	#可选，没有发生异常，执行的代码
[finally:]
	#可选，不管有没有异常，都要执行的代码
```

### 常见异常

1. IndexError：当序列抽取超出范围时将被触发，也就是索引错误
2. KeyError：当在现有键集合中找不到指定的映射（字典）键时将被引发
3. NameError：当某个局部或全局名称未找到时将被引发，比如使用了一个没有定义的变量名
4. TypeError：当一个操作或函数使用了类型不适当的对象时将被引发
5. ValueError：当操作或函数接收到具有正确类型但值不适合的参数时将被引发
6. ZeroDivisionError：当除法或取余运算的第二个参数为零时将被引发
7. FileNotFoundError：请求的文件或目录不存在时将被引发
8. AttributeError：当属性引用或赋值失败时将被引发

异常注意细节：

1.如果异常发生了，则异常发生后面的代码不会执行，直接进入except子句

```python
num1 - 10
num2 = 0
try:
    res = num1 / num2  #此次触发异常
    print("hi....")  #此次不会执行，直接跳到捕获异常
except Exception as e:
    print(f"出现了异常 异常信息->{e}") #输出异常处理
    
print("继续执行...") #异常捕获后继续执行其他的语句
```

2.如果未发生异常，则执行try的代码块，不会进入到except子句

3.如果希望没有发生异常是，要执行某段代码，则使用else子句

4.如果希望不管是否发生异常，都执行某段代码（比如关闭连接，释放资源等）则使用finally子句

5.可以有多个except子句，捕获不同的异常（进行不同的业务处理），如果发生异常，只会匹配一个except，建议吧具体的异常写在前面，基类异常在后比如（IndexError在前，Exception在后），这样当具体异常匹配不到时，再由基类异常匹配

6.一个except子句，也可以捕获不同的异常

```python
# 通过异常来做数据验证
a = 0
while True:
    try:
        a = int(input("请输入年龄:"))
        break
     except Exception as e:
        print("你输入的不是整数，请重新输入")
        
print(f"您输入的年龄是{a}")
```



### 主动抛出异常

```python
# 可以使用raise语句主动抛出异常
try：
	raise NameError("错误信息详情")
except NameError:
    捕获异常...
```

### 异常的传递

如果一个异常发生了，但是没有捕获处理异常，那个这个异常会传递给调用者处理，如果所有的调用者都没有处理，最终会由系统处理（中止程序并报错）。

### 自定义异常

1.程序可以通过创建新的异常类命名自己的异常。不论是以直接还是间接的方式，异常都应从Exception类派生

2.异常类通常应当保持简单，它往往只提供一些属性，允许相应的异常处理程序提取有关错误的信息。

3.大多数异常命名都以“Error”结尾，类似标准异常的命名，但是需要注意不要使用内置异常名

```python
# 自定义异常案例
class AgeError(Exception): #构建自定义异常
    pass
while True:
    try:
        age = int(input('请输入年龄（18-120）：'))
        if not (18<=age<=120):
            raise AgeError("年龄需要在18-120之间")
        break
     except ValueError as e:
        print("你输入的不是整数")
     except AgeError as e:
        print(e)
        
print(f"你输入的年龄是{age}")
```

## 十六、文件处理

### 文件输入与输出

输入：数据从数据源（文件）到程序（内存），读文件

输出：数据从程序（内存）到数据源（文件），写文件

I/O类型：

1. python用于处理各种I/O（Input/Output）类型,主要的I/O类型分别为：文本I/O，二进制I/O，也分别对应处理的文件对象类型：文本文件、二进制文件
2. 文本文件：通常是记事本可以直接打开的，比如.py .txt等文件
3. 二进制文件：比如图片，视频，音频等
4. 在处理不同类型的文件时，需要用对应的方式打开处理

### 常用文件操作

| 序号 | 文件操作                                                     |
| ---- | ------------------------------------------------------------ |
| 1    | open(fiel,mode='r',buffering=-1,encoding=None,errors=None,newline=None,closefd=True,operer=None):<br />1.打开file并返回对应的file object。如果该文件不能被打开，则引发OSError<br />2.file表示将要打开的文件的路径（绝对路径或者相对当前工作目录的路径）<br />3.mode是文件打开的模式<br />4.buffering是一个可选的整数，用于设置缓冲策略<br />5.open方法最常使用的是两个位置参数和一个关键字参数open(filename,mode,encoding=None)第一个实参是文件名字符串。第二个市场是包含描述文件使用方式字符的字符串。mode的值包含'r'表示文件只能读取，'w'表示只能写入（同文件名会覆盖），'a'表示打开文件并追加，写入的数据会自动添加到文件末尾，'r+'表示打开文件进行读写。'b'以二进制打开文件，mode实参是可选的，省略时默认值为'r'。<br />通常情况下，文件是以text mode打开的，也就是说，你从文件中读写字符串，这些字符串是以特定的encoding编码的，如果没有指定encoding，默认是的与平台有关的。因为utf-8是现代事实上的标准，除非你知道你需要使用一个不同的编码，否则建议使用encoding = “utf-8”。当mode为’b‘时，表示以二进制模式打开文件，此时不能指定encoding。 |
| 2    | f.read(size)：可用于读取文件内容，它会读取一些数据，并返回字符串（文本模式），或字节串对象（二进制模式）。size是可选的数值参数，省略size或size为负数时，读取并返回整个文件的内容 |
| 3    | f.readline()：从文件中读取单行数据，字符串末尾保留换行符（\n） |
| 4    | 如需以列表形式读取文件中的所有行，可以用list(f)或f.readlines() |
| 5    | for line in f:从文件中读取多行时，可以用循环遍历整个文件对象。这种操作能高效利用内存且代码简单 |
| 6    | f.write(string)：把string的内容写入文件，并返回写入的字符串  |
| 7    | f.flush()：刷新流的写入缓冲区                                |
| 8    | f.close()：刷新并关闭此流。即可释放文件占用的系统资源，如果文件已关闭，此方法无效。文件关闭后，对文件的任何操作都会引发ValueError |
| 9    | with open() as f：在处理文件对象时，最好使用with关键字。优点是，子句体结束后，文件会自动关闭 |

`open(file,mode="w",enconding="utf-8")` `mode="w"`打开文件，如果文件不存在，会创建，如果文件已经存在，会先截断打开的文件，也就是清空文件内容。

如果我们希望以追加的方式写入，需要`mode='a'`

### 目录操作

`os.path.exists(file)`判断文件或目录是否存在

`os.remove(file)`删除文件

`os.mkdir(path)`创建单级目录

`os.makedirs(path)`递归创建多级目录

`os.rmdir(path)`删除目录

`os.removedirs(path)`递归删除多级目录

`os.path.isdir(path)`判断目录是否存在

`os.path.rename(path)`重命名给定的文件或目录

`os.stat(path)`获取文件或文件描述符的状态，返回一个stat_result对象

目录操作的注意事项：

1.f.flush():刷新流的写入缓冲区到文件

- 调用f.wirte()，内容并没有真正写入到文件，而是先积攒到缓存区
- 当调用flush()时，内容会真正写入到文件
- 这样是为了避免频繁的操作硬盘，导致效率低（积攒一定量的数据，一次性写入文件，提高效率）

2.f.close()：刷新并关闭此流，也就是f.close()内置的flush功能

3.`with open() as f:`在处理文件对象时，子句结束后，文件会自动关闭

4.关于目录分隔符号，在windows下`/`和`//`都可以，比如`d://aaa//bbb//hi.txt`和`d:/aaa/bbb/hi.txt`，linux/unix是`/`比如`/roor/home/aa.log`因此建议目录分隔符，为了兼容linux和windows都使用`/`

### pyecharts

文档地址：https://pyecharts.org/#/zh-cn/intro

实例文档地址：https://gallery.pyecharts.org/#/README

## 网络处理urllib

urllib用于处理网络访问的包，常用方法urllib.request

获取页面信息`response = urllib.request.openurl(url,[data],[timeout, ]*, context=None)`返回的对象可以用`response.header`返回头，`response.status`返回状态，`response.info`返回信息，`response.read()`读取返回的内容等。

模拟人操作网络，隐藏python处理网络可以有两个方法

- 通过Request的headers参数修改

  ```python
  headers={}
  # 模拟浏览器的参数
  headers['User-Agent']="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.95 Safari/537.36"
  # 对URL发送带data（application/x-www-form-urlencoded格式）参数的post请求
  response = urllib.request.Request(url, data=None, header, origin_req_host=None, unverifiable=False, method=None)
  ```

- 通过request.add_header()方法修改

  ```python
  req = urllib.request.Request(url,data)
  # 动态添加header
  req.add_header('User-Agent',"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.95 Safari/537.36")
  ```

修改了默认的Request方法后再调用urllib.request.openurl()即可。

```python
# 模拟浏览器访问url 实例
import urllib
request = urllib.request.Request('http://chaipip.com')
request.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.6261.95 Safari/537.36')
response = urllib.request.urlopen(request)
html = response.read().decode('utf-8')
print(html)
```



### 代理

防止网络请求频繁被请求的服务器封禁我们的ip可以使用代理来更换不同ip来访问。

步骤：

1. 创建一个字段参数{"类型":"代理ip:端口号"}，配置代理服务器`proxy_support = urllib.request.ProxyHandler({})`

2. 定制、创建一个带代理的opener
   `opener = urllib.request.build_opener(proxy_support)`

3. 安装opener
   `urllib.request.install_opener(opener)`

4. 调用opener访问url
   `opener.open(url)`

   

## Scrapy爬虫框架

使用scrapy抓取一个网站一共需要四个步骤：

- 创建一个scrapy项目

  ```python
  # 命令行运行命令
  scrapy startproject <项目名称>
  
  #测试爬取
  scrapy crawl <spider名>
  
  # 保存爬虫数据到本地
  scrapy crawl jjwxc -o items.json -t json
  ```

  

- 定义item容器
  xpath()：xpath表达式获取节点列表
  css()：css表达式获取节点列表
  extract()：序列化节点为Unicode字符串并返回list
  re()：根据正则表达式对数据提取，并返回Unicode字符串列表

- 编写爬虫

- 存储内容

65
