# Python学习笔记

## 一、快速入门案例

用cmd解释器，写出hell world

```python
>>> print("hello world")
hello world
```

用记事本，可发一个hello.py程序，可以输出hello world

```python
#python程序文件的后缀是.py
#print语句的作用是输出内容，输出的内容就是（）内写的内容
#在python中使用#表示注释，及对代码的说明，但是不会被执行

print("hello world")

执行方法：python/py 文件名
PS E:\学习笔记\python_code> python hello.py
hello world
PS E:\学习笔记\python_code> py hello.py
hello world
```

## 二、注意事项

1.python 文件默认以.py做文件名，但不强制，以其他文件名也可以执行

2.python程序默认情况是按顺序执行的

3.python语言区分大小写

4.python程序由一条条语句构成，每条语句后不需要以`;`结束，但是如果带上`;`也不会报错，建议不带`;`(规范)

## 三、pycharm快捷键

1. 删除当前行快捷键：`shift+delete`
2. 复制当前行：`ctrl+D`
3. 添加注释和取消注销：`ctrl+/`
4. 快速格式化代码：`ctrl+alt+L`
5. 快速运行程序，默认是`ctrl+shift+F10/shift+10` 自己定义 `alt+R`
6. 查看类的层级关系：`crtl+H`
7. 拷贝/粘贴/剪切：`ctrl+C/V/X`
8. 查找：`ctrl+F`，替换：`ctrl+R`

## 四、转义字符

- `\t `： 一个制表位，实现对齐的功能
- `\n` ：换行符
- `\\`：一个\
- `\"`：一个"
- `\'`： 一个'
- `\r`：一个回车

## 五、注释

单行注释：`#`

多行注释：`'''注释内容‘’‘`（三组单引号）或者`"""注释内容"""`（三组双引号）

文件编码声明注释：`# coding:编码` 用于指定文件的编码类型，只能放到文件的开头

**python文档：https://docs.python.org/zh-cn/3.13/**

## 六、变量

变量三要素：类型，名称，值

`type(a)` 输出变量a的类型

### 变量格式化输出

- %操作符

  ```python
  age = 20
  score = 78
  sex = "男"
  name = "张三"
  # %操作符输出
  print("姓名：%s %d %s %.1f" % (name,age,sex,score))
  
  # %s 代表输出字符串
  # %d 代表输出整数
  # %.nf 代表输出n位的浮点数
  ```

- format()函数,不用关心数据类型

  ```py
  print("姓名：{} {} {}" .format(name,sex,score))
  ```

- f-strings，自动搜索变量，不关心数据类型，推荐使用

  ```python
  print(f"姓名：{name} {sex} {score}")
  ```

**加号的使用**

如果加号两边是字符串，则是作为连接符，如果两边是数值类型则做加法运算。

### **数据类型**

python中的变量再试用期都必须赋值，变量赋值以后该变量才会被创建。

我们所说的“类型”是变量所指的内存数据的类型。

python的数据类型包括：整型，浮点型，布尔，字符串

 python 的int类型可以存放4300位的整数，python的整数有十进制，十六进制，八进制和二进制。

十六进制写法：加前缀0x，由0-9和A-F的数字和字母组合

八进制写法：加前缀0o，由0-7数字组合

二进制写法：加前缀0b，只有0和1数字组合

运行时，会自动转换成十进制输出。

```python
# 10进制
print(10)

#16进制
print(0x10)

#8进制
print(0o10)

#2进制
print(0b10)
```

python中整型占多少字节？

1.字节数随着数字增大而增大（即：python整型是变长的）

2.每次的增量是4个字节

```python
# 在python中可以通过sys.getsizeof(obj)返回obj的大小（按照字节单位返回）
p = 2**10   # 2**10 就是2的10次方
print({sys.getsizeof(p)})
# 返回结果：40
```

科学计数法浮点数

5.12e2 = 5.12X10的2次方

5.12e-2 =  5.12/10的2次方

浮点数大小限制

float_info.max = 1.7976931348623157e+308

float_info.min = 2.2250738585072014e-308

浮动类型计算后，存在精度的损失，可以使用Decimal类进行精确计算

**布尔类型注意事项：**

布尔类型可以和其他数据类型进行比较，比如数字，字符串等，在比较时，python会将ture视为1，false视为0.

在python中，非0被视为真，0值被视为假值

**字符串注意事项：**

python 不支持单字符类型，单字符在python中也是作为一个字符串使用

用三个单引号`'''内容'''`或三个双引号`"""内容"""`可以使字符串内容保持原样输出

```python
# 原样输出字符串
cont = """
def any(iterable):
    for element in iterable:
        if element:
            return True
    return False
"""
print(cont)
```

在字符串前面加`'r'`可以使整个字符串不会被转义。

```python
str=r"jack \n tom \t jeron"
print(str)
jack \n tom \t jeron
```

### 字符串驻留机制

python仅保存一份相同且不可变字符串，不同的值被存放在字符串的驻留池中，python的驻留机制对相同的字符串只保留一份拷贝，后续创建相同字符串时，不会开辟新空间，而是把该字符串的地址赋给新创建的变量

```python
str1 = "hello"
str2 = "hello"
str3 = "hello"
#id()函数，可以返回对象/数据的内存地址
print("str1的地址：", id(str1))
print("str2的地址：", id(str2))
print("str3的地址：", id(str3))
str1的地址： 1965951195328
str2的地址： 1965951195328
str3的地址： 1965951195328
```

驻留机制的几种情况：

1.字符串是由26个英文字母大小写，0-9，_组成

2.字符串长度为0或者1时

3.字符串在编译时进行驻留，而非运行时

```python
a = "abc"
b = "".join(["a","bc"])
print(a)
abc
print(b)
adc  
id(a)
1409056
id(b)
194784
# a 和 b的结果虽然一样，但是a是编译时就是abc，b是运行时才是abc，所以不会驻留
```

4.[-5至256]的整数数字

5.sys中的intern方法可以强制两个字符串指向同一个对象

```python
import sys
s1 = "abc#"
s2 = sys.intern(s1) 
```

6.pycharm对字符串进行了优化处理，相同字符串依然会驻留

```python
str1 = "abc#"
str2 = "abc#"
print(id(str1) == id(str2))
True
```

字符串驻留机制的好处：

当需要值相同的字符串时，可以直接从字符串池里拿来使用，避免频繁的创建和销毁，提升效率和节约内存

### 数据类型转换

- 隐式类型转换
  python变量的类型不是固定的，会根据变量当前值在运行时决定，可以通过内置函数type(变量)来查看其类型，这种方式就是隐式转换，也称为自动转换

```python
var1 = 10
print(type(var1)) #int
var1 = 1.1
print(type(var1)) #float
var1 = "XXX"
print(type(var1)) #str
```

- 显式类型转换

​	如果需要对变量数据类型进行转换，只需要将数据类型作为函数名即可，这种方式就是显式转换/强制转换。

| **函数**             | **作用**                                                     |
| -------------------- | ------------------------------------------------------------ |
| `int(x, base=10) `   | 将X转换为一个整型变量，base参数为可选项，用来决定转化后的进制 ，默认为十进制 |
| ` long(x, base=10) ` | 将X转换为一个长整型变量（比int的范围更大），base参数为可选项，用来决定转化后的进制，默认为十进制 |
| ` float(x)`          | 将X转换为一个浮点数                                          |
| `str(object)`        | 将对象object转换为字符串                                     |
| `repr(object) `      | 将对象object转换为表达式字符串                               |
| `eval(str) `         | 用来计算在字符串str中的有效python表达式，并返回一个对象      |
| `tuple(seq) `        | 将序列seq转换为一个元组                                      |
| `list(seq)`          | 将序列seq转换为一个列表                                      |
| ` chr(x)`            | 将一个整数转换为一个字符                                     |
| `unichr(x)`          | 将一个整数转换为一个Unicode字符                              |
| ` ord(x)`            | 将一个字符转换为它的整数值                                   |
| ` hex(x)`            | 将一个整数转换为一个十六进制字符串                           |
| `oct(x)`             | 将一个整数转换为一个八进制字符串                             |

显式类型转换注意事项：

1.不管什么值的int，float都可以转成str，str(x)将对象x转换成字符串

2.int转成float时，会增加小数部分，比如12-->12.0,float转成int时，会去掉小数部分，比如123.65-->123

3.str转int，float使用int(x),float(x)将对象x转换成int/float,在将str类型转成基本数据类型时，要确保str值能够转成有效的数据，比如我们可以将"123".转成一个整数，但是不能把"hello"转成一个整数，"12.3"也不能转成一个整数，如果格式不正确，程序会报valueError。

4.对一个变量进行强制转换，会返回一个数据/值，注意，强制转换后，并不会影响原变量的数据类型（即不会影响原变量指向的数据/值的数据类型）。

```python
i = 10
j = float(i) #j 会开辟一个新的内存空间，存储float(i)的结果，并不会改变原来i的值
```

## 七、运算符

### 算术运算符

| 运算符 | 运算                                 | 范例            |
| ------ | ------------------------------------ | --------------- |
| +      | 加                                   | 5+5=10          |
| -      | 减                                   | 6-4=2           |
| *      | 乘                                   | 3*4=12          |
| /      | 除                                   | 5/5=1           |
| %      | 取模（取余）                         | 7%5=2           |
| //     | 取整除（返回商的整数部分，向下取整） | 9//2=4,-9//2=-5 |
| **     | 幂                                   | 2**3=8          |

```python
# 当对一个数取模时，对应的运算公式是：a%b = a-a//b*b
print(-10%3) 
# 计算过程：-10 -（-10）//3*3 => -10 - (-4)*3 =>-10 -(-12) => 2
print(10%-3) 
# 计算过程：10 -10//(-3)*(-3) => 10 - (-4)*(-3) => 10-12 => -2
print(-10%-3) => -1
print(10%3) => 1
```

练习题：

1.假如还有97天放假，问：合多少个星期零多少天？

2.华氏温度转摄氏温度的公式：5/9*（华氏温度-100），求234.5华氏温度是多少摄氏度？

### 赋值运算符

| 运算符 | 描述                 | 实例               |
| ------ | -------------------- | ------------------ |
| =      | 简单的赋值运算符     | c=a+b              |
| +=     | 复合加法赋值运算符   | c+=a等效于c=c+a    |
| -=     | 复合减法赋值运算符   | c-=a等效于c=c-a    |
| *=     | 复合乘法赋值运算符   | c\*=a等效于c=c*a   |
| /=     | 复合除法赋值运算符   | c/=a等效于c=c/a    |
| %=     | 复合取模赋值运算符   | c%=a等效于c=c%a    |
| **=    | 复合幂赋值运算符     | c\**=a等效于c=c**a |
| //=    | 复合取整除赋值运算符 | c//=a等效于c=c//a  |

python 中支持一个简单的方式实现变量交换 x,y = y,x

python是一种极简主义的边陲语言，它没有引入？：这个运算符，而是使用if else关键字来实现相同的功能

语法是` max = a if a>b else b`

```python
# 用三元运算求两个数的较大值
a = 10
b = 80
max = a if a > b else b
print("较大值是", max)
```



### 比较运算符

| 运算符 | 运算                             | 范例 | 结果  |
| ------ | -------------------------------- | ---- | ----- |
| ==     | 等于                             | 4==3 | false |
| !=     | 不等于                           | 4!=3 | true  |
| <      | 小于                             | 4<3  | false |
| >      | 大于                             | 4>3  | true  |
| <=     | 小于等于                         | 4<=3 | false |
| >=     | 大于等于                         | 4>=3 | true  |
| is     | 判断两个变量引用对象是否为同一个 |      |       |
| is not | 判断两个变量引用对象是否不同     |      |       |

注意：比较运算符的结果要么是true，要么是false

比较运算符组成的表达式，我们称为比较表达式，比如：a>b

比较运算符==不能误写成=

### 逻辑运算符

| 运算符 | 逻辑表达式 | 描述                                                         | 实例              |
| ------ | ---------- | ------------------------------------------------------------ | ----------------- |
| and    | x and y    | 布尔“与”，如果x为false，x and y 返回x的值，否则返回y的计算值 | 10 and 20 返回 20 |
| or     | x or y     | 布尔“或”，如果x为true，x or y 返回x的值，否则返回y的计算值   | 10 or 20 返回10   |
| not    | not x      | 布尔“非”，如果x为false，返回true，如果x为true，返回false     |                   |

注意：

and 是种“短路运算符”，只有当第一个为true时才去验证第二个

or 是种“短路运算符”，只有当第一个为false时才去验证第二个

### 位运算符

详见第八章的位运算。

### 运算符的优先级

|      | 运算符从高到低                      | 描述                                 |
| ---- | ----------------------------------- | ------------------------------------ |
| 0    | （expressions）                     | 加括号的表达式                       |
| 1    | **                                  | 乘方                                 |
| 1    | *,@,/,//,%                          | 乘，矩阵乘，除，整除，取余           |
| 1    | +,-                                 | 加法，减法                           |
| 2    | >>,<<                               | 右移，左移（移位）                   |
| 2    | &                                   | 按位与                               |
| 2    | ^                                   | 按位异或                             |
| 2    | \|                                  | 按位或                               |
| 3    | in,not in,is,is not,<,<=,>,>=,!=,== | 比较运算符，包括成员检测和标识号检测 |
| 4    | not x                               | 布尔逻辑非                           |
| 4    | and                                 | 布尔逻辑与                           |
| 4    | or                                  | 布尔逻辑或                           |
| 5    | =,%=,/=,//=,-=,+=,*=,**=            | 辅助运算符                           |

1类是算术运算，2类位运算，3类比较运算，4类逻辑运算，5类赋值运算

### 标识符命名规则和规范

python对各种变量，函数和类等命名时使用的字符序列称为标识符

凡是自己可以起名字的地方都叫标识符

命名规则：

1. 由26个英文字母大小写，0-9，_ 组成

2. 数字不可以开头

3. 不可以使用关键字，但能包含关键字
   python内置关键字

   ```python
   False               class               finally             is              return
   None                continue            for                 lambda          try
   True                def                 from                nonlocal        while
   and                 del                 global              not             with
   as                  elif                if                  or              yield
   assert              else                import              pass            async
   await               except              in                  raise
   ```

4. python区分大小写

5. 标识符不能包含空格

标识符命名规范

- 变量名：变量要小写，若有多个单词，使用下划线分开，常量全部大写
- 函数名：函数名一律小写，如果有多个单词，用下划线隔开。另外，私有函数以双下划线开头
- 类名：使用大驼峰命名

大驼峰：多个单词的首字母都用大写开头。例如：MyName

小驼峰：第一个单词的首字母用小写，后面的单词首字母都用大写。例如：myName

`input(prompt)`函数接收到的一切数据都保存为str类型，如果要对接收到的数据做算术运算就要先类型转换。也可以使用如下方法指定获取的数据类型：

```python
age = int(input("请输入年龄："))
```

## 八、进制

| 10进制 | 16进制                             | 8进制                            | 2进制                                                    |
| ------ | ---------------------------------- | -------------------------------- | -------------------------------------------------------- |
| 0      | 0                                  | 0                                | 0                                                        |
| 1      | 1                                  | 1                                | 1                                                        |
| 2      | 2                                  | 2                                | 10<br />（满2进一位，十位表示2）                         |
| 3      | 3                                  | 3                                | 11                                                       |
| 4      | 4                                  | 4                                | 100                                                      |
| 5      | 5                                  | 5                                | 101                                                      |
| 6      | 6                                  | 6                                | 110                                                      |
| 7      | 7                                  | 7                                | 111                                                      |
| 8      | 8                                  | 10<br />（满8进一位，十位表示8） | 1000                                                     |
| 9      | 9                                  | 11                               | 1001                                                     |
| 10     | A                                  | 12                               | 1010                                                     |
| 11     | B                                  | 13                               | 1011                                                     |
| 12     | C                                  | 14                               | 1100                                                     |
| 13     | D                                  | 15                               | 1101                                                     |
| 14     | E                                  | 16                               | 1110                                                     |
| 15     | F                                  | 17                               | 1111                                                     |
| 16     | 10<br />（满16进一位，十位表示16） | 20                               | 10000<br/>(每一位表示2的(n-1)次方，结果是再想加)         |
| 17     | 11                                 | 21                               | 10001                                                    |
| 18     | 12                                 | 22                               | 10010<br/>=>1X2\*\*4+0X2\*\*3+0X2\*\*2+1X2\*\*1+0X2\*\*0 |

### 其他转十进制

二进制转十进制规则：从最低位(右边)开始，将每个位上的数乘以2的(位数-1)次方，然后求和。

八进制转十进制规则：从最低位(右边)开始，将每个位上的数乘以8的(位数-1)次方，然后求和。

十六进制转十进制规则：从最低位(右边)开始，将每个位上的数乘以16的(位数-1)次方，然后求和。

### 十进制转其他

十进制转二进制规则，将该数不断除以2，只到商为0为止，然后将每步得到的余数倒过来就是对应的二进制。

```python
print(bin(123))
# 计算过程
# 123/2=61  ...1
# 61/2=30 ...1
#30/2=15 ...0
# 15/2=7 ...1
# 7/2=3 ...1
# 3/2=1 ...1
# 1
#结果是0B1111011
```

十进制转八进制规则，将该数不断除以8，只到商为0为止，然后将每步得到的余数倒过来就是对应的八进制。

```python
print(oct(678))
# 计算过程如下
# 678/8=84 ...6
# 84/8=10 ...4
# 10/8=1 ...2
# 1
# 结果 0o1246
```

十进制转十六进制规则，将该数不断除以16，只到商为0为止，然后将每步得到的余数倒过来就是对应的十六进制。

```python
print(hex(8912))
# 计算过程如下
# 8912/16=557 ...0
# 557/16=34 ...13=>d
# 34/16=2 ...2
# 2
# 结果 0X22d0
```

### 二进制转八进制，十六进制

二进制转八进制规则：从低位开始，将二进制数每三位一组，转成对应的八进制数即可。

```python
#ob11010101 转八进制
# 11 010 101 =》3  2  5
#结果0o325
```

二进制转十六进制规则：从低位开始，将二进制数每四位一组，转成对应的十六进制数即可。

```python
#ob11010101 转十六进制
# 1101 0101 =》13(d) 5
#结果0xd5
```

### 八进制，十六进制转二进制

八进制转二进制规则：将八进制数的每1位，转成对应的一个3位的二进制数即可。

```python
#0o237转二进制
# 7 ==》111
# 3 ==》011
# 2 ==》010
#结果0b10011111
```

十六进制转二进制规则：将十六进制数的每1位，转成对应的一个4位的二进制数即可。

```python
#0X23B转二进制
# B ==》1011
# 3 ==》0011
# 2 ==》0010
#结果0b1000111011
```

### 原码，反码，补码

1. 二进制的最高位是符号位：0表示整数，1表示负数

```python
#  python中一个数由28个字节组成，便于演示现假定一个数就是1个字节（8位)
#  3 ==》0000 0011
#  -3==》1000 0011
```

2. 正数的原码，反码，补码都一样（三码合一）
3. 负数的反码=它的原码符号位不变，其他位取反

```python
# -3 =》 原码：1000 0011
#	 =》 反码：1111 1100
```

4. 负数的补码=它的反码+1，负数的反码 = 负数的补码-1

```python
# -3 =》 原码：1000 0011
#	 =》 反码：1111 1100
#    =》 补码：1111 1101
```

5. 0的反码，补码都是0
6. 在计算机运算的时候，都是以**补码**的方式来运算的

```python
#  1+3
# 1的补码：0000 0001
# 3的补码：0000 0011
# 1+3 =》 0000 0100 （运算结果还是补码）
# 1-3 == 1+(-3)
# 1的补码：0000 0001
# -3的原码：1000 0011 =》反码：1111 1100 =》补码：1111 1101
# 0000 0001 + 1111 1101 =》 1111 1110（得出结果的补码）
# 结果的反码：1111 1110（补码）-1 =》 1111 1101
# 结果的原码: 1000 0010 => -2
```

7. 当我们看运算结果的时候，要看它的原码

### 位运算

| 位运算符 | 名称     | 规则释义                                                     |
| -------- | -------- | ------------------------------------------------------------ |
| ~        | 按位取反 | 对数据的每个二进制位取反，即把1变0,把0变1                    |
| &        | 按位与   | 参与运算的两个值，如果两个相应位都为1，则该位的结果为1，否则为0 |
| ^        | 按位异或 | 当两个对应的二进位相异时，结果为1                            |
| \|       | 按位或   | 只要对应的二个二进位有一个为1时，结果就为1                   |
| <<       | 左移     | 运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，符合位不变，高位丢弃，低位补0 |
| >>       | 右移     | 把“>>”左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数，低位溢出，符号位不变，并用符号位补溢出的高位 |

~ 按位取反案例

```python
# 我们假定使用一个字节来表示一个数字
# ~-2=?
# -2的补码:? 推导步骤：
# -2的原码1000 0010 
#  =>-2的反码 1111 1101
#  =》-2补码 1111 1110
#  =》按位取反：0000 0001(结果是补码)=》00000001(正数的补码就是原码)
#  =>结果就是：1


# ~2=?
# 2 的补码:0000 0010
# 按位取反：1111 1101(结果是补码)
# 补码推导原码（反码：补码-1）=>1111 1100(反码)=>1000 0011(原码)
# 结果=》-3
```

& 按位与

```python
# 分析 2&3 的结果
# 2的补码：0000 0010
# 3的补码：0000 0011
# 按位与： 0000 0010 正数 原码=补码
# 结 果 ：2
```

^ 按位异或

```python
# 分析 2^-3的结果
# 2的补码：0000 0010
# -3的原码：1000 0011
# -3的反码：1111 1100
# -3的补码：1111 1101
#  2^-3:0000 0010
#		1111 1101
#(补码)结果 1111 1111
#结果反码： 1111 1110
#结果原码： 1000 0001
# 结果==》 -1
```

| 按位或

```python
# 分析 2|3的结果
# 2的补码：0000 0010
# 3的补码：0000 0011
# 2|3的补码：0000 0011
# 结果 == 3
```

<< 右移

```python
# 分析 5<<1
# 5的补码：0000 0101
# 5<<1:  0000 1010 (补码)
# 结果：10

# 分析 -5<<1
# -5的原码：1000 0101
# -5的反码：1111 1010
# -5的补码：1111 1011
# -5 <<1: 1111 0110 (补码)
#  结果的反码：1111 0101
#  结果原码： 1000 1010 => -10
# m左移n位相当于 m*2**n
```

\>\> 右移

```python
# 分析 5>>1
# 5的补码：0000 0101
# 5>>1:  0000  0010 (补码)
# 结果：2

# 分析 -5>>1
# -5的原码：1000 0101
# -5的反码：1111 1010
# -5的补码：1111 1011
# -5 >>1:  1111 1101 (补码)
#  结果的反码：1111 1100
#  结果的原码：1000 0011
#  结果： -3
#  m右移n位相当于 m//2**n
```

## 九、程序流程控制

### 顺序控制

程序从上到下逐行地执行，中间没有任何判断和跳转

### 分支控制

让程序有选择的执行，分支控制有三种：

1. 单分支
   **if** 条件表达式 **：**
   	代码块（可以有多条语句)

if基本语法说明

- 当条件表达式为true时，就会执行代码块，如果为false，就不执行

- python缩进非常重要，是用于界定代码块的，相当于其他编程语言里的大括号{ }
- 最短的缩进对较长的有包含关系，缩进前后没有要求，但是每个代码块应具有相同的缩进长度（tab或相同个数的空格）

2. 双分支
   **if** 条件表达式**：**
       执行代码块1
   **else：**
       执行代码块2

3. 多分支
   **if** 条件表达式1**:**
      执行代码块1
   **elif** 条件表达式2**:**
       执行代码块2
   ....
   **else:**
   
   ​    执行代码块n+1
   
4. 嵌套分支

   - 嵌套分支：在一个分支结构中又嵌套了另一个分支结构
   - 里面的分支结构称为内存分支，外面的分支结构称为外层分支
   - 规范：不要超过3层（可读性不好）

### 循环控制

**for循环**

```python
# 基本语法
for <变量> in <范围/序列>:
​	<循环操作语句>
```

可以通过`range()`函数快速生成序列。range(start=0, stop, step=1) range默认的start是0，step步长是1。range()生成的数列的前闭后开的，列： range(1,5) 包含1，不包含5。

for 可以和else配合使用，如果正常循环完循环体就会执行else代码块，如果循环体被中断（break），则不会执行else代码块。

**while循环**

```python
# 基本语法
while 判断条件:
    循环操作语句
    
#实例
i=1
while i<=10:
    print('hello',i)
    i+=1
# while 可以和else 配合使用
#语法
i=0
while i<3:
    print('i小于3')
    i+=1
else：
	print('i大于等于3')
```

**多重循环控制**

打印空心金字塔【化繁为简，先死后活】

```python
#分析过程详见，star.py文件
#先死后活，把层数改成不固定,最终结果：
total_level = 10
for i in range(1,total_level + 1):
    for k in range(total_level - i):  # 每行输出的空格数为总层减当前层
        print(" ",end="")  # 输出第一个星前面的空格
    for j in range(2 * i - 1): #每层输出的星总个数
        if j == 0 or j == 2*(i-1) or i == total_level: # 如果是最后一行或者是每行的第一个和每行的最后一个星就输出
            print("*",end="")
        else:
            print(" ", end="") #否则就输出空格
    print("")
```

```python
#课后练习打印出九九乘法表

for i in range(1, 10):
    for j in range(1, i+1):
        print(f"{i} X {j} = {i*j} ", end=" ")
    print("")
```

### break语句

break语句是用在for或while循环所嵌套的代码

它会终结最近的外层循环，如果循环有可选的else子句，也会跳过该子句。 

如果一个for循环被break锁终结，该循环的控制变量会保持其当前值。

```python
# 实例，随机生成1-100的整数，如果等于97则统计随机生成了多少次
import random
k=0
while True:  #无限循环生成随机数
    num = random.randint(1, 100)
    print(num)
    k += 1       #统计生成次数
    if num == 97:
        break    #退出循环
print(f"循环了{k}次")
```

### continue语句

continue语句用于for或while循环所嵌套的代码中

continue语句用于结束本次循环，继续执行循环的下一个轮次，（继续执行的是：该continue最近的外层循环的下一个轮次）。

### return语句

return使用在函数，表示跳出所在的函数

```python
#return 实例
def f1():
    for i in range(1,5):
        if i == 3:
            return
        	#break
            #continue
        print("i =", i)
    print("结束了for...")
    
#调用f1函数--》执行f1函数
f1()
```

## 十、函数

1.为完成某一功能的程序指令（语句）的集合，称为函数。

2.在python中，函数分为：系统函数，自定义函数。

函数格式：

```python
def 函数名(形参):
    函数体代码
    return 返回值
# 形参可以没有，也可以有多个，多个中间用,隔开
# 如果么诶有return语句，默认返回None，None是内置常量，通常用来表示空值的对象
```

  3.函数中的变量是局部的，函数外不生效

  4.如果同一个文件，出现两个函数名相同的函数，则以就近原则进行调用。

5. 调用函数时，根据函数定义的参数位置来传统参数，这种传参方式就是位置参数，传递的实参和定义的形参顺序和个数必须一致，同时定义的形参，不用指定数据类型，会根据传入的实参决定。

6. 函数可以有多个返回值，返回数据类型不受限制。
7. 函数支持关键字参数
   函数调用时，可以通过“**形参名=实参值**”形式传递参数
   这样可以不受参数传递顺序的限制
8. 函数支持默认参数（缺省参数）
   定义函数时，可以给参数提供默认值，调用函数时，指定了实参，则以指定为准，没有指定，则以默认值为准
   默认参数，需要放在参数列表后
9. 函数支持可变参数（不定长参数）
   应用场景：当调用函数时，不确定传入多少个实参的情况
   传入的多个实参，会被组成一个元祖（tuple），元祖可以存储多个数据项。

```python
def sum(*args): # *表示0个或多个
    print(f"args->{args} 类型是->{type(args)}")
    total=0
    # 对args进行遍历，即对元组便利
    for ele in args:
        total += ele
    return total
```

10. 函数的可变参数还支持多个关键字参数，也就是多个"形参名=实参值"

    应用场景：当调用函数时，不确定传入多少个关键字参数的情况

    传入的多个关键字参数，会被组成一个字典（dict），字典可以存储多个  键=值  的数据项

```py
def person_info(**args):
    print(f"args->{args} 类型->{type(args)}")
    for arg_name in args:
        print(f"参数名->{arg_name} 参数值->{args[arg_name]}")
```

### 函数的传参机制

字符串和数值类型是不可变数据类型，当对应的变量的值发生了变化时，它对应的内存地址会发生改变。

```python
def f1(a):
    print(f"f1() a的值：{a} 地址是：{id(a)}")
    a+=1
    print(f"f1() a的值：{a} 地址是：{id(a)}")
    
a = 10  #假设 10对应的内容地址是：0X123

print(f"调用f1()前 a的值：{a} 地址是：{id(a)}") #此时 a=10，id是0X123
f1(a)  #调用f1()时，因为python的驻留机制，函数内变量a指向函数外的a（并不会开辟新的内存空间）,所以第一条输出 a =10，id是0X123
#当执行a+=1时，函数内变量a对应的值改变，所以此时a的内存地址指向新值的内存地址，原来的10的内存地址不变。第二条输出 a=11，id假设是0X1245
print(f"调用f1()后 a的值：{a} 地址是：{id(a)}") #调用函数不影响函数外的变量，a依然=10，id也还是0X123
```

### 函数递归调用

递归调用示例图：

![image-20250821113619300](.\img\image-20250821113619300.png)

递归重要规则：

1. 执行一个函数时，就创建一个新的栈空间
2. 函数的变量是独立的
3. 递归必须向退出递归的条件逼近，否则就是无限递归，就会出现RecursionError：maximum recursion depth exceeded【死归了】
4. 当一个函数执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁

### 函数作为参数传递

```python
# 定义一个函数，返回两个数的最大值
def get_max_val(num1,num2):
    max_val= num1 if num1>num2 else num2
    return max_val

def fq(fun,num1,num2):
    """
    fun:表示接手一个函数
    """
    return num1+num2,fun(num1,num2)

#调用函数
fq(get_max_val,10,30) #传入一个函数的名称，和两个值
```

函数作为参数传递，传递的不是数据，而是业务处理逻辑

一个函数，可以接收多个函数作为参数传入

### 匿名函数

用于临时创建一个函数，只使用一次的场景

匿名函数基本语法：

lambda 形参列表: 函数体（一行代码）

lambda 关键字，表示定义匿名函数

函数体完成的功能，只能写一行，不能写多行代码

```python
# 你们函数的使用
f1(lambda a,b:a if a>b else b, 10,30)   #lambda 后面的函数就是个匿名函数
```

###  变量作用范围

**全景变量：**在整个程序范围内都可以访问，定义在函数外，拥有全局作用域的变量。

**局部变量：**只能在其被声明的函数范围内访问，定义在函数内部，拥有举报作用域的变量

1. 未在函数内部重新定义n1，那么默认使用全局变量n1
2. 在函数内部重新定义了n1，那么根据就近原则，使用的就是函数内部重新定义的n1
3. 在函数内部使用global 关键字，可以标明指定使用全局变量

## 十一、数据容器（collections）

 数据容器是一种数据类型，有些地方简称为容器

数据容器可以存放多个数据，每一个数据也被称为一个元素

存放的数据/元素可以是任意类型

简单的说，数据容器就是一种可以存放多个数据/元素的数据类型

数据容器可以分为以下五种：

### 列表（list）

列表可以存放多个不同类型数据，即：列表就是一列数据（多个数据）

列表也是一种数据类型

创建一个列表，只需要用逗号分隔的不同的数据项使用方括号括起来即可

```python
# 定义一个列表
list_color=["red","green","white","yellow","black"]
# 取出列表中的元素
list_color[0] #就是 red
```

1. 如果需要一个空列表，可以使用[ ]或者list()
2. 列表的元素可以有多个，而且数据类型没有限制，允许有重复元素，并且是有序的
3. 列表是索引/下标是从0开始的
4. 列表索引必须在指定范围内使用，如list1=[1,2,3]的有效索引为0-2
5. 索引也可以从尾部开始，最后一个元素的索引为-1，往前一位为-2，以此类推
6. 通过 `列表[索引]=新值` 对数据进行更新，使用 `列表.append(值)` 方法来添加元素，使用`del 列表[索引] `语句来删除元素，注意不能超出有效索引范围。
7. 列表是可变序列（列表的元素是可以修改的，修改后，列表变量指向的地址不变，只是数据内容变化）

![2025-08-21_223347](.\img\2025-08-21_223347.jpg)

![2025-08-21_223347](.\img\2025-08-21_224138.jpg)

| 序号 | 列表常用操作方法                                             |
| ---- | ------------------------------------------------------------ |
| 1    | list.append(obj)：在列表末尾添加新的对象                     |
| 2    | list.count(obj)：统计某个元素在列表中出现的次数              |
| 3    | list.extend(seq)：在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） |
| 4    | list.index(ojb)：从列表中找出某个值第一个匹配项的索引位置    |
| 5    | list.insert(index,ojb)：将对象插入列表指定位置               |
| 6    | list.pop([index=-1])：移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 |
| 7    | list.remove(obj)：移除列表中某个值的第一个匹配项             |
| 8    | list.reverse()：反向列表中元素（翻转列表）                   |
| 9    | list.sort(key=None,reverse=False)：对原列表进行排序          |
| 10   | list.clear()：清空列表                                       |
| 11   | list.copy()：复制列表                                        |

列表生成式：就是“生成列表的公式”

基本语法：`[列表元素的表达式 for 自定义变量 in 可迭代对象]`

```python
# 示例
list1 = [ele*2 for ele in range(1,5)] #得到列表 list1=> [2,4,6,8]

#用列表生成式生成内容为[1,4,9,16,25,36,49,64,81,100]
lst = [ele**2 for ele in range(1,11)]
print("lst = ", lst)
```

### 元组（tuple）

 元组（tuple）可以存放多个不同类型数据，元组是不可变序列。（tuple不可变是指当你创建了tuple时候，它就不能改变了，也就是说它也没有append（），insert()这样的方法，但它也有获取某个索引值的方法，但是不能重新赋值）

元组也是一种数据类型

创建一个元组，只要把逗号分隔的不同的数据项，使用圆括号括起来即可。

tuple_a = (100,200,300)

- 创建空元组可以用 `()`或`tuple()`

- 元组的元素可以有多个，而且数据类型没有限制（甚至可以嵌套元组），允许有重复元素，并且是有序的
- 元组的索引/下标是从0开始的
- 元组索引必须在指定范围内使用
- 元组是不可变序列。
- 如果元组内有一个list元素，这该list元素的内容是可以修改的（包括增加，修改，删除等）
- 索引也可以从尾部开始，最后一个元素的索引为-1，往前一位为-2，以此类推
- 定义只有一个元素的元组，需要带上逗号，否则就不是元组类型

```python
tuple_one = (100,)
print(type(tuple_one)) #类型就是元组<class 'tuple'>
tuple_a1=(100)
print(type(tuple_a1)) #类型就是int <class 'int'>
```

- 为什么要引入元组：元组在创建时间和占用的空间上优于列表，元组能够对不需要修改的数据写保护。

| 序号 | 元组常用操作                                               |
| ---- | ---------------------------------------------------------- |
| 1    | len(tuple)：元组元素个数                                   |
| 2    | max(tuple)：返回元组元素最大值                             |
| 3    | min(tuple)：返回元组元素最小值                             |
| 4    | tuple.count(obj)：统计某个元素在元组中出现的次数           |
| 5    | tuple.index(obj)：从元组中找出某个值第一次匹配项的索引位置 |

### 字符串（str）

1. 在python中处理文本数据是使用str对象，也称为 字符串，字符串是由Unicode码位构成的不可变序列。
2. 字符串字面量有三种写法：单引号，双引号，三重引号
3. 字符串是字符的容器，一个字符串可以存放多个字符。

| 序号 | 字符串常用操作                                               |
| ---- | ------------------------------------------------------------ |
| 1    | len(str)：字符串的长度，也就是包含多少个字符                 |
| 2    | str.replace(old,new[,count])：返回字符串的副本，其中出现的所有子字符串old都被被替换为new，如果给出了可选参数count，则只替换前count次出现 |
| 3    | str.split(sep=None,maxsplit=-1)：返回一个由字符串内单词组成的列表，使用sep作为字符串分隔符。如果给出了maxsplit，则最多进行maxsplit次拆分（因此，列表最多会有maxsplit+1个元素）。如果maxsplit未指定为-1，则不限制拆分次数（进行所有可能的拆分） |
| 4    | str.count(sub)：统计指定字符串在字符串中出现的次数           |
| 5    | str.index(sub)：从字符串中找出指定字符串第一个匹配项的索引位置 |
| 6    | str.strip([chars])：返回原字符串的副本，移除其中的前导和末尾字符。chars为指定要移除字符的字符串 |
| 7    | str.lower()：返回原字符串小写的副本                          |
| 8    | str.upper()：返回原字符串大写的副本                          |

**字符串比较：**

- 运算符：> , >= , < , <= , == , !=
- 比较规则：首先比较两个字符串中的第一个字符，如果相等则继续比较下一个字符，依次比较下去，直到两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符将不再被比较。
- 比较原理：两个字符串进行比较时，比较的是其ordinal value（原始码/码值），调用内置函数ord()可以得到指定字符的ordinal value，与内置函数ord对应的的是内置函数chr，调用内置函数chr时指定ordinal value可以得到其对应的字符串。

### 切片操作

什么是切片：从一个序列中，取出一个子序列。

什么是序列：序列是指，内容连续、有序，可使用索引的一类数据容器，列表（list），元组（tuple），字符串都是序列。

```python
# 基本语法
序列[起始索引:结束索引:步长]  
#表示从序列中，从指定的起始索引开始，按照指定的步长，依次取出元素，到指定结束索引为止，截取到一个新的序列
#切片操作是前闭后开，也就是[起始索引:结束索引),即截取的子序列，包括起始索引，但是不包括结束索引的部分
#步长表示，依次取出元素的间隔
# -步长为1：一个一个的取出元素
# -步长为2：每次跳过一个元素取出
# -步长为N:每次跳过N-1个元素取

#案例对字符串进行切片
str = "hello,world"
#需求，截取“hello”
str_slice = str[0:5:1]   #起始索引0，结束索引5，步长1
```

**注意：**

1.切片的起始索引不写默认0，结束索引不行默认取到结尾，步长默认1

2.步长为负数，表示反向取，同时注意起始索引和结束索引也要反向标记。

3.切片操作并不会影响原序列，而是返回了一个新序列

### 集合（set）

集合是由**不重复元素**组成的**无序**容器。

集合对象支持合集、交集、差集等数学运算

创建一个集合，只要用逗号分隔的不同的数据项，并使用{ }括起来即可。

集合不支持索引，集合进行遍历不支持while，只支持for

创建空集合只能用set{}，不能用{}，{}创建的是空字典。

| 序号 | 集合常用操作                                                 |
| ---- | ------------------------------------------------------------ |
| 1    | len(set)：集合元素个数                                       |
| 2    | x in s：检测x是否为s中的成员                                 |
| 3    | set.add(elem)：将元素elem添加到集合中                        |
| 4    | set.remove(elem)：从集合中删除元素elem，如果elem不存在于集合，则会报错keyError |
| 5    | set.pop()：从集合中移除并返回任意一个元素（会影响原集合），如果集合为空会报错keyError |
| 6    | set.clear()：从集合中移除所有元素                            |
| 7    | set.union(others) ：返回一个新集合，其中包含来自原集合以及others指定的所有集合中的元素（求合集 set \| others） |
| 8    | set.intersection( others) ：返回一个新集合，其中包含原集合以及others指定的所有元素中共有的元素（求并集 set & others） |
| 9    | set.difference(others) ：返回一个新集合，其中包含原集合中在others指定的其他集合中不存在的元素（求差集 set - others） |

集合生成式基本语法：

{集合元素的表达式 for 自定义变量 in 可迭代对象}

```python
set1={ ele*2 for ele in range(1,5)}

# 生成的集合是 {2,4,6,8}
```

### 字典（dict）

字典（dict）也是一种常用的数据类型，在其他语言中可能吧字典称为联合内存或联合数组。

字典是一种映射关系，非常适合处理通过xx查询yy的需求，这里的xx我们称为key（键/关键字）,这里的yy我们称为Value（值），即key -- value的映射关系。

创建一个字段，只要把逗号分隔的不同的元素，用{}括起来即可，存储的元素是一个个的**键值对**，实例：

```python
dict_a={"key":"value","key1":"value1",...}
#通过key取出对应的value
dict_a[key]
```

注意事项：

1. 字典的key（关键字）通常是字符串或数字，value可以是任意数据类型。
2. 字典不支持索引，会报keyError
3. 既然字典不支持索引，所以对字典的遍历不支持while，只支持for，注意直接对字典进行遍历，遍历得到的是key

```python
dict_a={"one":1,"two":2,"three":3}
# 三种遍历方式
# 第一种通过key遍历
for k in dict_a:
    print("key:", k,"value:", dict_a[k])
    
# 第二种直接遍历value
for v in dict_a.values():
    print("value:", v)

# 第三种 通过k-v遍历
for k,v in dict_a.items():
    print("key:", k,"value:",v)
```

4. 创建空字典可以通过{}，或者dict()
5. 字典的key必须是唯一的，如果你指定了多个相同的key，后面的键值会覆盖前面的。

| 序号 | 字典常用操作                                                 |
| ---- | ------------------------------------------------------------ |
| 1    | len(d)：返回字典d中的项数                                    |
| 2    | d[key]：返回d中以key为键的项，如果key不存在报keyError错      |
| 3    | d[key]=value：将d[key]设为value，如果key已经存在，则是修改value，如果key没有存在，则是增加key-value |
| 4    | del d[key]：将d[key]从d中移除，如果映射中不存在key则会引发keyError |
| 5    | d.pop(key,[default])：如果key存在于字典中则将其移除并返回其值，否则返回default（会改变d）。如果default未给出且key不存在于字典中，则会引发keyError， |
| 6    | d.keys()：返回字典所有的key                                  |
| 7    | key in d：如果d中存在键key则返回True，否则返回False          |
| 8    | d. clear()：移除字典中的所有元素。                           |

字典生成式：

内置函数zip()：可以将可迭代的对象作为参数，将对象中对应的元素打包成一个元组，返回由这些元组组成的列表。

字典生成式语法：

````python
{ 字典key的表达式:字典value的表达式 for 表示key的变量，表示value的变量 in zip(可迭代对象，可迭代对象) }

#实例
books=["红楼梦","三国演义","西游记","水浒传"]
authors=["曹雪芹","罗贯中","吴承恩","施耐庵"]
{book:author for book,author in zip(books,authors)}
````

### 数据容器特定比较

| 比较项           | 列表(list)               | 元组(tuple)                | 字符串(str) | 集合(set)          | 字典(dict)                          |
| ---------------- | ------------------------ | -------------------------- | ----------- | ------------------ | ----------------------------------- |
| 是否支持多个元素 | Y                        | Y                          | Y           | Y                  | Y                                   |
| 元素类型         | 任意                     | 任意                       | 只支持字符  | 任意               | key：只支持字符串或数字，value:任意 |
| 是否支持元素重复 | Y                        | Y                          | Y           | N                  | key：不能重复，value：可以重复      |
| 是否有序         | Y                        | Y                          | Y           | N                  | 3.6前无序，3.6后开始支持有序        |
| 是否支持索引     | Y                        | Y                          | Y           | N                  | N                                   |
| 可修改性/可变性  | Y                        | N                          | N           | Y                  | Y                                   |
| 使用场景         | 可修改，可重复的多个数据 | 不可修改，可重复的多个数据 | 字符串      | 不可重复的多个数据 | 通过关键字查询对应数据的需求        |
| 定义符号         | []                       | ()                         | ""/''       | {}                 | {key:value}                         |

### **list，tuple，set，dict在函数中的传参机制**

![17561039847039](.\img\17561039847039.jpg)

结论：

1. python数据类型主要有整数int/浮点数float/字符串str/布尔值bool/列表list/元组tuple/字典dict/集合set,数据类型分为两大类，一种是可变数据类型，一种是不可变数据类型
2. 可变数据类型：当该数据类型的变量的值发生了变化，如果他的内存地址不变，那个这个数据类型就是可变数据类型。
   不可变数据类型：当该数据类型的变量的值发生了变化，如果它的内存地址改变了，那么这个数据类型就是不可变数据类型。
3. 不可变的数据类型：数值类型（int，float）、布尔（bool）、字符串（str），元组（tuple）
   可变数据类型：list（列表）、set（集合）、dict（字典）

## 十二、排序和查找

冒泡排序：重复的走访需要排序的元素列表，依次比较两个相邻的元素，如果顺序（从小到大或从大到小）错误就交换它们的位置。重复地进行直到没有相邻的元素需要交换，则元素列表排序完成。

```python
# 通过冒泡排序把列表元素从小到大排序
num_list = [19,24,50,13,80]
#定义函数，完成排序操作
def bubble_sort(my_list):
    #i控制循环轮数，循环轮数为元素个数-1
    for i in range(len(my_list)-1):
        #j控制循环次数，循环次数为循环轮数-j
        for j in range(len(my_list)-1-i):
            #如果前面的元素比后面的元素大，则交换位置
            if my_ist[j] > my_list[j+1]:
                my_ist[j], my_list[j+1] = my_ist[j+1], my_list[j]
# 调用函数
bubble_sort(num_list)
```

**顺序查找**

```python
#顺序查找示例
name_list = ["白眉鹰王","金毛狮王","紫衫龙王","青翼蝠王"]
find_name = "金毛狮王"

def seq_search(my_list,find_val):
    #如果找到就返回元素索引，否则返回-1
    find_index = -1
    for i in range(len(my_list)):
        if my_list[i] == find_val:
            find_index = i
            break
    else:
        print("没有找到")
    return find_index

#调用函数
seq_search(name_list,find_name)

#查找所有的，并把所有的元素索引返回
def seq_search2(my_list,find_val):
    #如果找到就添加到空列表中，直到所有元素查找完
    find_index = []
    for i in range(len(my_list)):
        if my_list[i] == find_val:
            find_index.append(i)
    return find_index
```

**二分查找**

二分查找思路：

1. 将列表排序(例如：从小到大)
2. 找到列表的中间数mid_val和find_val比较
3. 如果mid_val >find_val,则到mid_val的左边查找；如果mid_val <find_val,则到mid_val的右边查找；如果mid_val == find_val,则找到了，直接返回对应的下标即可。
4. 不断重复步骤3，这里就是不断的折半，使用while
5. 如果while结束，都没有找到，说明find_val没有在列表中

 ```python
 #二分查找代码
 num_list = [1,8,10,89,1000,1234]
 def binary_search(my_list,find_val)：
 	find_index = -1
 	left_index,right_index=0,len(my_list)-1
     #如果left_index小于等于right_index则可以继续查找
     while left_index <= right_index :
         mid_index = (eft_index+right_index)//2
         if my_list[mid_index] > find_val:
             right_index = mid_index - 1 #如果要找的值小于中间值，则，最右边的索引移动到中间值前一位
         elif my_list[mid_index]<find_val:
             left_index= mid_index + 1 #如果要找的值大于中间值，则最左边的索引移动到中间值后一位
         else: # 相等
             find_index = mid_index
             break
         return find_index
 ```

99
